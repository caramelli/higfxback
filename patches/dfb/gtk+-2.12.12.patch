# This file is part of HiGFXback

# requires
REQUIRES="atk-build autotools-wrappers-lt-build gdk-pixbuf-build pango-build"

PKG_CONFIG_PATH=/dfb/share/pkgconfig pkg-config --exists --print-errors $REQUIRES || exit 1

# configure (ac-2.62; am-1.7; lt-1.5.26)
libtoolize -c -f; aclocal -I .; autoconf; autoheader; automake -a -c
rm -rf gdk-pixbuf*
PATH=/bin:/dfb/bin PKG_CONFIG_PATH=/dfb/lib/pkgconfig LDFLAGS=-Wl,-rpath,/dfb/lib ./configure --with-gdktarget=directfb --with-system-gdk-pixbuf --prefix=/dfb

# build
make

# install
install -d $DESTDIR/dfb/bin
install demos/gtk-demo/.libs/gtk-demo $DESTDIR/dfb/bin
install gtk/gtk-update-icon-cache $DESTDIR/dfb/bin
install gtk/.libs/gtk-query-immodules-2.0 $DESTDIR/dfb/bin
install -d $DESTDIR/dfb/include/gtk-2.0
install -m 644 gdk/gdkconfig.h $DESTDIR/dfb/include/gtk-2.0
install -d $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdk.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkcairo.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkcolor.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkcursor.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkdisplay.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkdisplaymanager.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkdnd.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkdrawable.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkenumtypes.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkevents.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkfont.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkgc.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkimage.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkinput.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkkeys.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkkeysyms.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkpango.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkpixbuf.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkpixmap.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkprivate.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkproperty.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkregion.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkrgb.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkscreen.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkselection.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkspawn.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdktypes.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkvisual.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/gdkwindow.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -m 644 gdk/directfb/gdkdirectfb.h $DESTDIR/dfb/include/gtk-2.0/gdk
install -d $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtk.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkaboutdialog.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkaccelgroup.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkaccellabel.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkaccelmap.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkaccessible.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkaction.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkactiongroup.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkadjustment.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkalignment.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkarrow.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkaspectframe.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkassistant.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkbbox.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkbin.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkbindings.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkbox.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkbuildable.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkbuilder.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkbutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcalendar.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcelleditable.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcelllayout.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcellrenderer.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcellrendereraccel.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcellrenderercombo.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcellrendererpixbuf.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcellrendererprogress.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcellrendererspin.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcellrenderertext.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcellrenderertoggle.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcellview.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcheckbutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcheckmenuitem.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkclipboard.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkclist.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcolorbutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcolorsel.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcolorseldialog.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcombo.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcombobox.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcomboboxentry.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcontainer.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkctree.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkcurve.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkdebug.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkdialog.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkdnd.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkdrawingarea.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkeditable.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkentry.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkentrycompletion.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkenums.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkeventbox.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkexpander.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkfilechooser.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkfilechooserbutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkfilechooserdialog.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkfilechooserwidget.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkfilefilter.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkfilesel.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkfixed.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkfontbutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkfontsel.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkframe.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkgamma.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkgc.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkhandlebox.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkhbbox.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkhbox.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkhpaned.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkhruler.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkhscale.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkhscrollbar.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkhseparator.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkiconfactory.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkicontheme.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkiconview.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkimage.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkimagemenuitem.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkimcontext.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkimcontextsimple.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkimmulticontext.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkinputdialog.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkinvisible.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkitem.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkitemfactory.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtklabel.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtklayout.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtklinkbutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtklist.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtklistitem.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkliststore.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkmain.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkmarshal.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkmenu.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkmenubar.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkmenuitem.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkmenushell.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkmenutoolbutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkmessagedialog.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkmisc.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkmodules.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtknotebook.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkobject.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkoldeditable.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkoptionmenu.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkpagesetup.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkpaned.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkpapersize.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkpixmap.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkplug.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkpreview.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkprintcontext.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkprintoperation.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkprintoperationpreview.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkprintsettings.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkprogress.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkprogressbar.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkradioaction.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkradiobutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkradiomenuitem.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkradiotoolbutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkrange.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkrc.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkrecentaction.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkrecentchooser.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkrecentchooserdialog.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkrecentchoosermenu.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkrecentchooserwidget.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkrecentfilter.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkrecentmanager.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkruler.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkscale.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkscalebutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkscrollbar.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkscrolledwindow.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkselection.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkseparator.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkseparatormenuitem.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkseparatortoolitem.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtksettings.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtksignal.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtksizegroup.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtksocket.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkspinbutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkstatusbar.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkstatusicon.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkstock.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkstyle.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktable.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktearoffmenuitem.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktext.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktextbuffer.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktextbufferrichtext.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktextchild.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktextdisplay.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktextiter.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktextlayout.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktextmark.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktexttag.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktexttagtable.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktextview.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktipsquery.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktoggleaction.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktogglebutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktoggletoolbutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktoolbar.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktoolbutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktoolitem.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktooltip.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktooltips.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktree.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktreednd.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktreeitem.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktreemodel.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktreemodelfilter.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktreemodelsort.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktreeselection.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktreesortable.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktreestore.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktreeview.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktreeviewcolumn.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktypebuiltins.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtktypeutils.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkuimanager.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkvbbox.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkvbox.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkversion.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkviewport.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkvolumebutton.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkvpaned.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkvruler.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkvscale.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkvscrollbar.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkvseparator.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkwidget.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -m 644 gtk/gtkwindow.h $DESTDIR/dfb/include/gtk-2.0/gtk
install -d $DESTDIR/dfb/include/gtk-unix-print-2.0/gtk
install -m 644 gtk/gtkpagesetupunixdialog.h $DESTDIR/dfb/include/gtk-unix-print-2.0/gtk
install -m 644 gtk/gtkprinter.h $DESTDIR/dfb/include/gtk-unix-print-2.0/gtk
install -m 644 gtk/gtkprintjob.h $DESTDIR/dfb/include/gtk-unix-print-2.0/gtk
install -m 644 gtk/gtkprintunixdialog.h $DESTDIR/dfb/include/gtk-unix-print-2.0/gtk
install -d $DESTDIR/dfb/lib
install gdk/.libs/libgdk-directfb-2.0.so.0.* $DESTDIR/dfb/lib/libgdk-directfb-2.0.so.0
ln -sf libgdk-directfb-2.0.so.0 $DESTDIR/dfb/lib/libgdk-2.0.so
install gtk/.libs/libgtk-directfb-2.0.so.0.* $DESTDIR/dfb/lib/libgtk-directfb-2.0.so.0
ln -sf libgtk-directfb-2.0.so.0 $DESTDIR/dfb/lib/libgtk-2.0.so
install -d $DESTDIR/dfb/lib/pkgconfig
install -m 644 gdk-2.0.pc $DESTDIR/dfb/lib/pkgconfig
install -m 644 gtk+-2.0.pc $DESTDIR/dfb/lib/pkgconfig
install -m 644 gtk+-unix-print-2.0.pc $DESTDIR/dfb/lib/pkgconfig
install -d $DESTDIR/dfb/share/aclocal
install -m 644 m4macros/gtk-2.0.m4 $DESTDIR/dfb/share/aclocal
install -d $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/alphatest.png $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/apple-red.png $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/appwindow.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/assistant.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/background.jpg $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/builder.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/button_box.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/changedisplay.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/clipboard.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/colorsel.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/combobox.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/demo.ui $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/dialog.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/drawingarea.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/editable_cells.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/entry_completion.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/expander.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/floppybuddy.gif $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/gnome-applets.png $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/gnome-calendar.png $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/gnome-foot.png $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/gnome-fs-directory.png $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/gnome-fs-regular.png $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/gnome-gimp.png $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/gnome-gmush.png $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/gnome-gsame.png $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/gnu-keys.png $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/gtk-logo-rgb.gif $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/hypertext.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/iconview.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/iconview_edit.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/images.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/list_store.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/menus.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/panes.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/pickers.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/pixbufs.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/printing.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/rotated_text.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/sizegroup.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/stock_browser.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/textscroll.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/textview.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/tree_store.c $DESTDIR/dfb/share/gtk-2.0/demo
install -m 644 demos/gtk-demo/ui_manager.c $DESTDIR/dfb/share/gtk-2.0/demo

# build.pc
install -d $DESTDIR/dfb/share/pkgconfig
cat > $DESTDIR/dfb/share/pkgconfig/gtk2-build.pc << EOF
Name: gtk+
Version: 2.12.12
Description: GIMP ToolKit
Requires: $REQUIRES

devel=\\
/dfb/include/gtk-2.0/gdkconfig.h \\
/dfb/include/gtk-2.0/gdk/gdk.h \\
/dfb/include/gtk-2.0/gdk/gdkcairo.h \\
/dfb/include/gtk-2.0/gdk/gdkcolor.h \\
/dfb/include/gtk-2.0/gdk/gdkcursor.h \\
/dfb/include/gtk-2.0/gdk/gdkdirectfb.h \\
/dfb/include/gtk-2.0/gdk/gdkdisplay.h \\
/dfb/include/gtk-2.0/gdk/gdkdisplaymanager.h \\
/dfb/include/gtk-2.0/gdk/gdkdnd.h \\
/dfb/include/gtk-2.0/gdk/gdkdrawable.h \\
/dfb/include/gtk-2.0/gdk/gdkenumtypes.h \\
/dfb/include/gtk-2.0/gdk/gdkevents.h \\
/dfb/include/gtk-2.0/gdk/gdkfont.h \\
/dfb/include/gtk-2.0/gdk/gdkgc.h \\
/dfb/include/gtk-2.0/gdk/gdkimage.h \\
/dfb/include/gtk-2.0/gdk/gdkinput.h \\
/dfb/include/gtk-2.0/gdk/gdkkeys.h \\
/dfb/include/gtk-2.0/gdk/gdkkeysyms.h \\
/dfb/include/gtk-2.0/gdk/gdkpango.h \\
/dfb/include/gtk-2.0/gdk/gdkpixbuf.h \\
/dfb/include/gtk-2.0/gdk/gdkpixmap.h \\
/dfb/include/gtk-2.0/gdk/gdkprivate.h \\
/dfb/include/gtk-2.0/gdk/gdkproperty.h \\
/dfb/include/gtk-2.0/gdk/gdkregion.h \\
/dfb/include/gtk-2.0/gdk/gdkrgb.h \\
/dfb/include/gtk-2.0/gdk/gdkscreen.h \\
/dfb/include/gtk-2.0/gdk/gdkselection.h \\
/dfb/include/gtk-2.0/gdk/gdkspawn.h \\
/dfb/include/gtk-2.0/gdk/gdktypes.h \\
/dfb/include/gtk-2.0/gdk/gdkvisual.h \\
/dfb/include/gtk-2.0/gdk/gdkwindow.h \\
/dfb/include/gtk-2.0/gtk/gtk.h \\
/dfb/include/gtk-2.0/gtk/gtkaboutdialog.h \\
/dfb/include/gtk-2.0/gtk/gtkaccelgroup.h \\
/dfb/include/gtk-2.0/gtk/gtkaccellabel.h \\
/dfb/include/gtk-2.0/gtk/gtkaccelmap.h \\
/dfb/include/gtk-2.0/gtk/gtkaccessible.h \\
/dfb/include/gtk-2.0/gtk/gtkaction.h \\
/dfb/include/gtk-2.0/gtk/gtkactiongroup.h \\
/dfb/include/gtk-2.0/gtk/gtkadjustment.h \\
/dfb/include/gtk-2.0/gtk/gtkalignment.h \\
/dfb/include/gtk-2.0/gtk/gtkarrow.h \\
/dfb/include/gtk-2.0/gtk/gtkaspectframe.h \\
/dfb/include/gtk-2.0/gtk/gtkassistant.h \\
/dfb/include/gtk-2.0/gtk/gtkbbox.h \\
/dfb/include/gtk-2.0/gtk/gtkbin.h \\
/dfb/include/gtk-2.0/gtk/gtkbindings.h \\
/dfb/include/gtk-2.0/gtk/gtkbox.h \\
/dfb/include/gtk-2.0/gtk/gtkbuildable.h \\
/dfb/include/gtk-2.0/gtk/gtkbuilder.h \\
/dfb/include/gtk-2.0/gtk/gtkbutton.h \\
/dfb/include/gtk-2.0/gtk/gtkcalendar.h \\
/dfb/include/gtk-2.0/gtk/gtkcelleditable.h \\
/dfb/include/gtk-2.0/gtk/gtkcelllayout.h \\
/dfb/include/gtk-2.0/gtk/gtkcellrenderer.h \\
/dfb/include/gtk-2.0/gtk/gtkcellrendereraccel.h \\
/dfb/include/gtk-2.0/gtk/gtkcellrenderercombo.h \\
/dfb/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h \\
/dfb/include/gtk-2.0/gtk/gtkcellrendererprogress.h \\
/dfb/include/gtk-2.0/gtk/gtkcellrendererspin.h \\
/dfb/include/gtk-2.0/gtk/gtkcellrenderertext.h \\
/dfb/include/gtk-2.0/gtk/gtkcellrenderertoggle.h \\
/dfb/include/gtk-2.0/gtk/gtkcellview.h \\
/dfb/include/gtk-2.0/gtk/gtkcheckbutton.h \\
/dfb/include/gtk-2.0/gtk/gtkcheckmenuitem.h \\
/dfb/include/gtk-2.0/gtk/gtkclipboard.h \\
/dfb/include/gtk-2.0/gtk/gtkclist.h \\
/dfb/include/gtk-2.0/gtk/gtkcolorbutton.h \\
/dfb/include/gtk-2.0/gtk/gtkcolorsel.h \\
/dfb/include/gtk-2.0/gtk/gtkcolorseldialog.h \\
/dfb/include/gtk-2.0/gtk/gtkcombo.h \\
/dfb/include/gtk-2.0/gtk/gtkcombobox.h \\
/dfb/include/gtk-2.0/gtk/gtkcomboboxentry.h \\
/dfb/include/gtk-2.0/gtk/gtkcontainer.h \\
/dfb/include/gtk-2.0/gtk/gtkctree.h \\
/dfb/include/gtk-2.0/gtk/gtkcurve.h \\
/dfb/include/gtk-2.0/gtk/gtkdebug.h \\
/dfb/include/gtk-2.0/gtk/gtkdialog.h \\
/dfb/include/gtk-2.0/gtk/gtkdnd.h \\
/dfb/include/gtk-2.0/gtk/gtkdrawingarea.h \\
/dfb/include/gtk-2.0/gtk/gtkeditable.h \\
/dfb/include/gtk-2.0/gtk/gtkentry.h \\
/dfb/include/gtk-2.0/gtk/gtkentrycompletion.h \\
/dfb/include/gtk-2.0/gtk/gtkenums.h \\
/dfb/include/gtk-2.0/gtk/gtkeventbox.h \\
/dfb/include/gtk-2.0/gtk/gtkexpander.h \\
/dfb/include/gtk-2.0/gtk/gtkfilechooser.h \\
/dfb/include/gtk-2.0/gtk/gtkfilechooserbutton.h \\
/dfb/include/gtk-2.0/gtk/gtkfilechooserdialog.h \\
/dfb/include/gtk-2.0/gtk/gtkfilechooserwidget.h \\
/dfb/include/gtk-2.0/gtk/gtkfilefilter.h \\
/dfb/include/gtk-2.0/gtk/gtkfilesel.h \\
/dfb/include/gtk-2.0/gtk/gtkfixed.h \\
/dfb/include/gtk-2.0/gtk/gtkfontbutton.h \\
/dfb/include/gtk-2.0/gtk/gtkfontsel.h \\
/dfb/include/gtk-2.0/gtk/gtkframe.h \\
/dfb/include/gtk-2.0/gtk/gtkgamma.h \\
/dfb/include/gtk-2.0/gtk/gtkgc.h \\
/dfb/include/gtk-2.0/gtk/gtkhandlebox.h \\
/dfb/include/gtk-2.0/gtk/gtkhbbox.h \\
/dfb/include/gtk-2.0/gtk/gtkhbox.h \\
/dfb/include/gtk-2.0/gtk/gtkhpaned.h \\
/dfb/include/gtk-2.0/gtk/gtkhruler.h \\
/dfb/include/gtk-2.0/gtk/gtkhscale.h \\
/dfb/include/gtk-2.0/gtk/gtkhscrollbar.h \\
/dfb/include/gtk-2.0/gtk/gtkhseparator.h \\
/dfb/include/gtk-2.0/gtk/gtkiconfactory.h \\
/dfb/include/gtk-2.0/gtk/gtkicontheme.h \\
/dfb/include/gtk-2.0/gtk/gtkiconview.h \\
/dfb/include/gtk-2.0/gtk/gtkimage.h \\
/dfb/include/gtk-2.0/gtk/gtkimagemenuitem.h \\
/dfb/include/gtk-2.0/gtk/gtkimcontext.h \\
/dfb/include/gtk-2.0/gtk/gtkimcontextsimple.h \\
/dfb/include/gtk-2.0/gtk/gtkimmulticontext.h \\
/dfb/include/gtk-2.0/gtk/gtkinputdialog.h \\
/dfb/include/gtk-2.0/gtk/gtkinvisible.h \\
/dfb/include/gtk-2.0/gtk/gtkitem.h \\
/dfb/include/gtk-2.0/gtk/gtkitemfactory.h \\
/dfb/include/gtk-2.0/gtk/gtklabel.h \\
/dfb/include/gtk-2.0/gtk/gtklayout.h \\
/dfb/include/gtk-2.0/gtk/gtklinkbutton.h \\
/dfb/include/gtk-2.0/gtk/gtklist.h \\
/dfb/include/gtk-2.0/gtk/gtklistitem.h \\
/dfb/include/gtk-2.0/gtk/gtkliststore.h \\
/dfb/include/gtk-2.0/gtk/gtkmain.h \\
/dfb/include/gtk-2.0/gtk/gtkmarshal.h \\
/dfb/include/gtk-2.0/gtk/gtkmenu.h \\
/dfb/include/gtk-2.0/gtk/gtkmenubar.h \\
/dfb/include/gtk-2.0/gtk/gtkmenuitem.h \\
/dfb/include/gtk-2.0/gtk/gtkmenushell.h \\
/dfb/include/gtk-2.0/gtk/gtkmenutoolbutton.h \\
/dfb/include/gtk-2.0/gtk/gtkmessagedialog.h \\
/dfb/include/gtk-2.0/gtk/gtkmisc.h \\
/dfb/include/gtk-2.0/gtk/gtkmodules.h \\
/dfb/include/gtk-2.0/gtk/gtknotebook.h \\
/dfb/include/gtk-2.0/gtk/gtkobject.h \\
/dfb/include/gtk-2.0/gtk/gtkoldeditable.h \\
/dfb/include/gtk-2.0/gtk/gtkoptionmenu.h \\
/dfb/include/gtk-2.0/gtk/gtkpagesetup.h \\
/dfb/include/gtk-2.0/gtk/gtkpaned.h \\
/dfb/include/gtk-2.0/gtk/gtkpapersize.h \\
/dfb/include/gtk-2.0/gtk/gtkpixmap.h \\
/dfb/include/gtk-2.0/gtk/gtkplug.h \\
/dfb/include/gtk-2.0/gtk/gtkpreview.h \\
/dfb/include/gtk-2.0/gtk/gtkprintcontext.h \\
/dfb/include/gtk-2.0/gtk/gtkprintoperation.h \\
/dfb/include/gtk-2.0/gtk/gtkprintoperationpreview.h \\
/dfb/include/gtk-2.0/gtk/gtkprintsettings.h \\
/dfb/include/gtk-2.0/gtk/gtkprogress.h \\
/dfb/include/gtk-2.0/gtk/gtkprogressbar.h \\
/dfb/include/gtk-2.0/gtk/gtkradioaction.h \\
/dfb/include/gtk-2.0/gtk/gtkradiobutton.h \\
/dfb/include/gtk-2.0/gtk/gtkradiomenuitem.h \\
/dfb/include/gtk-2.0/gtk/gtkradiotoolbutton.h \\
/dfb/include/gtk-2.0/gtk/gtkrange.h \\
/dfb/include/gtk-2.0/gtk/gtkrc.h \\
/dfb/include/gtk-2.0/gtk/gtkrecentaction.h \\
/dfb/include/gtk-2.0/gtk/gtkrecentchooser.h \\
/dfb/include/gtk-2.0/gtk/gtkrecentchooserdialog.h \\
/dfb/include/gtk-2.0/gtk/gtkrecentchoosermenu.h \\
/dfb/include/gtk-2.0/gtk/gtkrecentchooserwidget.h \\
/dfb/include/gtk-2.0/gtk/gtkrecentfilter.h \\
/dfb/include/gtk-2.0/gtk/gtkrecentmanager.h \\
/dfb/include/gtk-2.0/gtk/gtkruler.h \\
/dfb/include/gtk-2.0/gtk/gtkscale.h \\
/dfb/include/gtk-2.0/gtk/gtkscalebutton.h \\
/dfb/include/gtk-2.0/gtk/gtkscrollbar.h \\
/dfb/include/gtk-2.0/gtk/gtkscrolledwindow.h \\
/dfb/include/gtk-2.0/gtk/gtkselection.h \\
/dfb/include/gtk-2.0/gtk/gtkseparator.h \\
/dfb/include/gtk-2.0/gtk/gtkseparatormenuitem.h \\
/dfb/include/gtk-2.0/gtk/gtkseparatortoolitem.h \\
/dfb/include/gtk-2.0/gtk/gtksettings.h \\
/dfb/include/gtk-2.0/gtk/gtksignal.h \\
/dfb/include/gtk-2.0/gtk/gtksizegroup.h \\
/dfb/include/gtk-2.0/gtk/gtksocket.h \\
/dfb/include/gtk-2.0/gtk/gtkspinbutton.h \\
/dfb/include/gtk-2.0/gtk/gtkstatusbar.h \\
/dfb/include/gtk-2.0/gtk/gtkstatusicon.h \\
/dfb/include/gtk-2.0/gtk/gtkstock.h \\
/dfb/include/gtk-2.0/gtk/gtkstyle.h \\
/dfb/include/gtk-2.0/gtk/gtktable.h \\
/dfb/include/gtk-2.0/gtk/gtktearoffmenuitem.h \\
/dfb/include/gtk-2.0/gtk/gtktext.h \\
/dfb/include/gtk-2.0/gtk/gtktextbuffer.h \\
/dfb/include/gtk-2.0/gtk/gtktextbufferrichtext.h \\
/dfb/include/gtk-2.0/gtk/gtktextchild.h \\
/dfb/include/gtk-2.0/gtk/gtktextdisplay.h \\
/dfb/include/gtk-2.0/gtk/gtktextiter.h \\
/dfb/include/gtk-2.0/gtk/gtktextlayout.h \\
/dfb/include/gtk-2.0/gtk/gtktextmark.h \\
/dfb/include/gtk-2.0/gtk/gtktexttag.h \\
/dfb/include/gtk-2.0/gtk/gtktexttagtable.h \\
/dfb/include/gtk-2.0/gtk/gtktextview.h \\
/dfb/include/gtk-2.0/gtk/gtktipsquery.h \\
/dfb/include/gtk-2.0/gtk/gtktoggleaction.h \\
/dfb/include/gtk-2.0/gtk/gtktogglebutton.h \\
/dfb/include/gtk-2.0/gtk/gtktoggletoolbutton.h \\
/dfb/include/gtk-2.0/gtk/gtktoolbar.h \\
/dfb/include/gtk-2.0/gtk/gtktoolbutton.h \\
/dfb/include/gtk-2.0/gtk/gtktoolitem.h \\
/dfb/include/gtk-2.0/gtk/gtktooltip.h \\
/dfb/include/gtk-2.0/gtk/gtktooltips.h \\
/dfb/include/gtk-2.0/gtk/gtktree.h \\
/dfb/include/gtk-2.0/gtk/gtktreednd.h \\
/dfb/include/gtk-2.0/gtk/gtktreeitem.h \\
/dfb/include/gtk-2.0/gtk/gtktreemodel.h \\
/dfb/include/gtk-2.0/gtk/gtktreemodelfilter.h \\
/dfb/include/gtk-2.0/gtk/gtktreemodelsort.h \\
/dfb/include/gtk-2.0/gtk/gtktreeselection.h \\
/dfb/include/gtk-2.0/gtk/gtktreesortable.h \\
/dfb/include/gtk-2.0/gtk/gtktreestore.h \\
/dfb/include/gtk-2.0/gtk/gtktreeview.h \\
/dfb/include/gtk-2.0/gtk/gtktreeviewcolumn.h \\
/dfb/include/gtk-2.0/gtk/gtktypebuiltins.h \\
/dfb/include/gtk-2.0/gtk/gtktypeutils.h \\
/dfb/include/gtk-2.0/gtk/gtkuimanager.h \\
/dfb/include/gtk-2.0/gtk/gtkvbbox.h \\
/dfb/include/gtk-2.0/gtk/gtkvbox.h \\
/dfb/include/gtk-2.0/gtk/gtkversion.h \\
/dfb/include/gtk-2.0/gtk/gtkviewport.h \\
/dfb/include/gtk-2.0/gtk/gtkvolumebutton.h \\
/dfb/include/gtk-2.0/gtk/gtkvpaned.h \\
/dfb/include/gtk-2.0/gtk/gtkvruler.h \\
/dfb/include/gtk-2.0/gtk/gtkvscale.h \\
/dfb/include/gtk-2.0/gtk/gtkvscrollbar.h \\
/dfb/include/gtk-2.0/gtk/gtkvseparator.h \\
/dfb/include/gtk-2.0/gtk/gtkwidget.h \\
/dfb/include/gtk-2.0/gtk/gtkwindow.h \\
/dfb/include/gtk-unix-print-2.0/gtk/gtkpagesetupunixdialog.h \\
/dfb/include/gtk-unix-print-2.0/gtk/gtkprinter.h \\
/dfb/include/gtk-unix-print-2.0/gtk/gtkprintjob.h \\
/dfb/include/gtk-unix-print-2.0/gtk/gtkprintunixdialog.h \\
/dfb/lib/libgdk-2.0.so \\
/dfb/lib/libgtk-2.0.so \\
/dfb/lib/pkgconfig/gdk-2.0.pc \\
/dfb/lib/pkgconfig/gtk+-2.0.pc \\
/dfb/lib/pkgconfig/gtk+-unix-print-2.0.pc \\
/dfb/share/aclocal/gtk-2.0.m4

exec=\\
/dfb/bin/gtk-demo \\
/dfb/bin/gtk-query-immodules-2.0 \\
/dfb/bin/gtk-update-icon-cache \\
/dfb/lib/libgdk-directfb-2.0.so.0 \\
/dfb/lib/libgtk-directfb-2.0.so.0 \\
/dfb/share/gtk-2.0/demo/alphatest.png \\
/dfb/share/gtk-2.0/demo/apple-red.png \\
/dfb/share/gtk-2.0/demo/appwindow.c \\
/dfb/share/gtk-2.0/demo/assistant.c \\
/dfb/share/gtk-2.0/demo/background.jpg \\
/dfb/share/gtk-2.0/demo/builder.c \\
/dfb/share/gtk-2.0/demo/button_box.c \\
/dfb/share/gtk-2.0/demo/changedisplay.c \\
/dfb/share/gtk-2.0/demo/clipboard.c \\
/dfb/share/gtk-2.0/demo/colorsel.c \\
/dfb/share/gtk-2.0/demo/combobox.c \\
/dfb/share/gtk-2.0/demo/demo.ui \\
/dfb/share/gtk-2.0/demo/dialog.c \\
/dfb/share/gtk-2.0/demo/drawingarea.c \\
/dfb/share/gtk-2.0/demo/editable_cells.c \\
/dfb/share/gtk-2.0/demo/entry_completion.c \\
/dfb/share/gtk-2.0/demo/expander.c \\
/dfb/share/gtk-2.0/demo/floppybuddy.gif \\
/dfb/share/gtk-2.0/demo/gnome-applets.png \\
/dfb/share/gtk-2.0/demo/gnome-calendar.png \\
/dfb/share/gtk-2.0/demo/gnome-foot.png \\
/dfb/share/gtk-2.0/demo/gnome-fs-directory.png \\
/dfb/share/gtk-2.0/demo/gnome-fs-regular.png \\
/dfb/share/gtk-2.0/demo/gnome-gimp.png \\
/dfb/share/gtk-2.0/demo/gnome-gmush.png \\
/dfb/share/gtk-2.0/demo/gnome-gsame.png \\
/dfb/share/gtk-2.0/demo/gnu-keys.png \\
/dfb/share/gtk-2.0/demo/gtk-logo-rgb.gif \\
/dfb/share/gtk-2.0/demo/hypertext.c \\
/dfb/share/gtk-2.0/demo/iconview.c \\
/dfb/share/gtk-2.0/demo/iconview_edit.c \\
/dfb/share/gtk-2.0/demo/images.c \\
/dfb/share/gtk-2.0/demo/list_store.c \\
/dfb/share/gtk-2.0/demo/menus.c \\
/dfb/share/gtk-2.0/demo/panes.c \\
/dfb/share/gtk-2.0/demo/pickers.c \\
/dfb/share/gtk-2.0/demo/pixbufs.c \\
/dfb/share/gtk-2.0/demo/printing.c \\
/dfb/share/gtk-2.0/demo/rotated_text.c \\
/dfb/share/gtk-2.0/demo/sizegroup.c \\
/dfb/share/gtk-2.0/demo/stock_browser.c \\
/dfb/share/gtk-2.0/demo/textscroll.c \\
/dfb/share/gtk-2.0/demo/textview.c \\
/dfb/share/gtk-2.0/demo/tree_store.c \\
/dfb/share/gtk-2.0/demo/ui_manager.c
EOF

exit
--- gtk+-2.12.12.orig/Makefile.am
+++ gtk+-2.12.12/Makefile.am
@@ -1,6 +1,6 @@
 ## Makefile.am for GTK+
 
-SRC_SUBDIRS = gdk-pixbuf gdk gtk modules demos tests perf contrib
+SRC_SUBDIRS = $(GDK_PIXBUF_SUBDIRS) gdk gtk modules demos tests perf contrib
 SUBDIRS = po po-properties $(SRC_SUBDIRS) docs m4macros
 
 # require automake 1.4
@@ -135,7 +135,7 @@
 	cp gdk-2.0-uninstalled.pc gdk-$(GDKTARGET)-2.0-uninstalled.pc
 
 pkgconfigdir = $(libdir)/pkgconfig
-pkgconfig_DATA= gdk-pixbuf-2.0.pc gdk-$(GDKTARGET)-2.0.pc gtk+-$(GDKTARGET)-2.0.pc
+pkgconfig_DATA= $(GDK_PIXBUF_PC) gdk-$(GDKTARGET)-2.0.pc gtk+-$(GDKTARGET)-2.0.pc
 
 if OS_UNIX
 pkgconfig_DATA += gtk+-unix-print-2.0.pc
--- gtk+-2.12.12.orig/configure.in
+++ gtk+-2.12.12/configure.in
@@ -93,6 +93,10 @@
 AC_SUBST(LT_VERSION_INFO)
 AC_SUBST(LT_CURRENT_MINUS_AGE)
 
+AC_ARG_WITH(system-gdk-pixbuf,
+            [AC_HELP_STRING([--with-system-gdk-pixbuf], [use system gdk-pixbuf library])])
+
+if test "x$with_system_gdk_pixbuf" != "xyes"; then
 
 #
 # gdk-pixbuf gets versioned separately, and for now, using standard
@@ -107,6 +111,8 @@
 AC_SUBST(GDK_PIXBUF_MICRO)
 AC_SUBST(GDK_PIXBUF_VERSION)
 
+fi
+
 GETTEXT_PACKAGE=gtk20
 AC_SUBST(GETTEXT_PACKAGE)
 AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE,"$GETTEXT_PACKAGE")
@@ -125,6 +131,7 @@
     ;;
 esac
 AC_MSG_RESULT([$os_win32])
+AC_SUBST(MATH_LIB)
 
 case $host in
   *-*-linux*)
@@ -690,6 +697,31 @@
 # Checks for gdk-pixbuf
 ##################################################
 
+if test "x$with_system_gdk_pixbuf" = "xyes"; then
+
+AM_CONDITIONAL(BUILD_DYNAMIC_MODULES, true)
+AM_CONDITIONAL(INCLUDE_PNG, true)
+AM_CONDITIONAL(INCLUDE_BMP, true)
+AM_CONDITIONAL(INCLUDE_WBMP, true)
+AM_CONDITIONAL(INCLUDE_GIF, true)
+AM_CONDITIONAL(INCLUDE_ICO, true)
+AM_CONDITIONAL(INCLUDE_ANI, true)
+AM_CONDITIONAL(INCLUDE_JPEG, true)
+AM_CONDITIONAL(INCLUDE_PNM, true)
+AM_CONDITIONAL(INCLUDE_RAS, true)
+AM_CONDITIONAL(INCLUDE_TIFF, true)
+AM_CONDITIONAL(INCLUDE_XPM, true)
+AM_CONDITIONAL(INCLUDE_XBM, true)
+AM_CONDITIONAL(INCLUDE_TGA, true)
+AM_CONDITIONAL(INCLUDE_PCX, true)
+AM_CONDITIONAL(HAVE_TIFF, true)
+AM_CONDITIONAL(HAVE_PNG, true)
+AM_CONDITIONAL(HAVE_JPEG, true)
+AM_CONDITIONAL(USE_MEDIALIB, false)
+AM_CONDITIONAL(USE_MEDIALIB25, false)
+
+else
+
 dnl ********************************************************
 dnl * See whether we need to load our modules as .la files *
 dnl ********************************************************
@@ -980,6 +1012,8 @@
 AM_CONDITIONAL(USE_MEDIALIB, test $use_mlib = yes)
 AM_CONDITIONAL(USE_MEDIALIB25, test $use_mlib25 = yes)
 
+fi
+
 # Checks to see if we should compile in MMX support (there will be
 # a runtime test when the code is actually run to see if it should
 # be used - this just checks if we can compile it.)
@@ -1021,7 +1055,7 @@
 AM_CONDITIONAL(USE_MMX, test x$use_mmx_asm = xyes)
 
 REBUILD_PNGS=
-if test -z "$LIBPNG"; then
+if test "x$with_system_gdk_pixbuf" != "xyes" && test -z "$LIBPNG"; then
   REBUILD_PNGS=#
 fi
 
@@ -1029,12 +1063,25 @@
 
 AM_CONDITIONAL(CROSS_COMPILING, test $cross_compiling = yes)
 
-if test $cross_compiling = yes; then
+if test "x$with_system_gdk_pixbuf" = "xyes" || test $cross_compiling = yes; then
   AC_PATH_PROG(GDK_PIXBUF_CSOURCE, gdk-pixbuf-csource, no)
+else
+  GDK_PIXBUF_CSOURCE="GDK_PIXBUF_MODULE_FILE=\$(top_builddir)/gdk-pixbuf/gdk-pixbuf.loaders \$(top_builddir)/gdk-pixbuf/gdk-pixbuf-csource"
+  GDK_PIXBUF_CSOURCE_DEPS="\$(top_builddir)/gdk-pixbuf/gdk-pixbuf-csource \$(top_builddir)/gdk-pixbuf/gdk-pixbuf.loaders"
+  AC_SUBST(GDK_PIXBUF_CSOURCE_DEPS)
+fi
+
+if test $cross_compiling = yes; then
   AC_PATH_PROG(GTK_UPDATE_ICON_CACHE, gtk-update-icon-cache, no)
   if test x$GTK_UPDATE_ICON_CACHE = xno; then
     REBUILD_PNGS=#
   fi
+else
+  if test "x$with_system_gdk_pixbuf" = "xyes"; then
+    GTK_UPDATE_ICON_CACHE="./gtk-update-icon-cache"
+  else
+    GTK_UPDATE_ICON_CACHE="GDK_PIXBUF_MODULE_FILE=\$(top_builddir)/gdk-pixbuf/gdk-pixbuf.loaders ./gtk-update-icon-cache"
+  fi
 fi
 
 if test ! -f $srcdir/gtk/gtkbuiltincache.h && 
@@ -1047,12 +1094,34 @@
 
 AC_SUBST(REBUILD_PNGS)
 
+if test "x$with_system_gdk_pixbuf" = "xyes"; then
+
+PKG_CHECK_MODULES(GDK_PIXBUF, gdk-pixbuf-2.0)
+
+GDK_PIXBUF_EXTRA_CFLAGS="$GDK_PIXBUF_CFLAGS"
+
+else
+
 GDK_PIXBUF_PACKAGES="gmodule-no-export-2.0 gobject-2.0"
 GDK_PIXBUF_EXTRA_LIBS="$STATIC_LIB_DEPS $MATH_LIB $MEDIA_LIB"
 GDK_PIXBUF_EXTRA_CFLAGS= 
 GDK_PIXBUF_DEP_LIBS="`$PKG_CONFIG --libs $GDK_PIXBUF_PACKAGES` $GDK_PIXBUF_EXTRA_LIBS"
 GDK_PIXBUF_DEP_CFLAGS="`$PKG_CONFIG --cflags  gthread-2.0 $GDK_PIXBUF_PACKAGES $PNG_DEP_CFLAGS_PACKAGES` $GDK_PIXBUF_EXTRA_CFLAGS"
 
+GDK_PIXBUF_CFLAGS="$GDK_PIXBUF_DEP_CFLAGS"
+GDK_PIXBUF_DEPS="\$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-\$(GTK_API_VERSION).la"
+GDK_PIXBUF_LIBS="$GDK_PIXBUF_DEPS"
+GDK_PIXBUF_PC=gdk-pixbuf-2.0.pc
+GDK_PIXBUF_SUBDIRS=gdk-pixbuf
+
+fi
+
+AC_SUBST(GDK_PIXBUF_CFLAGS)
+AC_SUBST(GDK_PIXBUF_DEPS)
+AC_SUBST(GDK_PIXBUF_LIBS)
+AC_SUBST(GDK_PIXBUF_PC)
+AC_SUBST(GDK_PIXBUF_SUBDIRS)
+
 ########################################
 # Windowing system checks
 ########################################
@@ -1755,11 +1824,9 @@
 config.h.win32
 gtk-zip.sh
 Makefile
-gdk-pixbuf-2.0.pc
 gdk-2.0.pc
 gtk+-2.0.pc
 gtk+-unix-print-2.0.pc
-gdk-pixbuf-2.0-uninstalled.pc
 gdk-2.0-uninstalled.pc
 gtk+-2.0-uninstalled.pc
 m4macros/Makefile
@@ -1780,10 +1847,6 @@
 docs/faq/Makefile
 docs/tools/Makefile
 docs/tutorial/Makefile
-gdk-pixbuf/Makefile
-gdk-pixbuf/gdk_pixbuf.rc
-gdk-pixbuf/gdk-pixbuf-features.h
-gdk-pixbuf/pixops/Makefile
 gdk/Makefile
 gdk/x11/Makefile
 gdk/win32/Makefile
@@ -1814,6 +1877,16 @@
 contrib/gdk-pixbuf-xlib/Makefile
 contrib/gdk-pixbuf-xlib/gdk-pixbuf-xlib-2.0.pc
 ])
+if test "x$with_system_gdk_pixbuf" != "xyes"; then
+AC_CONFIG_FILES([
+gdk-pixbuf-2.0.pc
+gdk-pixbuf-2.0-uninstalled.pc
+gdk-pixbuf/Makefile
+gdk-pixbuf/gdk_pixbuf.rc
+gdk-pixbuf/gdk-pixbuf-features.h
+gdk-pixbuf/pixops/Makefile
+])
+fi
 
 AC_OUTPUT
 
--- gtk+-2.12.12.orig/demos/Makefile.am
+++ gtk+-2.12.12/demos/Makefile.am
@@ -12,12 +12,12 @@
 	$(GTK_DEP_CFLAGS)
 
 DEPS = 									\
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
+	$(GDK_PIXBUF_DEPS)						\
 	$(top_builddir)/gdk/$(gdktargetlib) 				\
 	$(top_builddir)/gtk/$(gtktargetlib)
 
 LDADDS = 								\
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
+	$(GDK_PIXBUF_LIBS)						\
 	$(top_builddir)/gdk/$(gdktargetlib)        			\
 	$(top_builddir)/gtk/$(gtktargetlib)
 
@@ -34,13 +34,8 @@
 BUILT_SOURCES = test-inline-pixbufs.h
 endif
 
-if CROSS_COMPILING
 pixbuf_csource=$(GDK_PIXBUF_CSOURCE)
-pixbuf_csource_deps=
-else
-pixbuf_csource=GDK_PIXBUF_MODULE_FILE=$(top_builddir)/gdk-pixbuf/gdk-pixbuf.loaders $(top_builddir)/gdk-pixbuf/gdk-pixbuf-csource
-pixbuf_csource_deps=$(top_builddir)/gdk-pixbuf/gdk-pixbuf-csource $(top_builddir)/gdk-pixbuf/gdk-pixbuf.loaders 
-endif
+pixbuf_csource_deps=$(GDK_PIXBUF_CSOURCE_DEPS)
 
 test-inline-pixbufs.h: $(pixbuf_csource_deps) apple-red.png gnome-foot.png
 	$(pixbuf_csource) --raw --build-list		\
@@ -61,7 +56,7 @@
 testpixbuf_save_LDADD = $(LDADDS)
 testpixbuf_scale_LDADD = $(LDADDS)
 testanimation_LDADD = $(LDADDS)
-pixbuf_demo_LDADD = $(LDADDS)
+pixbuf_demo_LDADD = $(LDADDS) $(MATH_LIB)
 
 testpixbuf_SOURCES = testpixbuf.c pixbuf-init.c
 testpixbuf_drawable_SOURCES = testpixbuf-drawable.c pixbuf-init.c
--- gtk+-2.12.12.orig/demos/gtk-demo/Makefile.am
+++ gtk+-2.12.12/demos/gtk-demo/Makefile.am
@@ -47,12 +47,13 @@
 	$(GTK_DEP_CFLAGS)
 
 DEPS = \
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
+	$(GDK_PIXBUF_DEPS)						\
 	$(top_builddir)/gdk/$(gdktargetlib) 				\
 	$(top_builddir)/gtk/$(gtktargetlib)
 
 LDADDS = \
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
+	$(GDK_PIXBUF_LIBS)						\
+	$(MATH_LIB)							\
 	$(top_builddir)/gdk/$(gdktargetlib)        			\
 	$(top_builddir)/gtk/$(gtktargetlib)
 
--- gtk+-2.12.12.orig/docs/tools/Makefile.am
+++ gtk+-2.12.12/docs/tools/Makefile.am
@@ -7,12 +7,12 @@
 	$(GTK_DEP_CFLAGS)
 
 DEPS = 									\
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
+	$(GDK_PIXBUF_DEPS)						\
 	$(top_builddir)/gdk/$(gdktargetlib) 				\
 	$(top_builddir)/gtk/$(gtktargetlib)
 
 LDADDS = 								\
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
+	$(GDK_PIXBUF_LIBS)						\
 	$(top_builddir)/gdk/$(gdktargetlib)        			\
 	$(top_builddir)/gtk/$(gtktargetlib)				\
 	$(GTK_DEP_LIBS)
--- gtk+-2.12.12.orig/gdk/Makefile.am
+++ gtk+-2.12.12/gdk/Makefile.am
@@ -25,7 +25,6 @@
 	-DGDK_COMPILATION		\
 	-I$(top_srcdir)			\
 	-I$(top_builddir)/gdk		\
-	-I$(top_srcdir)/gdk-pixbuf 	\
 	-DGDK_PIXBUF_DISABLE_DEPRECATED \
 	$(GTK_DEBUG_FLAGS) 		\
 	$(GDK_DEP_CFLAGS)
@@ -144,22 +143,22 @@
 
 libgdk_directfb_2_0_la_SOURCES = $(common_sources) 
 libgdk_directfb_2_0_la_LIBADD = directfb/libgdk-directfb.la $(GDK_DEP_LIBS) \
-  $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la
+  $(GDK_PIXBUF_LIBS)
 libgdk_directfb_2_0_la_LDFLAGS = $(LDADD)
 
 libgdk_x11_2_0_la_SOURCES = $(common_sources)
 libgdk_x11_2_0_la_LIBADD = x11/libgdk-x11.la $(GDK_DEP_LIBS) \
-  $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la
+  $(GDK_PIXBUF_LIBS)
 libgdk_x11_2_0_la_LDFLAGS = $(LDADD)
 
 libgdk_quartz_2_0_la_SOURCES = $(common_sources) gdkkeynames.c
 libgdk_quartz_2_0_la_LIBADD = quartz/libgdk-quartz.la $(GDK_DEP_LIBS) \
-  $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la
+  $(GDK_PIXBUF_LIBS)
 libgdk_quartz_2_0_la_LDFLAGS = $(LDADD)
 
 libgdk_win32_2_0_la_SOURCES = $(common_sources) gdkkeynames.c
 libgdk_win32_2_0_la_LIBADD = win32/libgdk-win32.la $(GDK_DEP_LIBS) \
-  $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la
+  $(GDK_PIXBUF_LIBS)
 libgdk_win32_2_0_la_DEPENDENCIES = win32/libgdk-win32.la win32/rc/gdk-win32-res.o gdk.def
 libgdk_win32_2_0_la_LDFLAGS = -Wl,win32/rc/gdk-win32-res.o -export-symbols $(srcdir)/gdk.def $(LDADD)
 
--- gtk+-2.12.12.orig/gdk/directfb/Makefile.am
+++ gtk+-2.12.12/gdk/directfb/Makefile.am
@@ -2,18 +2,16 @@
 
 libgdkincludedir = $(includedir)/gtk-2.0/gdk
 
-INCLUDES = 		\
+INCLUDES =				\
 	-DG_LOG_DOMAIN=\"Gdk-DirectFB\"	\
-	-DGDK_COMPILATION \
+	-DGDK_COMPILATION		\
 	-I$(top_srcdir)			\
 	-I$(top_srcdir)/gdk		\
 	-I$(top_builddir)/gdk		\
-	-DG_DISABLE_DEPRECATED		\
-	@GTK_DEBUG_FLAGS@		\
-	@GDK_DEP_CFLAGS@		
+	$(GTK_DEBUG_FLAGS) 		\
+	$(GDK_DEP_CFLAGS)
 
-LDADDS = 		\
-	@GDK_DEP_LIBS@		
+LDADDS = $(GDK_DEP_LIBS)
 
 noinst_LTLIBRARIES = libgdk-directfb.la
 
--- gtk+-2.12.12.orig/gdk/directfb/gdkcolor-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkcolor-directfb.c
@@ -31,29 +31,21 @@
  */
 
 #include "config.h"
-#include "gdk.h"
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
 
-#include "gdkcolor.h"
-#include "gdkinternals.h"
+#include "gdk.h"
 #include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
 #include "gdkalias.h"
 
-
-typedef struct {
+typedef struct
+{
   GdkColorInfo     *info;
   IDirectFBPalette *palette;
 } GdkColormapPrivateDirectFB;
 
-
-static void  gdk_colormap_init          (GdkColormap      *colormap);
-static void  gdk_colormap_class_init    (GdkColormapClass *klass);
-static void  gdk_colormap_finalize      (GObject          *object);
+static void  gdk_colormap_init               (GdkColormap      *colormap);
+static void  gdk_colormap_class_init         (GdkColormapClass *klass);
+static void  gdk_colormap_finalize           (GObject          *object);
 
 static gint  gdk_colormap_alloc_pseudocolors (GdkColormap *colormap,
                                               GdkColor    *colors,
@@ -61,12 +53,11 @@
                                               gboolean     writeable,
                                               gboolean     best_match,
                                               gboolean    *success);
-static void  gdk_directfb_allocate_color_key (GdkColormap *colormap);
 
+static void  gdk_directfb_allocate_color_key (GdkColormap *colormap);
 
 static GObjectClass *parent_class = NULL;
 
-
 GType
 gdk_colormap_get_type (void)
 {
@@ -152,25 +143,34 @@
     {
     case GDK_VISUAL_PSEUDO_COLOR:
       {
+        DFBResult                   ret;
+        IDirectFB                  *dfb = _gdk_display_dfb->directfb;
         GdkColormapPrivateDirectFB *private;
         DFBPaletteDescription       dsc;
+        IDirectFBPalette           *palette;
+
+        dsc.flags = DPDESC_SIZE;
+        dsc.size  = colormap->size;
+
+        ret = dfb->CreatePalette (dfb, &dsc, &palette);
+        if (ret)
+          {
+            DirectFBError ("gdk_colormap_new: CreatePalette() failed", ret);
+            return NULL;
+          }
 
         colormap->colors = g_new0 (GdkColor, colormap->size);
 
         private = g_new0 (GdkColormapPrivateDirectFB, 1);
         private->info = g_new0 (GdkColorInfo, colormap->size);
+        private->palette = palette;
 
-	if (visual == gdk_visual_get_system())
-	  {
+        if (visual == gdk_visual_get_system())
+          {
             /* save the first (transparent) palette entry */
             private->info[0].ref_count++;
           }
 
-        dsc.flags = DPDESC_SIZE;
-        dsc.size  = colormap->size;
-        _gdk_display->directfb->CreatePalette (
-		_gdk_display->directfb, &dsc, &private->palette);
-
         colormap->windowing_data = private;
 
         gdk_directfb_allocate_color_key (colormap);
@@ -216,6 +216,8 @@
       if (visual->type == GDK_VISUAL_PSEUDO_COLOR)
         {
           GdkColormapPrivateDirectFB *private;
+          GdkWindowObject            *parent_private;
+          GdkWindowImplDirectFB      *parent_impl;
           IDirectFBSurface           *surface;
 
           colormap = g_object_new (gdk_colormap_get_type (), NULL);
@@ -226,9 +228,10 @@
 
           private = g_new0 (GdkColormapPrivateDirectFB, 1);
           private->info = g_new0 (GdkColorInfo, colormap->size);
-	
-          surface=GDK_WINDOW_IMPL_DIRECTFB (
-				GDK_WINDOW_OBJECT (_gdk_parent_root)->impl)->drawable.surface;
+
+          parent_private = GDK_WINDOW_OBJECT (_gdk_parent_root);
+          parent_impl = GDK_WINDOW_IMPL_DIRECTFB (parent_private->impl);
+          surface = parent_impl->drawable.surface;
           surface->GetPalette (surface, &private->palette);
 
           colormap->windowing_data = private;
@@ -261,7 +264,7 @@
 gdk_colormap_change (GdkColormap *colormap,
                      gint         ncolors)
 {
-  g_message ("gdk_colormap_change() is deprecated and unimplemented");
+  D_UNIMPLEMENTED();
 }
 
 gboolean
@@ -272,9 +275,9 @@
                   gulong        *pixels,
                   gint           npixels)
 {
-  /* g_message ("gdk_colors_alloc() is deprecated and unimplemented"); */
+  D_UNIMPLEMENTED();
 
-  return TRUE;  /* return TRUE here to make GdkRGB happy */
+  return TRUE;
 }
 
 void
@@ -283,7 +286,7 @@
                  gint         in_npixels,
                  gulong       planes)
 {
-  /* g_message ("gdk_colors_free() is deprecated and unimplemented"); */
+  D_UNIMPLEMENTED();
 }
 
 void
@@ -535,7 +538,9 @@
               palette->GetEntries (palette, &entry, 1, index);
 
               if (entry.a == 0xFF &&
-                  entry.r == lookup.r && entry.g == lookup.g && entry.b == lookup.b)
+                  entry.r == lookup.r &&
+                  entry.g == lookup.g &&
+                  entry.b == lookup.b)
                 {
                   colors[i].pixel = index;
 
@@ -550,7 +555,8 @@
                 index = j;
 
                 palette->SetEntries (palette, &lookup, 1, index);
-    		private->info[index].flags = 0;
+
+                private->info[index].flags = 0;
 
                 colors[i].pixel = index;
                 colormap->colors[index] = colors[i];
@@ -563,10 +569,10 @@
               !(private->info[index].flags & GDK_COLOR_WRITEABLE))
             {
 #if 0
-               g_print ("best match for (%d %d %d)  ",
-                       colormap->colors[index].red,
-                       colormap->colors[index].green,
-                       colormap->colors[index].blue);
+               g_print ("best match for (%d %d %d)",
+                        colormap->colors[index].red,
+                        colormap->colors[index].green,
+                        colormap->colors[index].blue);
 #endif
 
               colors[i].pixel = index;
@@ -584,7 +590,7 @@
 #if 0
       g_print ("cmap %p: allocated (%d %d %d) %d [%d]\n", colormap,
                 colors[i].red, colors[i].green, colors[i].blue, colors[i].pixel,
-	        private->info[index].ref_count);
+                private->info[index].ref_count);
 #endif
 
       success[i] = TRUE;
@@ -616,5 +622,6 @@
 
   private->info[255].ref_count++;
 }
+
 #define __GDK_COLOR_X11_C__
 #include "gdkaliasdef.c"
--- gtk+-2.12.12.orig/gdk/directfb/gdkcursor-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkcursor-directfb.c
@@ -29,24 +29,17 @@
  * Written by Denis Oliver Kropp <dok@convergence.de> and
  *            Sven Neumann <sven@convergence.de>
  */
-#include <config.h>
-#include "gdk.h"
 
-#include "gdkdirectfb.h"
+#include "config.h"
+
+#include "gdk.h"
 #include "gdkprivate-directfb.h"
-#include "gdkcursor.h"
 #include "gdkalias.h"
 
 #include "x-cursors.xbm"
 
-#include <directfb_version.h>
-
-#if DIRECTFB_MAJOR_VERSION < 1
-#define u32 __u32
-#define u8 __u8
-#endif
-
-static struct {
+static struct
+{
   const guchar *bits;
   int width, height, hotx, hoty;
   GdkCursor *cursor;
@@ -208,26 +201,28 @@
 };
 
 GdkCursor *
-gdk_cursor_new_for_display (GdkDisplay *display,GdkCursorType cursor_type)
+gdk_cursor_new_for_display (GdkDisplay    *display,
+                            GdkCursorType  cursor_type)
 {
-  GdkCursor *cursor;
-  GdkDisplayDFB *dfb_display  = GDK_DISPLAY_DFB(display);
+  GdkCursor     *cursor;
+  GdkDisplayDFB *dfb_display = GDK_DISPLAY_DFB (display);
 
-  if (cursor_type >= sizeof(stock_cursors)/sizeof(stock_cursors[0]))
+  if (cursor_type >= G_N_ELEMENTS (stock_cursors))
     return NULL;
 
   cursor = stock_cursors[cursor_type].cursor;
   if (!cursor)
     {
-      GdkCursorDirectFB     *private;
-      DFBResult              ret;
-      IDirectFBSurface      *temp;
-      IDirectFBSurface      *shape;
+      DFBResult          ret;
+      GdkCursorDirectFB *private;
+      IDirectFBSurface  *temp;
+      IDirectFBSurface  *shape;
 
-      int width       = stock_cursors[cursor_type+1].width;
-      int height      = stock_cursors[cursor_type+1].height;
+      int width  = stock_cursors[cursor_type+1].width;
+      int height = stock_cursors[cursor_type+1].height;
 
-      temp =gdk_display_dfb_create_surface(dfb_display,DSPF_ARGB,width,height);
+      temp = gdk_display_dfb_create_surface (dfb_display,
+                                             DSPF_ARGB, width, height);
 
       if (!temp)
         {
@@ -235,14 +230,13 @@
         }
       else
         {
-          u32  *dst;
-          int     pitch;
+          void *ptr;
+          int   pitch;
 
-          ret = temp->Lock (temp, DSLF_WRITE, (void**)&dst, &pitch);
+          ret = temp->Lock (temp, DSLF_WRITE, &ptr, &pitch);
           if (ret)
             {
-              DirectFBError ("gdkcursor-directfb.c (gdk_cursor_new): "
-                             "temp->Lock", ret);
+              DirectFBError ("gdk_cursor_new_for_display: Lock() failed", ret);
 
               temp->Release (temp);
 
@@ -255,6 +249,7 @@
               gint  p = ((stock_cursors[cursor_type].width + 7) / 8) * 8;
               gint mp = ((stock_cursors[cursor_type+1].width + 7) / 8) * 8;
 
+              guint32      *dst = ptr;
               const guchar *src;
               const guchar *mask;
 
@@ -263,22 +258,24 @@
               src  = stock_cursors[cursor_type].bits;
               mask = stock_cursors[cursor_type+1].bits;
 
-              mx = stock_cursors[cursor_type+1].hotx - stock_cursors[cursor_type].hotx;
-              my = stock_cursors[cursor_type+1].hoty - stock_cursors[cursor_type].hoty;
+              mx = stock_cursors[cursor_type+1].hotx -
+                     stock_cursors[cursor_type].hotx;
+              my = stock_cursors[cursor_type+1].hoty -
+                     stock_cursors[cursor_type].hoty;
 
               for (y = 0; y < height; y++)
                 {
                   for (x = 0; x < width; x++)
                     {
-                      gint  bit = x-mx + (y-my) * p;
-                      gint mbit =    x +     y  * mp;
+                      gint bit  = x - mx + (y - my) * p;
+                      gint mbit =      x +       y  * mp;
 
-                      u32 color = (x-mx < 0  ||  y-my < 0  ||
-                                     x-mx >= stock_cursors[cursor_type].width  ||
-                                     y-my >= stock_cursors[cursor_type].height)
-                        ? 0x00FFFFFF : (src[bit/8] & (1 << bit%8) ? 0 : 0x00FFFFFF);
+                      u32 color = (x-mx < 0 || y-my < 0                     ||
+                                   x-mx >= stock_cursors[cursor_type].width ||
+                                   y-my >= stock_cursors[cursor_type].height)
+                        ? 0xFFFFFF : (src[bit/8] & (1 << bit%8) ? 0 : 0xFFFFFF);
 
-		      u8  a     = color ? 0xE0 : 0xFF;
+                      u8  a     = color ? 0xE0 : 0xFF;
                       u32 alpha = mask[mbit/8] & (1 << mbit%8) ? (a << 24) : 0;
 
                       dst[x + y*pitch] = alpha | color;
@@ -289,21 +286,22 @@
             }
         }
 
-
       width  += 2;
       height += 2;
 
-      shape=gdk_display_dfb_create_surface(dfb_display,DSPF_ARGB,width,height);
+      shape = gdk_display_dfb_create_surface (dfb_display,
+                                              DSPF_ARGB, width, height);
 
-      if( !shape ) {
-	temp->Release(temp);
-	return NULL;
-      }
+      if (!shape)
+        {
+          temp->Release(temp);
+          return NULL;
+        }
 
       shape->Clear (shape, 0x80, 0x80, 0x80, 0);
 
-      shape->SetBlittingFlags (shape, (DSBLIT_BLEND_COLORALPHA |
-                                       DSBLIT_BLEND_ALPHACHANNEL));
+      shape->SetBlittingFlags (shape, DSBLIT_BLEND_COLORALPHA |
+                                      DSBLIT_BLEND_ALPHACHANNEL);
 
       shape->SetColor (shape, 0, 0, 0, 0x30);
       shape->Blit (shape, temp, NULL, 0, 0);
@@ -357,11 +355,12 @@
   impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (source)->impl);
   mask_impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (mask)->impl);
 
-  int width       = impl->width;
-  int height      = impl->height;
+  int width  = impl->width;
+  int height = impl->height;
+
+  shape = gdk_display_dfb_create_surface (_gdk_display_dfb,
+                                          DSPF_ARGB, width, height);
 
-  shape=gdk_display_dfb_create_surface(_gdk_display,DSPF_ARGB,width,height);
-            
   if (!shape)
     {
       return NULL;
@@ -377,8 +376,8 @@
   shape->Clear (shape, bg->red >> 8, bg->green >> 8, bg->blue >> 8, 0xFF);
 
   shape->SetColor (shape, fg->red >> 8, fg->green >> 8, fg->blue >> 8, 0xFF);
-  shape->SetBlittingFlags (shape,
-                           DSBLIT_BLEND_ALPHACHANNEL | DSBLIT_COLORIZE);
+  shape->SetBlittingFlags (shape, DSBLIT_BLEND_ALPHACHANNEL |
+                                  DSBLIT_COLORIZE);
   shape->Blit (shape, impl->surface, NULL, 0, 0);
 
   shape->SetPorterDuff (shape, DSPD_DST_IN);
@@ -405,64 +404,63 @@
                             gint        x,
                             gint        y)
 {
-GdkPixmap *pixmap, *mask;
- GdkCursor  *cursor;
- gint width, height, depth = 8;
- GdkVisual* visual;
-
- /* FIXME: this is not the right way to set colours */
- GdkColor fg = { 0, 65535, 65535, 65535 };
- GdkColor bg = { 0, 65535, 65535, 65535 };
-
- g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
- g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);
- g_return_val_if_fail (0 <= x && x < gdk_pixbuf_get_width (pixbuf), NULL);
- g_return_val_if_fail (0 <= y && y < gdk_pixbuf_get_height (pixbuf), NULL);
+  GdkPixmap *pixmap, *mask;
+  GdkCursor  *cursor;
+  gint width, height, depth = 8;
+  GdkVisual* visual;
+
+  GdkColor fg = { 0, 65535, 65535, 65535 };
+  GdkColor bg = { 0, 65535, 65535, 65535 };
+
+  g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
+  g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);
+  g_return_val_if_fail (0 <= x && x < gdk_pixbuf_get_width (pixbuf), NULL);
+  g_return_val_if_fail (0 <= y && y < gdk_pixbuf_get_height (pixbuf), NULL);
+
+  width  = gdk_pixbuf_get_width(pixbuf);
+  height = gdk_pixbuf_get_height(pixbuf);
+
+  pixmap = gdk_pixmap_new ( NULL, width, height, depth);
+  mask   = gdk_pixmap_new ( NULL, width, height, 1);
+  visual = gdk_rgb_get_visual ();
+  depth  = visual->depth;
 
- width = gdk_pixbuf_get_width(pixbuf);
- height = gdk_pixbuf_get_height(pixbuf);
+  gdk_pixbuf_render_pixmap_and_mask (pixbuf, &pixmap, &mask, 0);
 
- pixmap = gdk_pixmap_new ( NULL, width, height, depth);
- mask = gdk_pixmap_new ( NULL, width, height, 1);
- visual = gdk_rgb_get_visual ();
- depth = visual->depth;
-
- gdk_pixbuf_render_pixmap_and_mask (pixbuf, &pixmap, &mask, 0);
-
- g_return_val_if_fail (GDK_IS_PIXMAP (pixmap), NULL);
- g_return_val_if_fail (GDK_IS_PIXMAP (mask), NULL);
-
- cursor = gdk_cursor_new_from_pixmap (pixmap, mask, &fg, &bg, x, y) ;
+  g_return_val_if_fail (GDK_IS_PIXMAP (pixmap), NULL);
+  g_return_val_if_fail (GDK_IS_PIXMAP (mask), NULL);
 
- g_object_unref (pixmap);
- g_object_unref (mask);
+  cursor = gdk_cursor_new_from_pixmap (pixmap, mask, &fg, &bg, x, y) ;
 
- /* a cursor of type GDK_CURSOR_IS_PIXMAP is returned */
- return cursor;
+  g_object_unref (pixmap);
+  g_object_unref (mask);
 
+  return cursor;
 }
 
-GdkCursor*
+GdkCursor *
 gdk_cursor_new_from_name (GdkDisplay  *display,
                           const gchar *name)
 {
- GdkCursor *cursor;
- GdkPixbuf *pixbuf;
+  GdkCursor *cursor;
+  GdkPixbuf *pixbuf;
 
- g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
- pixbuf = gdk_pixbuf_new_from_file(name, NULL);
- /* Prevents attempts to load stock X cursors from generating error messages */
- if (pixbuf == NULL)
-   return NULL;
- g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);
- cursor = gdk_cursor_new_from_pixbuf (display, pixbuf, 1, 1);
- g_object_unref (pixbuf);
+  g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
 
- return cursor;
-}
+  pixbuf = gdk_pixbuf_new_from_file(name, NULL);
+  if (pixbuf == NULL)
+    return NULL;
 
+  g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);
 
-GdkPixbuf*
+  cursor = gdk_cursor_new_from_pixbuf (display, pixbuf, 1, 1);
+
+  g_object_unref (pixbuf);
+
+  return cursor;
+}
+
+GdkPixbuf *
 gdk_cursor_get_image (GdkCursor *cursor)
 {
   g_return_val_if_fail (cursor != NULL, NULL);
@@ -470,8 +468,6 @@
   return NULL;
 }
 
-
-
 void
 _gdk_cursor_destroy (GdkCursor *cursor)
 {
@@ -494,46 +490,25 @@
 }
 
 guint
-gdk_display_get_default_cursor_size (GdkDisplay    *display)
+gdk_display_get_default_cursor_size (GdkDisplay *display)
 {
   return 16;
 }
 
-/**
- * gdk_display_get_maximal_cursor_size:
- * @display: a #GdkDisplay
- * @width: the return location for the maximal cursor width
- * @height: the return location for the maximal cursor height
- *
- * Gets the maximal size to use for cursors on @display.
- *
- * Since: 2.4
- */
 void
 gdk_display_get_maximal_cursor_size (GdkDisplay *display,
-                                     guint       *width,
-                                     guint       *height)
+                                     guint      *width,
+                                     guint      *height)
 {
-  *width=gdk_display_get_default_cursor_size(display);
-  *height=*width;
+  *width = gdk_display_get_default_cursor_size (display);
+  *height = *width;
 }
 
-/**
- * gdk_display_supports_cursor_alpha:
- * @display: a #GdkDisplay
- *
- * Returns %TRUE if cursors can use an 8bit alpha channel
- * on @display. Otherwise, cursors are restricted to bilevel
- * alpha (i.e. a mask).
- *
- * Returns: whether cursors can have alpha channels.
- *
- * Since: 2.4
- */
 gboolean
 gdk_display_supports_cursor_alpha (GdkDisplay *display)
 {
   g_return_val_if_fail (GDK_IS_DISPLAY (display), FALSE);
+
   return TRUE;
 }
 
@@ -541,9 +516,9 @@
 gdk_display_supports_cursor_color (GdkDisplay *display)
 {
   g_return_val_if_fail (GDK_IS_DISPLAY (display), FALSE);
+
   return TRUE;
 }
 
 #define __GDK_CURSOR_X11_C__
 #include "gdkaliasdef.c"
-
--- gtk+-2.12.12.orig/gdk/directfb/gdkdirectfb.h
+++ gtk+-2.12.12/gdk/directfb/gdkdirectfb.h
@@ -33,29 +33,53 @@
 #ifndef __GDK_DIRECTFB_H__
 #define __GDK_DIRECTFB_H__
 
-#include <cairo.h>
-#include <directfb.h>
-#include "gdk/gdkprivate.h"
+/*
+ * Group the different Flip()s of several gdk_window_impl_directfb_end_paint()
+ * to improve speed and visual experience, e.g. switching tabs with a single
+ * consistent update on the screen.
+ */
+#ifndef GDK_DIRECTFB_GROUPED_FLIPS
+#define GDK_DIRECTFB_GROUPED_FLIPS      1
+#endif
+
+/*
+ * Until DirectFB provides it, we simply set it here.
+ */
+#ifndef GDK_DIRECTFB_SCREEN_RESOLUTION
+#define GDK_DIRECTFB_SCREEN_RESOLUTION  75.0
+#endif
 
-/* macro for a safe call to DirectFB functions */
-#define DFBCHECK(x...) \
-     {                                                                \
-          int err = x;                                                    \
-          if (err != DFB_OK) {                                        \
-               fprintf( stderr, "%s <%d>:\n\t", __FILE__, __LINE__ ); \
-               DirectFBErrorFatal( #x, err );                         \
-          }                                                           \
-     }
+/*
+ * Enables debugging in all GDK-DirectFB source files.
+ */
+#ifndef GDK_DIRECTFB_DEBUG
+#define GDK_DIRECTFB_DEBUG              0
+#endif
 
+/*
+ * Global debug switch.
+ */
+#ifdef __DIRECT__DEBUG_H__
+#error This file MUST be included BEFORE <direct/debug.h>
+#endif
+#if GDK_DIRECTFB_DEBUG
+#define DIRECT_ENABLE_DEBUG
+#endif
 
-extern GdkWindow * _gdk_parent_root;
+#include <directfb.h>
+#include "gdkprivate.h"
+
+#define GDK_DFB_UNUSED_P(x)  (void) x
+
+extern GdkWindow *_gdk_parent_root;
 
 G_BEGIN_DECLS
 
-#define GDK_ROOT_WINDOW()      _gdk_parent_root 
+#define GDK_ROOT_WINDOW()      _gdk_parent_root
 
 #define GDK_WINDOW_DFB_ID(win) (GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (win)->impl)->dfb_id)
 
+#define GDK_DFB_BITS_PER_PIXEL(format) (((format) == DSPF_RGB32) ? 24 : DFB_BITS_PER_PIXEL(format))
 
 /* used for the --transparent-unfocused hack */
 extern gboolean            gdk_directfb_apply_focus_opacity;
@@ -65,32 +89,31 @@
 extern DFBColor            gdk_directfb_bg_color;
 extern DFBColor            gdk_directfb_bg_color_key;
 
-/* to disable antialiasing */
-extern gboolean            gdk_directfb_monochrome_fonts;
-
-
 /* GTK+-DirectFB specific functions */
 
-void        gdk_directfb_window_set_opacity (GdkWindow             *window,
-                                             guchar                 opacity);
-
-GdkWindow * gdk_directfb_window_new         (GdkWindow             *parent,
-                                             GdkWindowAttr         *attributes,
-                                             gint                   attributes_mask,
-                                             DFBWindowCapabilities  window_caps,
-                                             DFBWindowOptions       window_options,
-                                             DFBSurfaceCapabilities surface_caps);
-
-GdkVisual * gdk_directfb_visual_by_format   (DFBSurfacePixelFormat  pixel_format);
-
-IDirectFBWindow *gdk_directfb_window_lookup(GdkWindow *window);
-IDirectFBSurface *gdk_directfb_surface_lookup(GdkWindow *window);
-
-#if (DIRECTFB_MAJOR_VERSION >= 1)
-GdkWindow *gdk_directfb_create_child_window(GdkWindow *parent,
-                IDirectFBSurface *subsurface);
-#endif
-
+void
+gdk_directfb_window_set_opacity  (GdkWindow              *window,
+                                  guchar                  opacity);
+
+GdkWindow *
+gdk_directfb_window_new          (GdkWindow              *parent,
+                                  GdkWindowAttr          *attributes,
+                                  gint                    attributes_mask,
+                                  DFBWindowCapabilities   window_caps,
+                                  DFBWindowOptions        window_options,
+                                  DFBSurfaceCapabilities  surface_caps);
+
+GdkVisual *
+gdk_directfb_visual_by_format    (DFBSurfacePixelFormat   pixel_format);
+
+IDirectFBWindow *
+gdk_directfb_window_lookup       (GdkWindow              *window);
+IDirectFBSurface *
+gdk_directfb_surface_lookup      (GdkWindow              *window);
+
+GdkWindow *
+gdk_directfb_create_child_window (GdkWindow              *parent,
+                                  IDirectFBSurface       *subsurface);
 
 G_END_DECLS
 
--- gtk+-2.12.12.orig/gdk/directfb/gdkdisplay-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkdisplay-directfb.c
@@ -21,114 +21,98 @@
  * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
  * file for a list of people on the GTK+ Team.  See the ChangeLog
  * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
+ * GTK+ at ftp://ftp.gtk.org/pub/gtk/.
  */
 
-#include <config.h>
 
-#include <glib.h>
+#include "config.h"
+
 #include "gdk.h"
 #include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
-#include "gdkscreen.h"
-#include "gdkdisplaymanager.h"
 #include "gdkintl.h"
 #include "gdkalias.h"
 
+D_DEBUG_DOMAIN( GDKDFB_GrabKeyboard, "GDKDFB/Grab/Kbd", "GDK DirectFB Keyboard Grabbing" );
+D_DEBUG_DOMAIN( GDKDFB_GrabPointer,  "GDKDFB/Grab/Ptr", "GDK DirectFB Pointer Grabbing" );
 
 
-extern void _gdk_visual_init (void);
-extern void _gdk_events_init (void);
-extern void _gdk_input_init (void);
-extern void _gdk_dnd_init (void);
-extern void _gdk_windowing_window_init (void);
-extern void _gdk_windowing_image_init (void);
-extern void _gdk_directfb_keyboard_init      (void);
-
-static gboolean   gdk_directfb_argb_font           = FALSE;
-static gint       gdk_directfb_glyph_surface_cache = 8;
-static gchar 	 *directfb_args;
-
-
-const GOptionEntry _gdk_windowing_args[] =
-{
-  { "dfb",0,0,G_OPTION_ARG_STRING,&directfb_args,N_("directfb arg"),N_("sdl|system")}, 
-  { "dfb-help",0,0,G_OPTION_ARG_NONE, NULL,NULL},
-  { "disable-aa-fonts",0,0,G_OPTION_ARG_INT,&gdk_directfb_monochrome_fonts,NULL,NULL    },
-  { "argb-font",0,0, G_OPTION_ARG_INT, &gdk_directfb_argb_font,NULL,NULL},
-  { "transparent-unfocused",0,0, G_OPTION_ARG_INT, &gdk_directfb_apply_focus_opacity,NULL,NULL },
-  { "glyph-surface-cache",0,0,G_OPTION_ARG_INT,&gdk_directfb_glyph_surface_cache,NULL,NULL },
-  { "enable-color-keying",0,0,G_OPTION_ARG_INT,&gdk_directfb_enable_color_keying,NULL,NULL },
-  { NULL}
+extern void _gdk_visual_init            (void);
+extern void _gdk_events_init            (GdkDisplay *display);
+extern void _gdk_input_init             (void);
+extern void _gdk_dnd_init               (void);
+extern void _gdk_windowing_window_init  (void);
+extern void _gdk_windowing_image_init   (void);
+extern void _gdk_directfb_keyboard_init (void);
+
+const GOptionEntry _gdk_windowing_args[] = {
+  { "transparent-unfocused", 0, 0, G_OPTION_ARG_INT,
+    &gdk_directfb_apply_focus_opacity, NULL, NULL },
+  { "enable-color-keying",   0, 0, G_OPTION_ARG_INT,
+    &gdk_directfb_enable_color_keying, NULL, NULL },
+  { NULL }
 };
 
-/**
-  Main entry point for gdk in 2.6 args are parsed
-**/
-GdkDisplay * gdk_display_open (const gchar *display_name)
+GdkDisplay *
+gdk_display_open (const gchar *display_name)
 {
-
-  if (_gdk_display) {
-    return GDK_DISPLAY_OBJECT(_gdk_display); /* single display only */
-  }
-  DFBResult  ret;
+  DFBResult               ret;
   IDirectFB              *directfb;
   IDirectFBDisplayLayer  *layer;
   IDirectFBInputDevice   *keyboard;
+  int                     argc = 0;
+  char                  **argv = NULL;
 
-  int argc=0;
-  char **argv=NULL;
+  ret = DirectFBInit (&argc, &argv);
 
-#if 0  /* arg hack arg support broken*/
-  if(directfb_args ) {
-	argc=2;
-	argv = (char **)g_malloc(sizeof(char *)*argc);
-	argv[0] = "simple";
-	argv[1] = "--dfb:system=SDL";
-  }
-#endif
-
-  ret = DirectFBInit (&argc,&argv);
   if (ret != DFB_OK)
-{
-      DirectFBError ("gdk_display_open: DirectFBInit", ret);
+    {
+      DirectFBError ("gdk_display_open: DirectFBInit() failed", ret);
       return NULL;
     }
 
-    ret = DirectFBCreate (&directfb);
+  ret = DirectFBCreate (&directfb);
 
   if (ret != DFB_OK)
     {
-      DirectFBError ("gdk_display_open: DirectFBCreate", ret);
+      DirectFBError ("gdk_display_open: DirectFBCreate() failed", ret);
       return NULL;
     }
-  _gdk_display = g_object_new(GDK_TYPE_DISPLAY_DFB,NULL);
-  _gdk_display->directfb=directfb;
+
+  atexit (_gdk_windowing_exit);
+
+  _gdk_display     = g_object_new (GDK_TYPE_DISPLAY_DFB, NULL);
+  _gdk_display_dfb = GDK_DISPLAY_DFB (_gdk_display);
+
+  _gdk_display_dfb->directfb = directfb;
 
   ret = directfb->GetDisplayLayer (directfb, DLID_PRIMARY, &layer);
+
   if (ret != DFB_OK)
     {
-      DirectFBError ("gdk_display_open: GetDisplayLayer", ret);
-      directfb->Release (directfb);
-	  directfb = NULL;
+      DirectFBError ("gdk_display_open: GetDisplayLayer() failed", ret);
       return NULL;
     }
 
-
   ret=directfb->GetInputDevice (directfb, DIDID_KEYBOARD, &keyboard);
 
-  if (ret != DFB_OK){
-      DirectFBError ("gdk_display_open: GetDisplayLayer", ret);
-   	return NULL;
-  }
+  if (ret != DFB_OK)
+    {
+      DirectFBError ("gdk_display_open: GetDisplayLayer() failed", ret);
+      return NULL;
+    }
 
-  _gdk_display->layer=layer;
-  _gdk_display->keyboard=keyboard;
+  _gdk_display_dfb->layer    = layer;
+  _gdk_display_dfb->keyboard = keyboard;
 
-    _gdk_directfb_keyboard_init ();
+  _gdk_directfb_keyboard_init ();
 
+  /* Initialize the screen. */
   _gdk_screen = g_object_new (GDK_TYPE_SCREEN, NULL);
 
+  /* Set the screen resolution. */
+  gdk_screen_set_resolution (_gdk_screen, GDK_DIRECTFB_SCREEN_RESOLUTION);
+
   _gdk_visual_init ();
 
   gdk_screen_set_default_colormap (_gdk_screen,
@@ -139,13 +123,14 @@
   _gdk_input_init ();
   _gdk_dnd_init ();
 
-  _gdk_events_init ();
+  _gdk_events_init (GDK_DISPLAY_OBJECT (_gdk_display));
+
   layer->EnableCursor (layer, 1);
 
   g_signal_emit_by_name (gdk_display_manager_get (),
-			 "display_opened", _gdk_display);
+                         "display_opened", _gdk_display);
 
-  return GDK_DISPLAY_OBJECT(_gdk_display);
+  return GDK_DISPLAY_OBJECT (_gdk_display);
 }
 
 GType
@@ -176,30 +161,42 @@
   return object_type;
 }
 
-IDirectFBSurface * gdk_display_dfb_create_surface (GdkDisplayDFB *display,int format,int width, int height) { 
-	DFBResult              ret;
-	IDirectFBSurface      *temp;
-	DFBSurfaceDescription  dsc;
-	dsc.flags = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
-      	dsc.width       = width;
-      	dsc.height      = height;
-      	dsc.pixelformat = format;
-	ret = display->directfb->CreateSurface (display->directfb, &dsc, &temp);
-        if (ret)
-        {
-          DirectFBError ("gdk_display_dfb_create_surface ", ret);
-          return NULL;
-        }
-	return temp;
-
-}
+IDirectFBSurface *
+gdk_display_dfb_create_surface (GdkDisplayDFB         *display,
+                                DFBSurfacePixelFormat  format,
+                                int                    width,
+                                int                    height)
+{
+  DFBResult              ret;
+  DFBSurfaceDescription  dsc;
+  IDirectFBSurface      *temp;
+
+  dsc.flags       = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
+  dsc.width       = width;
+  dsc.height      = height;
+  dsc.pixelformat = format;
 
+  ret = display->directfb->CreateSurface (display->directfb, &dsc, &temp);
+  if (ret)
+    {
+      DirectFBError ("gdk_display_dfb_create_surface: "
+                     "CreateSurface() failed", ret);
+      return NULL;
+    }
 
+  return temp;
+}
 
 void
 _gdk_windowing_set_default_display (GdkDisplay *display)
 {
-	_gdk_display=GDK_DISPLAY_DFB(display);
+  if (!display)
+    {
+      _gdk_display = NULL;
+      return;
+    }
+
+  g_assert (_gdk_display == display);
 }
 
 G_CONST_RETURN gchar *
@@ -211,42 +208,53 @@
 int
 gdk_display_get_n_screens (GdkDisplay *display)
 {
+  g_return_val_if_fail (GDK_IS_DISPLAY_DFB (display), 0);
+
   return 1;
 }
 
 GdkScreen *
 gdk_display_get_screen (GdkDisplay *display,
-			gint        screen_num)
+                        gint        screen_num)
 {
+  g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
+  g_return_val_if_fail (screen_num == 0, NULL);
+
   return _gdk_screen;
 }
 
 GdkScreen *
 gdk_display_get_default_screen (GdkDisplay *display)
 {
+  g_return_val_if_fail (GDK_IS_DISPLAY_DFB (display), NULL);
+
   return _gdk_screen;
 }
 
 gboolean
 gdk_display_supports_selection_notification (GdkDisplay *display)
 {
-	return FALSE;
+  D_UNIMPLEMENTED();
+
+  return FALSE;
 }
 
-gboolean gdk_display_request_selection_notification  (GdkDisplay *display,
-                                                      GdkAtom     selection)
+gboolean
+gdk_display_request_selection_notification (GdkDisplay *display,
+                                            GdkAtom     selection)
 
 {
+  D_UNIMPLEMENTED();
 
-	g_warning("gdk_display_request_selection_notification Unimplemented function \n");
-	return FALSE;
+  return FALSE;
 }
 
 gboolean
 gdk_display_supports_clipboard_persistence (GdkDisplay *display)
 {
-	g_warning("gdk_display_supports_clipboard_persistence Unimplemented function \n");
-	return FALSE;
+  D_UNIMPLEMENTED();
+
+  return FALSE;
 }
 
 void
@@ -256,36 +264,32 @@
                              GdkAtom    *targets,
                              gint        n_targets)
 {
-
-	g_warning("gdk_display_store_clipboard Unimplemented function \n");
-
+  D_UNIMPLEMENTED();
 }
 
-
 gboolean
 gdk_display_supports_shapes (GdkDisplay *display)
 {
-       return FALSE;
-}
+  g_return_val_if_fail (GDK_IS_DISPLAY_DFB (display), FALSE);
 
+  return FALSE;
+}
 
 gboolean
 gdk_display_supports_input_shapes (GdkDisplay *display)
 {
-       return FALSE;
-}
+  g_return_val_if_fail (GDK_IS_DISPLAY_DFB (display), FALSE);
 
-
-GdkWindow *gdk_display_get_default_group (GdkDisplay *display)
-{
-  g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
-  return  _gdk_parent_root;
+  return FALSE;
 }
 
+GdkWindow *
+gdk_display_get_default_group (GdkDisplay *display)
+{
+  g_return_val_if_fail (GDK_IS_DISPLAY_DFB (display), NULL);
 
-
-
-static gboolean _gdk_directfb_pointer_implicit_grab = FALSE;
+  return _gdk_parent_root;
+}
 
 GdkGrabStatus
 gdk_directfb_pointer_grab (GdkWindow    *window,
@@ -297,12 +301,31 @@
                            gboolean      implicit_grab)
 {
   GdkWindow             *toplevel;
+  GdkWindowObject       *private;
   GdkWindowImplDirectFB *impl;
+
+  private = GDK_WINDOW_OBJECT (window);
+  impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
+  D_DEBUG_AT( GDKDFB_GrabPointer, "%s( %p [" GDKDFB_WIMPL_FORM "], owner %d, mask 0x%x, time %u, %splicit )\n",
+              __FUNCTION__, window, GDKDFB_WIMPL_V (impl), owner_events, event_mask, time, implicit_grab ? "im" : "ex" );
+
   if (_gdk_directfb_pointer_grab_window)
     {
+      GdkWindowObject       *grab_priv;
+      GdkWindowImplDirectFB *grab_impl;
+
+      GDK_DFB_UNUSED_P (grab_impl);
+
+      grab_priv = GDK_WINDOW_OBJECT (_gdk_directfb_pointer_grab_window);
+      grab_impl = GDK_WINDOW_IMPL_DIRECTFB (grab_priv->impl);
+
       if (implicit_grab && !_gdk_directfb_pointer_implicit_grab)
         return GDK_GRAB_ALREADY_GRABBED;
 
+      D_DEBUG_AT( GDKDFB_GrabPointer, "  -> Breaking %splicit grab of " GDKDFB_WIMPL_FORM "!\n",
+                  _gdk_directfb_pointer_implicit_grab ? "im" : "ex", GDKDFB_WIMPL_V (grab_impl) );
+
       gdk_pointer_ungrab (time);
     }
 
@@ -311,6 +334,8 @@
 
   if (impl->window)
     {
+      D_DEBUG_AT( GDKDFB_GrabPointer, "  -> Grabbing at top level [" GDKDFB_WIMPL_FORM "].\n", GDKDFB_WIMPL_V (impl) );
+
       if (impl->window->GrabPointer (impl->window) == DFB_LOCKED)
         return GDK_GRAB_ALREADY_GRABBED;
     }
@@ -323,45 +348,55 @@
   _gdk_directfb_pointer_implicit_grab     = implicit_grab;
   _gdk_directfb_pointer_grab_window       = g_object_ref (window);
   _gdk_directfb_pointer_grab_owner_events = owner_events;
-
   _gdk_directfb_pointer_grab_confine      = (confine_to ?
                                              g_object_ref (confine_to) : NULL);
   _gdk_directfb_pointer_grab_events       = event_mask;
   _gdk_directfb_pointer_grab_cursor       = (cursor ?
                                              gdk_cursor_ref (cursor) : NULL);
 
-
-  gdk_directfb_window_send_crossing_events (NULL,
-                                            window,
-                                            GDK_CROSSING_GRAB);
-
   return GDK_GRAB_SUCCESS;
 }
 
-
-
-
 void
 gdk_directfb_pointer_ungrab (guint32  time,
                              gboolean implicit_grab)
 {
   GdkWindow             *toplevel;
-  GdkWindow             *mousewin;
   GdkWindow             *old_grab_window;
   GdkWindowImplDirectFB *impl;
 
+  D_DEBUG_AT( GDKDFB_GrabPointer, "%s( %u, %splicit )\n", __FUNCTION__, time, implicit_grab ? "im" : "ex" );
+
   if (implicit_grab && !_gdk_directfb_pointer_implicit_grab)
     return;
 
   if (!_gdk_directfb_pointer_grab_window)
     return;
 
-  toplevel =
-    gdk_directfb_window_find_toplevel (_gdk_directfb_pointer_grab_window);
+  if (_gdk_directfb_pointer_grab_window)
+    {
+      GdkWindowObject       *grab_priv;
+      GdkWindowImplDirectFB *grab_impl;
+
+      GDK_DFB_UNUSED_P (grab_impl);
+
+      grab_priv = GDK_WINDOW_OBJECT (_gdk_directfb_pointer_grab_window);
+      grab_impl = GDK_WINDOW_IMPL_DIRECTFB (grab_priv->impl);
+
+      D_DEBUG_AT( GDKDFB_GrabPointer, "  -> Finish %splicit grab of " GDKDFB_WIMPL_FORM "!\n",
+                  _gdk_directfb_pointer_implicit_grab ? "im" : "ex", GDKDFB_WIMPL_V (grab_impl) );
+    }
+
+  old_grab_window = _gdk_directfb_pointer_grab_window;
+  toplevel = gdk_directfb_window_find_toplevel (old_grab_window);
   impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (toplevel)->impl);
 
   if (impl->window)
-    impl->window->UngrabPointer (impl->window);
+    {
+      D_DEBUG_AT( GDKDFB_GrabPointer, "  -> Ungrabbing at top level [" GDKDFB_WIMPL_FORM "].\n", GDKDFB_WIMPL_V (impl) );
+
+      impl->window->UngrabPointer (impl->window);
+    }
 
   if (_gdk_directfb_pointer_grab_confine)
     {
@@ -375,86 +410,100 @@
       _gdk_directfb_pointer_grab_cursor = NULL;
     }
 
-  old_grab_window = _gdk_directfb_pointer_grab_window;
-
   _gdk_directfb_pointer_grab_window   = NULL;
   _gdk_directfb_pointer_implicit_grab = FALSE;
 
-  mousewin = gdk_window_at_pointer (NULL, NULL);
-  gdk_directfb_window_send_crossing_events (old_grab_window,
-                                            mousewin,
-                                            GDK_CROSSING_UNGRAB);
   g_object_unref (old_grab_window);
 }
 
-
-
-
-/*
- *--------------------------------------------------------------
- * gdk_keyboard_grab
- *
- *   Grabs the keyboard to a specific window
- *
- * Arguments:
- *   "window" is the window which will receive the grab
- *   "owner_events" specifies whether events will be reported as is,
- *     or relative to "window"
- *   "time" specifies the time
- *
- * Results:
- *
- * Side effects:
- *   requires a corresponding call to gdk_keyboard_ungrab
- *
- *--------------------------------------------------------------
- */
-
 GdkGrabStatus
-gdk_display_keyboard_grab (GdkDisplay *display,GdkWindow *window,
-                   gint       owner_events,
-                   guint32    time)
+gdk_directfb_keyboard_grab (GdkDisplay *display,
+                            GdkWindow  *window,
+                            gint        owner_events,
+                            guint32     time)
 {
   GdkWindow             *toplevel;
   GdkWindowImplDirectFB *impl;
 
   g_return_val_if_fail (GDK_IS_WINDOW (window), 0);
 
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  D_DEBUG_AT( GDKDFB_GrabKeyboard, "%s( %p [" GDKDFB_WIMPL_FORM "], owner %d, time %u )\n",
+              __FUNCTION__, window, GDKDFB_WIMPL_V (impl), owner_events, time );
+
   if (_gdk_directfb_keyboard_grab_window)
-    gdk_keyboard_ungrab (time);
+    {
+      GdkWindowObject       *grab_priv;
+      GdkWindowImplDirectFB *grab_impl;
+
+      GDK_DFB_UNUSED_P (grab_impl);
+
+      grab_priv = GDK_WINDOW_OBJECT (_gdk_directfb_keyboard_grab_window);
+      grab_impl = GDK_WINDOW_IMPL_DIRECTFB (grab_priv->impl);
+
+      D_DEBUG_AT( GDKDFB_GrabKeyboard, "  -> Breaking grab of " GDKDFB_WIMPL_FORM "!\n", GDKDFB_WIMPL_V (grab_impl) );
+
+      gdk_keyboard_ungrab (time);
+    }
 
   toplevel = gdk_directfb_window_find_toplevel (window);
   impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (toplevel)->impl);
 
   if (impl->window)
     {
+      D_DEBUG_AT( GDKDFB_GrabKeyboard, "  -> Grabbing at top level [" GDKDFB_WIMPL_FORM "].\n", GDKDFB_WIMPL_V (impl) );
+
       if (impl->window->GrabKeyboard (impl->window) == DFB_LOCKED)
         return GDK_GRAB_ALREADY_GRABBED;
     }
 
-  _gdk_directfb_keyboard_grab_window = g_object_ref (window);
+  _gdk_directfb_keyboard_grab_window       = g_object_ref (window);
   _gdk_directfb_keyboard_grab_owner_events = owner_events;
+
   return GDK_GRAB_SUCCESS;
 }
 
 void
-gdk_display_keyboard_ungrab (GdkDisplay *display,guint32 time)
+gdk_directfb_keyboard_ungrab (GdkDisplay *display,
+                              guint32     time)
 {
   GdkWindow             *toplevel;
+  GdkWindow             *old_grab_window;
   GdkWindowImplDirectFB *impl;
 
+  D_DEBUG_AT( GDKDFB_GrabKeyboard, "%s( %u )\n", __FUNCTION__, time );
+
   if (!_gdk_directfb_keyboard_grab_window)
     return;
 
-  toplevel =
-    gdk_directfb_window_find_toplevel (_gdk_directfb_keyboard_grab_window);
+  if (_gdk_directfb_keyboard_grab_window)
+    {
+      GdkWindowObject       *grab_priv;
+      GdkWindowImplDirectFB *grab_impl;
+
+      GDK_DFB_UNUSED_P (grab_impl);
+
+      grab_priv = GDK_WINDOW_OBJECT (_gdk_directfb_keyboard_grab_window);
+      grab_impl = GDK_WINDOW_IMPL_DIRECTFB (grab_priv->impl);
+
+      D_DEBUG_AT( GDKDFB_GrabKeyboard, "  -> Finish grab of " GDKDFB_WIMPL_FORM "!\n", GDKDFB_WIMPL_V (grab_impl) );
+    }
+
+  old_grab_window = _gdk_directfb_keyboard_grab_window;
+  toplevel = gdk_directfb_window_find_toplevel (old_grab_window);
   impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (toplevel)->impl);
 
   if (impl->window)
-    impl->window->UngrabKeyboard (impl->window);
+    {
+      D_DEBUG_AT( GDKDFB_GrabKeyboard, "  -> Ungrabbing at top level [" GDKDFB_WIMPL_FORM "].\n", GDKDFB_WIMPL_V (impl) );
+
+      impl->window->UngrabKeyboard (impl->window);
+    }
 
-  g_object_unref (_gdk_directfb_keyboard_grab_window);
   _gdk_directfb_keyboard_grab_window = NULL;
+
+  g_object_unref (old_grab_window);
 }
 
 gint
@@ -464,12 +513,20 @@
 }
 
 void
-gdk_display_pointer_ungrab (GdkDisplay *display,guint32 time)
+gdk_display_pointer_ungrab (GdkDisplay *display,
+                            guint32     time)
 {
   gdk_directfb_pointer_ungrab (time, _gdk_directfb_pointer_implicit_grab);
 }
 
 void
+gdk_display_keyboard_ungrab (GdkDisplay *display,
+                             guint32     time)
+{
+  gdk_directfb_keyboard_ungrab (display, time);
+}
+
+void
 gdk_display_beep (GdkDisplay *display)
 {
 }
@@ -484,34 +541,16 @@
 {
 }
 
-
-
 void
 gdk_notify_startup_complete (void)
 {
 }
 
-/**
- * gdk_notify_startup_complete_with_id:
- * @startup_id: a startup-notification identifier, for which notification
- *              process should be completed
- * 
- * Indicates to the GUI environment that the application has finished
- * loading, using a given identifier.
- * 
- * GTK+ will call this function automatically for #GtkWindow with custom
- * startup-notification identifier unless
- * gtk_window_set_auto_startup_notification() is called to disable
- * that feature.
- *
- * Since: 2.12
- **/
 void
 gdk_notify_startup_complete_with_id (const gchar* startup_id)
 {
 }
 
-
 gboolean
 gdk_display_supports_composite (GdkDisplay *display)
 {
@@ -520,4 +559,3 @@
 
 #define __GDK_DISPLAY_X11_C__
 #include "gdkaliasdef.c"
-
--- gtk+-2.12.12.orig/gdk/directfb/gdkdisplay-directfb.h
+++ gtk+-2.12.12/gdk/directfb/gdkdisplay-directfb.h
@@ -15,19 +15,15 @@
  * Boston, MA 02111-1307, USA.
  */
 
-#ifndef GDK_DISPLAY_DFB_H
-#define GDK_DISPLAY_DFB_H
+#ifndef __GDK_DISPLAY_DFB_H__
+#define __GDK_DISPLAY_DFB_H__
 
 #include <directfb.h>
-#include <gdk/gdkdisplay.h>
-#include <gdk/gdkkeys.h>
+#include "gdkdisplay.h"
+#include "gdkkeys.h"
 
 G_BEGIN_DECLS
 
-typedef struct _GdkDisplayDFB GdkDisplayDFB;
-typedef struct _GdkDisplayDFBClass GdkDisplayDFBClass;
-
-
 #define GDK_TYPE_DISPLAY_DFB              (gdk_display_dfb_get_type())
 #define GDK_DISPLAY_DFB(object)           (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_DISPLAY_DFB, GdkDisplayDFB))
 #define GDK_DISPLAY_DFB_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GDK_TYPE_DISPLAY_DFB, GdkDisplayDFBClass))
@@ -35,25 +31,35 @@
 #define GDK_IS_DISPLAY_DFB_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), GDK_TYPE_DISPLAY_DFB))
 #define GDK_DISPLAY_DFB_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS ((obj), GDK_TYPE_DISPLAY_DFB, GdkDisplayDFBClass))
 
-struct _GdkDisplayDFB
+typedef struct
 {
   GdkDisplay parent;
-  IDirectFB              *directfb;
-  IDirectFBDisplayLayer  *layer;
-  IDirectFBEventBuffer   *buffer;
-  IDirectFBInputDevice   *keyboard;
-  GdkKeymap *keymap;
-};
+  IDirectFB             *directfb;
+  IDirectFBDisplayLayer *layer;
+  IDirectFBEventBuffer  *buffer;
+  IDirectFBInputDevice  *keyboard;
+  GdkKeymap             *keymap;
+
+  int                    event_fd;
+  GSource               *event_source;
+
+  GList                 *client_filters;
+} GdkDisplayDFB;
 
-struct _GdkDisplayDFBClass
+typedef struct _GdkDisplayDFBClass
 {
   GdkDisplayClass parent;
-};
+} GdkDisplayDFBClass;
 
-GType      gdk_display_dfb_get_type            (void);
+GType
+gdk_display_dfb_get_type       (void);
 
-IDirectFBSurface * gdk_display_dfb_create_surface (GdkDisplayDFB *display,int format,int width, int height);
+IDirectFBSurface *
+gdk_display_dfb_create_surface (GdkDisplayDFB         *display,
+                                DFBSurfacePixelFormat  format,
+                                int                    width,
+                                int                    height);
 
 G_END_DECLS
 
-#endif /* GDK_DISPLAY_DFB_H */
+#endif /* __GDK_DISPLAY_DFB_H__ */
--- gtk+-2.12.12.orig/gdk/directfb/gdkdnd-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkdnd-directfb.c
@@ -30,17 +30,13 @@
  *            Sven Neumann <sven@convergence.de>
  */
 
-#include <config.h>
-#include "gdk.h"
+#include "config.h"
+
 #include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
-
-#include "gdkdnd.h"
 #include "gdkproperty.h"
 #include "gdkalias.h"
 
-typedef struct _GdkDragContextPrivate GdkDragContextPrivate;
-
 typedef enum
 {
   GDK_DRAG_STATUS_DRAG,
@@ -50,16 +46,16 @@
 } GtkDragStatus;
 
 /* Structure that holds information about a drag in progress.
- * this is used on both source and destination sides.
+ * This is used on both source and destination sides.
  */
-struct _GdkDragContextPrivate
+typedef struct
 {
   GdkAtom local_selection;
 
-  guint16 last_x;		/* Coordinates from last event */
+  guint16 last_x;          /* coordinates from last event */
   guint16 last_y;
-  guint   drag_status : 4;	/* current status of drag      */
-};
+  guint   drag_status : 4; /* current status of drag */
+} GdkDragContextPrivate;
 
 /* Drag Contexts */
 
@@ -68,9 +64,7 @@
 
 #define GDK_DRAG_CONTEXT_PRIVATE_DATA(ctx) ((GdkDragContextPrivate *) GDK_DRAG_CONTEXT (ctx)->windowing_data)
 
-
-static gpointer  parent_class = NULL;
-
+static gpointer parent_class = NULL;
 
 static void
 gdk_drag_context_init (GdkDragContext *dragcontext)
@@ -94,7 +88,6 @@
   if (context->dest_window)
     g_object_unref (context->dest_window);
 
-
   if (private)
     {
       g_free (private);
@@ -163,43 +156,36 @@
 }
 
 static GdkDragContext *
-gdk_drag_context_find (gboolean     is_source,
-		       GdkWindow   *source,
-		       GdkWindow   *dest)
+gdk_drag_context_find (gboolean   is_source,
+                       GdkWindow *source,
+                       GdkWindow *dest)
 {
-  GdkDragContext        *context;
-  GdkDragContextPrivate *private;
-  GList                 *list;
+  GdkDragContext *context;
+  GList          *list;
 
   for (list = contexts; list; list = list->next)
     {
       context = (GdkDragContext *) list->data;
-      private = GDK_DRAG_CONTEXT_PRIVATE_DATA (context);
 
       if ((!context->is_source == !is_source) &&
-	  ((source == NULL) ||
+          ((source == NULL) ||
            (context->source_window && (context->source_window == source))) &&
-	  ((dest == NULL) ||
+          ((dest == NULL) ||
            (context->dest_window && (context->dest_window == dest))))
-	  return context;
+        return context;
     }
 
   return NULL;
 }
 
-
-/************************** Public API ***********************/
-
 void
 _gdk_dnd_init (void)
 {
 }
 
-/* Source side */
-
 static void
-local_send_leave (GdkDragContext  *context,
-		  guint32          time)
+local_send_leave (GdkDragContext *context,
+                  guint32         time)
 {
   GdkEvent event;
 
@@ -222,11 +208,11 @@
 
 static void
 local_send_enter (GdkDragContext *context,
-		  guint32         time)
+                  guint32         time)
 {
   GdkDragContextPrivate *private;
   GdkDragContext        *new_context;
-  GdkEvent event;
+  GdkEvent               event;
 
   private = GDK_DRAG_CONTEXT_PRIVATE_DATA (context);
 
@@ -252,8 +238,9 @@
   new_context->targets = g_list_copy (context->targets);
 
   gdk_window_set_events (new_context->source_window,
-			 gdk_window_get_events (new_context->source_window) |
-			 GDK_PROPERTY_CHANGE_MASK);
+                         gdk_window_get_events (new_context->source_window) |
+                         GDK_PROPERTY_CHANGE_MASK);
+
   new_context->actions = context->actions;
 
   event.dnd.type       = GDK_DRAG_ENTER;
@@ -271,11 +258,11 @@
 }
 
 static void
-local_send_motion (GdkDragContext  *context,
-		    gint            x_root,
-		    gint            y_root,
-		    GdkDragAction   action,
-		    guint32         time)
+local_send_motion (GdkDragContext *context,
+                   gint            x_root,
+                   gint            y_root,
+                   GdkDragAction   action,
+                   guint32         time)
 {
   GdkEvent event;
 
@@ -297,7 +284,8 @@
       (GDK_DRAG_CONTEXT_PRIVATE_DATA (current_dest_drag))->last_x = x_root;
       (GDK_DRAG_CONTEXT_PRIVATE_DATA (current_dest_drag))->last_y = y_root;
 
-      GDK_DRAG_CONTEXT_PRIVATE_DATA (context)->drag_status = GDK_DRAG_STATUS_MOTION_WAIT;
+      GDK_DRAG_CONTEXT_PRIVATE_DATA (context)->drag_status =
+        GDK_DRAG_STATUS_MOTION_WAIT;
 
       gdk_event_put (&event);
     }
@@ -314,6 +302,7 @@
       (current_dest_drag->source_window == context->source_window))
     {
       GdkDragContextPrivate *private;
+
       private = GDK_DRAG_CONTEXT_PRIVATE_DATA (current_dest_drag);
 
       event.dnd.type       = GDK_DROP_START;
@@ -335,14 +324,14 @@
   if (context->dest_window)
     {
       switch (context->protocol)
-	{
-	case GDK_DRAG_PROTO_LOCAL:
-	  local_send_leave (context, time);
-	  break;
-
-	default:
-	  break;
-	}
+        {
+        case GDK_DRAG_PROTO_LOCAL:
+          local_send_leave (context, time);
+          break;
+
+        default:
+          break;
+        }
 
       g_object_unref (context->dest_window);
       context->dest_window = NULL;
@@ -351,7 +340,7 @@
 
 GdkDragContext *
 gdk_drag_begin (GdkWindow *window,
-		GList     *targets)
+                GList     *targets)
 {
   GList          *list;
   GdkDragContext *new_context;
@@ -373,12 +362,13 @@
 }
 
 guint32
-gdk_drag_get_protocol_for_display(GdkDisplay *display, guint32          xid,
+gdk_drag_get_protocol_for_display (GdkDisplay      *display,
+                                   guint32          xid,
                                    GdkDragProtocol *protocol)
 {
   GdkWindow *window;
 
-  window = gdk_window_lookup ((GdkNativeWindow) xid);
+  window = gdk_window_lookup (xid);
 
   if (window &&
       GPOINTER_TO_INT (gdk_drawable_get_data (window, "gdk-dnd-registered")))
@@ -388,6 +378,7 @@
     }
 
   *protocol = GDK_DRAG_PROTO_NONE;
+
   return 0;
 }
 
@@ -413,36 +404,36 @@
       /* Check if new destination accepts drags, and which protocol */
       if ((recipient = gdk_drag_get_protocol (GDK_WINDOW_DFB_ID (dest),
                                               protocol)))
-	{
-	  *dest_window = gdk_window_lookup ((GdkNativeWindow) recipient);
-	  if (dest_window)
+        {
+          *dest_window = gdk_window_lookup (recipient);
+          if (dest_window)
             g_object_ref (*dest_window);
-	}
+        }
       else
-	*dest_window = NULL;
+        *dest_window = NULL;
     }
   else
     {
       *dest_window = context->dest_window;
       if (*dest_window)
-	g_object_ref (*dest_window);
+        g_object_ref (*dest_window);
 
       *protocol = context->protocol;
     }
-
 }
 
 gboolean
 gdk_drag_motion (GdkDragContext  *context,
-		 GdkWindow       *dest_window,
-		 GdkDragProtocol  protocol,
-		 gint             x_root,
-		 gint             y_root,
-		 GdkDragAction    suggested_action,
-		 GdkDragAction    possible_actions,
-		 guint32          time)
+                 GdkWindow       *dest_window,
+                 GdkDragProtocol  protocol,
+                 gint             x_root,
+                 gint             y_root,
+                 GdkDragAction    suggested_action,
+                 GdkDragAction    possible_actions,
+                 guint32          time)
 {
   GdkDragContextPrivate *private;
+  GdkEvent               event;
 
   g_return_val_if_fail (context != NULL, FALSE);
 
@@ -450,35 +441,34 @@
 
   if (context->dest_window != dest_window)
     {
-      GdkEvent  event;
-
       /* Send a leave to the last destination */
       gdk_drag_do_leave (context, time);
       private->drag_status = GDK_DRAG_STATUS_DRAG;
 
       /* Check if new destination accepts drags, and which protocol */
       if (dest_window)
-	{
-	  context->dest_window = dest_window;
-	  g_object_ref (context->dest_window);
-	  context->protocol = protocol;
-
-	  switch (protocol)
-	    {
-	    case GDK_DRAG_PROTO_LOCAL:
-	      local_send_enter (context, time);
-	      break;
-
-	    default:
-	      break;
-	    }
-	  context->suggested_action = suggested_action;
-	}
+        {
+          context->dest_window = dest_window;
+          g_object_ref (context->dest_window);
+          context->protocol = protocol;
+
+          switch (protocol)
+            {
+            case GDK_DRAG_PROTO_LOCAL:
+              local_send_enter (context, time);
+              break;
+
+            default:
+              break;
+            }
+
+          context->suggested_action = suggested_action;
+        }
       else
-	{
-	  context->dest_window = NULL;
-	  context->action = 0;
-	}
+        {
+          context->dest_window = NULL;
+          context->action = 0;
+        }
 
       /* Push a status event, to let the client know that
        * the drag changed
@@ -486,9 +476,6 @@
 
       event.dnd.type       = GDK_DRAG_STATUS;
       event.dnd.window     = context->source_window;
-      /* We use this to signal a synthetic status. Perhaps
-       * we should use an extra field...
-       */
       event.dnd.send_event = TRUE;
       event.dnd.context    = context;
       event.dnd.time       = time;
@@ -508,23 +495,24 @@
   if (context->dest_window)
     {
       if (private->drag_status == GDK_DRAG_STATUS_DRAG)
-	{
-	  switch (context->protocol)
-	    {
-	    case GDK_DRAG_PROTO_LOCAL:
-	      local_send_motion (context,
+        {
+          switch (context->protocol)
+            {
+            case GDK_DRAG_PROTO_LOCAL:
+              local_send_motion (context,
                                  x_root, y_root, suggested_action, time);
-	      break;
+              break;
 
-	    case GDK_DRAG_PROTO_NONE:
-	      g_warning ("GDK_DRAG_PROTO_NONE is not valid in gdk_drag_motion()");
-	      break;
-	    default:
-	      break;
-	    }
-	}
+            case GDK_DRAG_PROTO_NONE:
+              g_warning ("GDK_DRAG_PROTO_NONE is not valid in gdk_drag_motion()");
+              break;
+
+            default:
+              break;
+            }
+        }
       else
-	return TRUE;
+        return TRUE;
     }
 
   return FALSE;
@@ -532,62 +520,58 @@
 
 void
 gdk_drag_drop (GdkDragContext *context,
-	       guint32         time)
+               guint32         time)
 {
   g_return_if_fail (context != NULL);
 
   if (context->dest_window)
     {
       switch (context->protocol)
-	{
-	case GDK_DRAG_PROTO_LOCAL:
-	  local_send_drop (context, time);
-	  break;
-	case GDK_DRAG_PROTO_NONE:
-	  g_warning ("GDK_DRAG_PROTO_NONE is not valid in gdk_drag_drop()");
-	  break;
-	default:
-	  break;
-	}
+        {
+        case GDK_DRAG_PROTO_LOCAL:
+          local_send_drop (context, time);
+          break;
+
+        case GDK_DRAG_PROTO_NONE:
+          g_warning ("GDK_DRAG_PROTO_NONE is not valid in gdk_drag_drop()");
+          break;
+
+        default:
+          break;
+        }
     }
 }
 
 void
 gdk_drag_abort (GdkDragContext *context,
-		guint32         time)
+                guint32         time)
 {
   g_return_if_fail (context != NULL);
 
   gdk_drag_do_leave (context, time);
 }
 
-/* Destination side */
-
 void
-gdk_drag_status (GdkDragContext   *context,
-		 GdkDragAction     action,
-		 guint32           time)
+gdk_drag_status (GdkDragContext *context,
+                 GdkDragAction   action,
+                 guint32         time)
 {
   GdkDragContextPrivate *private;
   GdkDragContext        *src_context;
-  GdkEvent event;
+  GdkEvent               event;
 
   g_return_if_fail (context != NULL);
 
-  private = GDK_DRAG_CONTEXT_PRIVATE_DATA (context);
-
   src_context = gdk_drag_context_find (TRUE,
-				       context->source_window,
-				       context->dest_window);
+                                       context->source_window,
+                                       context->dest_window);
 
   if (src_context)
     {
-      GdkDragContextPrivate *private;
-
       private = GDK_DRAG_CONTEXT_PRIVATE_DATA (src_context);
 
       if (private->drag_status == GDK_DRAG_STATUS_MOTION_WAIT)
-	private->drag_status = GDK_DRAG_STATUS_DRAG;
+        private->drag_status = GDK_DRAG_STATUS_DRAG;
 
       event.dnd.type       = GDK_DRAG_STATUS;
       event.dnd.window     = src_context->source_window;
@@ -602,29 +586,27 @@
 }
 
 void
-gdk_drop_reply (GdkDragContext   *context,
-		gboolean          ok,
-		guint32           time)
+gdk_drop_reply (GdkDragContext *context,
+                gboolean        ok,
+                guint32         time)
 {
   g_return_if_fail (context != NULL);
 }
 
 void
-gdk_drop_finish (GdkDragContext   *context,
-		 gboolean          success,
-		 guint32           time)
+gdk_drop_finish (GdkDragContext *context,
+                 gboolean        success,
+                 guint32         time)
 {
-  GdkDragContextPrivate *private;
-  GdkDragContext        *src_context;
-  GdkEvent event;
+  GdkDragContext *src_context;
+  GdkEvent        event;
 
   g_return_if_fail (context != NULL);
 
-  private = GDK_DRAG_CONTEXT_PRIVATE_DATA (context);
-
   src_context = gdk_drag_context_find (TRUE,
-				       context->source_window,
-				       context->dest_window);
+                                       context->source_window,
+                                       context->dest_window);
+
   if (src_context)
     {
       gdk_drag_context_ref (src_context);
@@ -641,12 +623,13 @@
 gboolean
 gdk_drag_drop_succeeded (GdkDragContext *context)
 {
-	g_warning("gdk_drag_drop_succeeded unimplemented \n");
-	return TRUE;
+  D_UNIMPLEMENTED();
+
+  return TRUE;
 }
 
 void
-gdk_window_register_dnd (GdkWindow      *window)
+gdk_window_register_dnd (GdkWindow *window)
 {
   g_return_if_fail (window != NULL);
 
@@ -657,14 +640,6 @@
                          GINT_TO_POINTER (TRUE), NULL);
 }
 
-/*************************************************************
- * gdk_drag_get_selection:
- *     Returns the selection atom for the current source window
- *   arguments:
- *
- *   results:
- *************************************************************/
-
 GdkAtom
 gdk_drag_get_selection (GdkDragContext *context)
 {
--- gtk+-2.12.12.orig/gdk/directfb/gdkdrawable-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkdrawable-directfb.c
@@ -30,52 +30,30 @@
  *            Sven Neumann <sven@convergence.de>
  */
 
-#include <config.h>
-#include "gdk.h"
-#include <assert.h>
-
-#include <string.h>
+#include "config.h"
 
+#include "gdk.h"
 #include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
 
-#include "gdkinternals.h"
-
+#include <cairo-directfb.h>
 
-#include "gdkregion-generic.h"
-#include "gdkalias.h"
+D_DEBUG_DOMAIN( GDKDFB_Drawable, "GDKDFB/Drawable", "GDK DirectFB Drawable" );
+D_DEBUG_DOMAIN( GDKDFB_DrawClip, "GDKDFB/DrawClip", "GDK DirectFB Drawable Clip Region" );
 
-#include "cairo-directfb.h"
+static GdkScreen       *gdk_directfb_get_screen        (GdkDrawable *drawable);
 
-#define WARN_UNIMPLEMENTED(func)\
-{\
-  static gboolean first_call = TRUE;\
-  if (first_call)\
-    {\
-                        g_message ("unimplemented " func);\
-      first_call = FALSE;\
-    }\
-}
-
-static GdkScreen * gdk_directfb_get_screen (GdkDrawable    *drawable);
-static void gdk_drawable_impl_directfb_class_init (GdkDrawableImplDirectFBClass *klass);
-static void gdk_directfb_draw_lines (GdkDrawable *drawable,
-                                     GdkGC       *gc,
-                                     GdkPoint    *points,
-                                     gint         npoints);
+static void             gdk_directfb_draw_lines        (GdkDrawable *drawable,
+                                                        GdkGC       *gc,
+                                                        GdkPoint    *points,
+                                                        gint         npoints);
 
 static cairo_surface_t *gdk_directfb_ref_cairo_surface (GdkDrawable *drawable);
 
 
-static gboolean  accelerated_alpha_blending = FALSE;
-static gpointer  parent_class               = NULL;
-static const cairo_user_data_key_t gdk_directfb_cairo_key;
-
-
-/**********************************************************
- * DirectFB specific implementations of generic functions *
- **********************************************************/
+static gpointer parent_class = NULL;
 
+static const cairo_user_data_key_t gdk_directfb_cairo_key;
 
 static void
 gdk_directfb_set_colormap (GdkDrawable *drawable,
@@ -85,6 +63,8 @@
 
   impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
 
+  D_DEBUG_AT( GDKDFB_Drawable, "%s( %p, %p ) <- old %p\n", __FUNCTION__, drawable, colormap, impl->colormap );
+
   if (impl->colormap == colormap)
     return;
 
@@ -97,17 +77,19 @@
     g_object_ref (colormap);
 }
 
-static GdkColormap*
+static GdkColormap *
 gdk_directfb_get_colormap (GdkDrawable *drawable)
 {
   GdkColormap *retval;
 
   retval = GDK_DRAWABLE_IMPL_DIRECTFB (drawable)->colormap;
 
-  if (!retval) {
-    retval = gdk_colormap_get_system ();
-	gdk_directfb_set_colormap(drawable,retval);
-  }
+  if (!retval)
+    {
+      retval = gdk_colormap_get_system ();
+
+      gdk_directfb_set_colormap (drawable, retval);
+    }
 
   return retval;
 }
@@ -117,7 +99,7 @@
 {
   GdkDrawableImplDirectFB *impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
 
-  return DFB_BITS_PER_PIXEL (impl->format);
+  return GDK_DFB_BITS_PER_PIXEL (impl->format);
 }
 
 static void
@@ -145,18 +127,20 @@
 /* Calculates the real clipping region for a drawable, taking into account
  * other windows and the gc clip region.
  */
-static GdkRegion *
+void
 gdk_directfb_clip_region (GdkDrawable  *drawable,
                           GdkGC        *gc,
-                          GdkRectangle *draw_rect)
+                          GdkRectangle *draw_rect,
+                          GdkRegion    *ret_clip)
 {
   GdkDrawableImplDirectFB *private;
-  GdkRegion               *clip_region;
-  GdkRegion               *tmpreg;
   GdkRectangle             rect;
 
-  g_return_val_if_fail (GDK_IS_DRAWABLE (drawable), NULL);
-  g_return_val_if_fail (GDK_IS_DRAWABLE_IMPL_DIRECTFB (drawable), NULL);
+  g_return_if_fail (GDK_IS_DRAWABLE (drawable));
+  g_return_if_fail (GDK_IS_DRAWABLE_IMPL_DIRECTFB (drawable));
+  g_return_if_fail (ret_clip != NULL);
+
+  D_DEBUG_AT( GDKDFB_DrawClip, "%s( %p, %p, %p )\n", __FUNCTION__, drawable, gc, draw_rect );
 
   private = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
 
@@ -170,42 +154,63 @@
       draw_rect = &rect;
     }
 
-  clip_region = gdk_region_rectangle (draw_rect);
+  D_DEBUG_AT( GDKDFB_DrawClip, "  -> draw rectangle   == %4d,%4d - %4dx%4d =\n",
+              draw_rect->x, draw_rect->y, draw_rect->width, draw_rect->height );
+
+  temp_region_init_rectangle (ret_clip, draw_rect);
+
+  if (private->buffered)
+    {
+      D_DEBUG_AT( GDKDFB_DrawClip, "  -> buffered region   > %4d,%4d - %4dx%4d <  (%ld boxes)\n",
+                  GDKDFB_RECTANGLE_VALS_FROM_BOX (&private->paint_region.extents), private->paint_region.numRects );
 
-  if (private->buffered && private->paint_region)
-    gdk_region_intersect (clip_region, private->paint_region);
+      gdk_region_intersect (ret_clip, &private->paint_region);
+    }
 
   if (gc)
     {
       GdkGCDirectFB *gc_private = GDK_GC_DIRECTFB (gc);
-      GdkRegion     *region     = gc_private->clip_region;
+      GdkRegion     *region     = &gc_private->clip_region;
 
-      if (region)
+      if (region->numRects)
         {
+          D_DEBUG_AT( GDKDFB_DrawClip, "  -> clipping region   > %4d,%4d - %4dx%4d <  (%ld boxes)\n",
+                      GDKDFB_RECTANGLE_VALS_FROM_BOX (&region->extents), region->numRects );
+
           if (gc->clip_x_origin || gc->clip_y_origin)
             {
-              tmpreg = gdk_region_copy (region);
-
-              gdk_region_offset (tmpreg, gc->clip_x_origin, gc->clip_y_origin);
-              gdk_region_intersect (clip_region, tmpreg);
-              gdk_region_destroy (tmpreg);
+              gdk_region_offset (ret_clip, -gc->clip_x_origin, -gc->clip_y_origin);
+              gdk_region_intersect (ret_clip, region);
+              gdk_region_offset (ret_clip, gc->clip_x_origin, gc->clip_y_origin);
             }
           else
             {
-              gdk_region_intersect (clip_region, region);
+              gdk_region_intersect (ret_clip, region);
             }
         }
 
       if (gc_private->values_mask & GDK_GC_SUBWINDOW &&
           gc_private->values.subwindow_mode == GDK_INCLUDE_INFERIORS)
-        return clip_region;
+        return;
+    }
+
+  if (private->buffered)
+    {
+      D_DEBUG_AT( GDKDFB_DrawClip, "  => returning clip   >> %4d,%4d - %4dx%4d << (%ld boxes)\n",
+                  GDKDFB_RECTANGLE_VALS_FROM_BOX (&ret_clip->extents), ret_clip->numRects );
+      return;
     }
 
   if (GDK_IS_WINDOW (private->wrapper) &&
       GDK_WINDOW_IS_MAPPED (private->wrapper) &&
       !GDK_WINDOW_OBJECT (private->wrapper)->input_only)
     {
-      GList *cur;
+      GList     *cur;
+      GdkRegion  temp;
+
+      temp.numRects = 1;
+      temp.rects = &temp.extents;
+      temp.size = 1;
 
       for (cur = GDK_WINDOW_OBJECT (private->wrapper)->children;
            cur;
@@ -221,23 +226,22 @@
 
           cur_impl = GDK_DRAWABLE_IMPL_DIRECTFB (cur_private->impl);
 
-          rect.x      = cur_private->x;
-          rect.y      = cur_private->y;
-          rect.width  = cur_impl->width;
-          rect.height = cur_impl->height;
-
-          tmpreg = gdk_region_rectangle (&rect);
-          gdk_region_subtract (clip_region, tmpreg);
-          gdk_region_destroy (tmpreg);
+          temp.extents.x1 = cur_private->x;
+          temp.extents.y1 = cur_private->y;
+          temp.extents.x2 = cur_private->x + cur_impl->width;
+          temp.extents.y2 = cur_private->y + cur_impl->height;
+
+          D_DEBUG_AT( GDKDFB_DrawClip, "  -> clipping child    [ %4d,%4d - %4dx%4d ]  (%ld boxes)\n",
+                      GDKDFB_RECTANGLE_VALS_FROM_BOX (&temp.extents), temp.numRects );
+
+          gdk_region_subtract (ret_clip, &temp);
         }
     }
 
-  return clip_region;
+  D_DEBUG_AT( GDKDFB_DrawClip, "  => returning clip   >> %4d,%4d - %4dx%4d << (%ld boxes)\n",
+              GDKDFB_RECTANGLE_VALS_FROM_BOX (&ret_clip->extents), ret_clip->numRects );
 }
 
-/* Drawing
- */
-
 static inline void
 gdk_directfb_set_color (GdkDrawableImplDirectFB *impl,
                         GdkColor                *color,
@@ -304,8 +308,7 @@
           break;
 
         default:
-          g_message ("unsupported GC function %d",
-                     gc_private->values.function);
+          g_message ("unsupported GC function %d", gc_private->values.function);
           flags = DSDRAW_NOFX;
           break;
         }
@@ -318,39 +321,43 @@
   return TRUE;
 }
 
-void
-_gdk_directfb_draw_rectangle (GdkDrawable *drawable,
-                              GdkGC       *gc,
-                              gint         filled,
-                              gint         x,
-                              gint         y,
-                              gint         width,
-                              gint         height)
+static void
+gdk_directfb_draw_rectangle (GdkDrawable *drawable,
+                             GdkGC       *gc,
+                             gint         filled,
+                             gint         x,
+                             gint         y,
+                             gint         width,
+                             gint         height)
 {
   GdkDrawableImplDirectFB *impl;
-  GdkRegion               *clip;
+  GdkRegion                clip;
   GdkGCDirectFB           *gc_private = NULL;
   IDirectFBSurface        *surface    = NULL;
   gint  i;
 
   g_return_if_fail (GDK_IS_DRAWABLE (drawable));
 
+  D_DEBUG_AT( GDKDFB_Drawable, "%s( %p, %p, %s, %4d,%4d - %4dx%4d )\n", __FUNCTION__,
+              drawable, gc, filled ? " filled" : "outline", x, y, width, height );
+
   impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
 
   if (!impl->surface)
     return;
 
-
   if (gc)
     gc_private = GDK_GC_DIRECTFB (gc);
 
   if (gc_private)
     {
+      GdkColor fg_color = gc_private->values.foreground;
+
       if (gdk_directfb_enable_color_keying &&
-	  (gc_private->values.foreground.red   >> 8) == gdk_directfb_bg_color_key.r &&
-	  (gc_private->values.foreground.green >> 8) == gdk_directfb_bg_color_key.g &&
-	  (gc_private->values.foreground.blue  >> 8) == gdk_directfb_bg_color_key.b)
-	{
+          (fg_color.red   >> 8) == gdk_directfb_bg_color_key.r &&
+          (fg_color.green >> 8) == gdk_directfb_bg_color_key.g &&
+          (fg_color.blue  >> 8) == gdk_directfb_bg_color_key.b)
+        {
           if (DFB_PIXELFORMAT_IS_INDEXED (impl->format))
             impl->surface->SetColorIndex (impl->surface, 255);
           else
@@ -359,20 +366,19 @@
                                      gdk_directfb_bg_color.g,
                                      gdk_directfb_bg_color.b,
                                      gdk_directfb_bg_color.a);
-	}
+        }
       else
-	{
-          if (!gdk_directfb_setup_for_drawing (impl, gc_private)){
+        {
+          if (!gdk_directfb_setup_for_drawing (impl, gc_private))
             return;
-		  }
-	}
+        }
     }
   else
     {
       GdkWindowObject *win = GDK_WINDOW_OBJECT (impl->wrapper);
 
       if (gdk_directfb_enable_color_keying)
-	{
+        {
           if (DFB_PIXELFORMAT_IS_INDEXED (impl->format))
             impl->surface->SetColorIndex (impl->surface, 255);
           else
@@ -381,18 +387,18 @@
                                      gdk_directfb_bg_color.b,
                                      gdk_directfb_bg_color.g,
                                      gdk_directfb_bg_color.a);
-	}
+        }
       else
-	{
+        {
           gdk_directfb_set_color (impl, &win->bg_color, 0xFF);
-	}
+        }
     }
 
   if (filled)
     {
-      GdkRectangle  rect = { x, y, width, height };
+      GdkRectangle rect = { x, y, width, height };
 
-      clip = gdk_directfb_clip_region (drawable, gc, &rect);
+      gdk_directfb_clip_region (drawable, gc, &rect, &clip);
 
       if (gc_private && gc_private->values_mask & GDK_GC_FILL)
         {
@@ -400,18 +406,26 @@
               gc_private->values_mask & GDK_GC_STIPPLE &&
               gc_private->values.stipple)
             {
-              surface = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (gc_private->values.stipple)->impl)->surface;
+              GdkPixmap *p = gc_private->values.stipple;
+              GdkDrawableImplDirectFB *p_impl;
+              p_impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (p)->impl);
+              surface = p_impl->surface;
 
               if (surface)
                 impl->surface->SetBlittingFlags (impl->surface,
-                                                 (DSBLIT_BLEND_ALPHACHANNEL |
-                                                  DSBLIT_COLORIZE));
+                                                 DSBLIT_BLEND_ALPHACHANNEL |
+                                                 DSBLIT_COLORIZE);
             }
           else if (gc_private->values.fill == GDK_TILED  &&
                    gc_private->values_mask & GDK_GC_TILE &&
                    gc_private->values.tile)
             {
-              surface = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (gc_private->values.tile)->impl)->surface;
+              GdkPixmap *p = gc_private->values.tile;
+              GdkDrawableImplDirectFB *p_impl;
+              p_impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (p)->impl);
+              surface = p_impl->surface;
+
+              impl->surface->SetBlittingFlags (impl->surface, DSBLIT_NOFX);
             }
         }
 
@@ -422,33 +436,35 @@
           if (gc_private->values_mask & GDK_GC_TS_Y_ORIGIN)
             y = gc_private->values.ts_y_origin;
 
-          for (i = 0; i < clip->numRects; i++)
+          for (i = 0; i < clip.numRects; i++)
             {
-              DFBRegion reg = { clip->rects[i].x1,     clip->rects[i].y1,
-                                clip->rects[i].x2, clip->rects[i].y2 };
+              DFBRegion reg = { clip.rects[i].x1, clip.rects[i].y1,
+                                clip.rects[i].x2, clip.rects[i].y2 };
 
               impl->surface->SetClip (impl->surface, &reg);
               impl->surface->TileBlit (impl->surface, surface, NULL, x, y);
             }
-
-          impl->surface->SetBlittingFlags (impl->surface, DSBLIT_NOFX);
-          impl->surface->SetClip (impl->surface, NULL);
         }
       else  /* normal rectangle filling */
         {
-          for (i = 0; i < clip->numRects; i++)
+          DFBRectangle rects[clip.numRects];
+
+          impl->surface->SetClip (impl->surface, NULL);
+
+          for (i = 0; i < clip.numRects; i++)
             {
-              DFBRegion *region = (DFBRegion *) &clip->rects[i];
+              GdkRegionBox *box = &clip.rects[i];
 
-              impl->surface->FillRectangle (impl->surface,
-                                            region->x1,
-                                            region->y1,
-                                            region->x2 - region->x1,
-                                            region->y2 - region->y1);
+              rects[i].x = box->x1;
+              rects[i].y = box->y1;
+              rects[i].w = box->x2 - box->x1;
+              rects[i].h = box->y2 - box->y1;
             }
+
+          impl->surface->FillRectangles (impl->surface, rects, clip.numRects);
         }
 
-      gdk_region_destroy (clip);
+      temp_region_deinit (&clip);
     }
   else
     {
@@ -459,9 +475,7 @@
       /*  DirectFB does not draw rectangles the X way. Using DirectFB,
           a filled Rectangle has the same size as a drawn one, while
           X draws the rectangle one pixel taller and wider.  */
-      impl->surface->DrawRectangle (impl->surface,
-                                    x, y, width , height);
-      impl->surface->SetClip (impl->surface, NULL);
+      impl->surface->DrawRectangle (impl->surface, x, y, width , height);
     }
 }
 
@@ -476,7 +490,7 @@
                        gint         angle1,
                        gint         angle2)
 {
-  WARN_UNIMPLEMENTED (G_STRLOC);
+  D_UNIMPLEMENTED();
 }
 
 static void
@@ -488,18 +502,20 @@
 {
   g_return_if_fail (GDK_IS_DRAWABLE (drawable));
 
+  D_DEBUG_AT( GDKDFB_Drawable, "%s( %p, %p, %s, %p, %d )\n", __FUNCTION__,
+              drawable, gc, filled ? " filled" : "outline", points, npoints );
+
   if (npoints < 3)
     return;
 
   if (filled)
     {
-                if (npoints == 3 ||
-                                (npoints == 4 && 
-                                 points[0].x == points[npoints-1].x &&
-                                 points[0].y == points[npoints-1].y))
+      if (npoints == 3 || (npoints == 4 &&
+                           points[0].x == points[npoints-1].x &&
+                           points[0].y == points[npoints-1].y))
           {
             GdkDrawableImplDirectFB *impl;
-            GdkRegion               *clip;
+            GdkRegion                clip;
             gint                     i;
 
             impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
@@ -507,12 +523,12 @@
             if (!gdk_directfb_setup_for_drawing (impl, GDK_GC_DIRECTFB (gc)))
               return;
 
-            clip = gdk_directfb_clip_region (drawable, gc, NULL);
+            gdk_directfb_clip_region (drawable, gc, NULL, &clip);
 
-            for (i = 0; i < clip->numRects; i++)
+            for (i = 0; i < clip.numRects; i++)
               {
-                                DFBRegion reg = { clip->rects[i].x1,     clip->rects[i].y1, 
-                    clip->rects[i].x2 , clip->rects[i].y2  };
+                DFBRegion reg = { clip.rects[i].x1, clip.rects[i].y1,
+                                  clip.rects[i].x2, clip.rects[i].y2 };
 
                 impl->surface->SetClip (impl->surface, &reg);
                 impl->surface->FillTriangle (impl->surface,
@@ -521,14 +537,14 @@
                                              points[2].x, points[2].y);
 
               }
-            impl->surface->SetClip (impl->surface, NULL);
-            gdk_region_destroy (clip);
+
+            temp_region_deinit (&clip);
 
             return;
           }
-                else
-                        g_message ("filled polygons with n > 3 are not yet supported, "
-                     "drawing outlines");
+          else
+            g_message ("filled polygons with n > 3 are not yet supported, "
+                       "drawing outlines");
     }
 
   if (points[0].x != points[npoints-1].x ||
@@ -560,7 +576,7 @@
                         const gchar *text,
                         gint         text_length)
 {
-  WARN_UNIMPLEMENTED (G_STRLOC);
+  D_UNIMPLEMENTED();
 }
 
 static void
@@ -572,7 +588,7 @@
                            const GdkWChar *text,
                            gint            text_length)
 {
-  WARN_UNIMPLEMENTED (G_STRLOC);
+  D_UNIMPLEMENTED();
 }
 
 static void
@@ -588,14 +604,15 @@
 {
   GdkDrawableImplDirectFB *impl;
   GdkDrawableImplDirectFB *src_impl;
-  GdkRegion               *clip;
-  GdkRectangle             dest_rect = { xdest,
-                                         ydest,
-                xdest + width ,
-                ydest + height};
+  GdkRegion                clip;
+  GdkRectangle             dest_rect = { xdest, ydest,
+                                         xdest + width , ydest + height };
 
-  DFBRectangle rect = { xsrc, ysrc, width, height };
-  gint i;
+  DFBRectangle             rect = { xsrc, ysrc, width, height };
+  gint                     i;
+
+  D_DEBUG_AT( GDKDFB_Drawable, "%s( %p, %p, %p, %4d,%4d -> %4d,%4d - %dx%d )\n", __FUNCTION__,
+              drawable, gc, src, xsrc, ysrc, xdest, ydest, width, height );
 
   impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
 
@@ -611,19 +628,22 @@
   else
     return;
 
-  clip = gdk_directfb_clip_region (drawable, gc, &dest_rect);
+  gdk_directfb_clip_region (drawable, gc, &dest_rect, &clip);
 
-  for (i = 0; i < clip->numRects; i++)
+  impl->surface->SetBlittingFlags (impl->surface, DSBLIT_NOFX);
+
+  for (i = 0; i < clip.numRects; i++)
     {
-      DFBRegion reg = { clip->rects[i].x1,     clip->rects[i].y1,
-                        clip->rects[i].x2 , clip->rects[i].y2 };
+      DFBRegion reg = { clip.rects[i].x1, clip.rects[i].y1,
+                        clip.rects[i].x2, clip.rects[i].y2 };
 
       impl->surface->SetClip (impl->surface, &reg);
-      impl->surface->Blit (impl->surface, src_impl->surface, &rect,
-                           xdest, ydest);
+      impl->surface->Blit (impl->surface, src_impl->surface,
+                           &rect, xdest, ydest);
+      impl->surface->Flip (impl->surface, &reg, DSFLIP_NONE);
     }
-  impl->surface->SetClip (impl->surface, NULL);
-  gdk_region_destroy (clip);
+
+  temp_region_deinit (&clip);
 }
 
 static void
@@ -633,10 +653,12 @@
                           gint         npoints)
 {
   GdkDrawableImplDirectFB *impl;
-  GdkRegion               *clip;
+  GdkRegion                clip;
 
   DFBRegion region = { points->x, points->y, points->x, points->y };
 
+  D_DEBUG_AT( GDKDFB_Drawable, "%s( %p, %p, %p, %d )\n", __FUNCTION__, drawable, gc, points, npoints );
+
   if (npoints < 1)
     return;
 
@@ -645,22 +667,24 @@
   if (!gdk_directfb_setup_for_drawing (impl, GDK_GC_DIRECTFB (gc)))
     return;
 
-  clip = gdk_directfb_clip_region (drawable, gc, NULL);
+  gdk_directfb_clip_region (drawable, gc, NULL, &clip);
 
   while (npoints > 0)
     {
-      if (gdk_region_point_in (clip, points->x, points->y))
+      if (gdk_region_point_in (&clip, points->x, points->y))
         {
           impl->surface->FillRectangle (impl->surface,
                                         points->x, points->y, 1, 1);
 
           if (points->x < region.x1)
             region.x1 = points->x;
+
           if (points->x > region.x2)
             region.x2 = points->x;
 
           if (points->y < region.y1)
             region.y1 = points->y;
+
           if (points->y > region.y2)
             region.y2 = points->y;
         }
@@ -669,7 +693,7 @@
       points++;
     }
 
-  gdk_region_destroy (clip);
+  temp_region_deinit (&clip);
 }
 
 static void
@@ -679,10 +703,10 @@
                             gint         nsegs)
 {
   GdkDrawableImplDirectFB *impl;
-  GdkRegion               *clip;
+  GdkRegion                clip;
   gint                     i;
 
-  DFBRegion region = { segs->x1, segs->y1, segs->x2, segs->y2 };
+  D_DEBUG_AT( GDKDFB_Drawable, "%s( %p, %p, %p, %d )\n", __FUNCTION__, drawable, gc, segs, nsegs );
 
   if (nsegs < 1)
     return;
@@ -692,62 +716,19 @@
   if (!gdk_directfb_setup_for_drawing (impl, GDK_GC_DIRECTFB (gc)))
     return;
 
-  clip = gdk_directfb_clip_region (drawable, gc, NULL);
+  gdk_directfb_clip_region (drawable, gc, NULL, &clip);
 
-  for (i = 0; i < clip->numRects; i++)
+  for (i = 0; i < clip.numRects; i++)
     {
-      DFBRegion reg = { clip->rects[i].x1,   clip->rects[i].y1,
-                        clip->rects[i].x2, clip->rects[i].y2 };
+      DFBRegion reg = { clip.rects[i].x1, clip.rects[i].y1,
+                        clip.rects[i].x2, clip.rects[i].y2 };
 
       impl->surface->SetClip (impl->surface, &reg);
 
-      impl->surface->DrawLines (impl->surface, (DFBRegion *)segs, nsegs);
+      impl->surface->DrawLines (impl->surface, (DFBRegion *) segs, nsegs);
     }
 
-  impl->surface->SetClip (impl->surface, NULL);
-
-  gdk_region_destroy (clip);
-
-  /* everything below can be omitted if the drawing is buffered */
-  if (impl->buffered)
-    return;
-
-  if (region.x1 > region.x2)
-    {
-      region.x1 = segs->x2;
-      region.x2 = segs->x1;
-    }
-  if (region.y1 > region.y2)
-    {
-      region.y1 = segs->y2;
-      region.y2 = segs->y1;
-    }
-
-  while (nsegs > 1)
-    {
-      nsegs--;
-      segs++;
-
-      if (segs->x1 < region.x1)
-        region.x1 = segs->x1;
-      if (segs->x2 < region.x1)
-        region.x1 = segs->x2;
-
-      if (segs->y1 < region.y1)
-        region.y1 = segs->y1;
-      if (segs->y2 < region.y1)
-        region.y1 = segs->y2;
-
-      if (segs->x1 > region.x2)
-        region.x2 = segs->x1;
-      if (segs->x2 > region.x2)
-        region.x2 = segs->x2;
-
-      if (segs->y1 > region.y2)
-        region.y2 = segs->y1;
-      if (segs->y2 > region.y2)
-        region.y2 = segs->y2;
-    }
+  temp_region_deinit (&clip);
 }
 
 static void
@@ -757,13 +738,15 @@
                          gint         npoints)
 {
   GdkDrawableImplDirectFB *impl;
-  GdkRegion               *clip;
+  GdkRegion                clip;
   gint                     i;
 
   DFBRegion lines[npoints > 1 ? npoints - 1 : 1];
 
   DFBRegion region = { points->x, points->y, points->x, points->y };
 
+  D_DEBUG_AT( GDKDFB_Drawable, "%s( %p, %p, %p, %d )\n", __FUNCTION__, drawable, gc, points, npoints );
+
   if (npoints < 2)
     return;
 
@@ -801,20 +784,18 @@
   lines[i].x2 = points->x;
   lines[i].y2 = points->y;
 
-  clip = gdk_directfb_clip_region (drawable, gc, NULL);
+  gdk_directfb_clip_region (drawable, gc, NULL, &clip);
 
-  for (i = 0; i < clip->numRects; i++)
+  for (i = 0; i < clip.numRects; i++)
     {
-      DFBRegion reg = { clip->rects[i].x1,   clip->rects[i].y1,
-                        clip->rects[i].x2, clip->rects[i].y2 };
+      DFBRegion reg = { clip.rects[i].x1, clip.rects[i].y1,
+                        clip.rects[i].x2, clip.rects[i].y2 };
 
       impl->surface->SetClip (impl->surface, &reg);
       impl->surface->DrawLines (impl->surface, lines, npoints - 1);
     }
 
-  impl->surface->SetClip (impl->surface, NULL);
-
-  gdk_region_destroy (clip);
+  temp_region_deinit (&clip);
 }
 
 static void
@@ -830,111 +811,87 @@
 {
   GdkDrawableImplDirectFB *impl;
   GdkImageDirectFB        *image_private;
-  GdkRegion               *clip;
+  GdkRegion                clip;
   GdkRectangle             dest_rect = { xdest, ydest, width, height };
-
-  gint pitch = 0;
-  gint i;
+  gint                     pitch = 0;
+  gint                     i;
 
   g_return_if_fail (GDK_IS_DRAWABLE (drawable));
   g_return_if_fail (image != NULL);
 
+  D_DEBUG_AT( GDKDFB_Drawable, "%s( %p, %p, %p, %4d,%4d -> %4d,%4d - %dx%d )\n", __FUNCTION__,
+              drawable, gc, image, xsrc, ysrc, xdest, ydest, width, height );
+
   impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
   image_private = image->windowing_data;
 
   if (!impl->surface)
     return;
 
-  clip = gdk_directfb_clip_region (drawable, gc, &dest_rect);
+  gdk_directfb_clip_region (drawable, gc, &dest_rect, &clip);
 
-  if (!gdk_region_empty (clip))
+  if (!gdk_region_empty (&clip))
     {
-      DFBRectangle  src_rect = { xsrc, ysrc, width, height };
+      DFBRectangle src_rect = { xsrc, ysrc, width, height };
 
       image_private->surface->Unlock (image_private->surface);
 
-      for (i = 0; i < clip->numRects; i++)
+      impl->surface->SetBlittingFlags (impl->surface, DSBLIT_NOFX);
+
+      for (i = 0; i < clip.numRects; i++)
         {
-          DFBRegion reg = { clip->rects[i].x1,     clip->rects[i].y1,
-                            clip->rects[i].x2 , clip->rects[i].y2  };
+          DFBRegion reg = { clip.rects[i].x1, clip.rects[i].y1,
+                            clip.rects[i].x2, clip.rects[i].y2 };
 
           impl->surface->SetClip (impl->surface, &reg);
-          impl->surface->Blit (impl->surface,
-                               image_private->surface, &src_rect,
-                               xdest, ydest);
+
+          impl->surface->Blit (impl->surface, image_private->surface,
+                               &src_rect, xdest, ydest);
+
+          impl->surface->Flip (impl->surface, &reg, DSFLIP_NONE);
         }
-      impl->surface->SetClip (impl->surface, NULL);
 
       image_private->surface->Lock (image_private->surface, DSLF_WRITE,
                                     &image->mem, &pitch);
       image->bpl = pitch;
     }
 
-  gdk_region_destroy (clip);
-}
-
-static inline void
-convert_rgba_pixbuf_to_image (guint32 *src,
-                              guint    src_pitch,
-                              guint32 *dest,
-                              guint    dest_pitch,
-                              guint    width,
-                              guint    height)
-{
-  guint i;
-
-  while (height--)
-    {
-      for (i = 0; i < width; i++)
-        {
-          guint32 pixel = GUINT32_FROM_BE (src[i]);
-          dest[i] = (pixel >> 8) | (pixel << 24);
-        }
-
-      src  += src_pitch;
-      dest += dest_pitch;
-    }
+  temp_region_deinit (&clip);
 }
 
-static inline void
-convert_rgb_pixbuf_to_image (guchar  *src,
-                             guint    src_pitch,
-                             guint32 *dest,
-                             guint    dest_pitch,
-                             guint    width,
-                             guint    height)
+static inline const char *
+drawable_impl_type_name (GObject *object)
 {
-  guint   i;
-  guchar *s;
+  if (GDK_IS_PIXMAP (object))
+    return "PIXMAP";
 
-  while (height--)
-    {
-      s = src;
+  if (GDK_IS_WINDOW (object))
+    return "WINDOW";
 
-      for (i = 0; i < width; i++, s += 3)
-        dest[i] = 0xFF000000 | (s[0] << 16) | (s[1] << 8) | s[2];
+  if (GDK_IS_DRAWABLE_IMPL_DIRECTFB (object))
+    return "DRAWABLE";
 
-      src  += src_pitch;
-      dest += dest_pitch;
-    }
+  return "unknown";
 }
 
-/*
- * Object stuff
- */
-
 static void
 gdk_drawable_impl_directfb_finalize (GObject *object)
 {
   GdkDrawableImplDirectFB *impl;
+
   impl = GDK_DRAWABLE_IMPL_DIRECTFB (object);
 
+  D_DEBUG_AT( GDKDFB_Drawable, "%s( %p ) <- %dx%d (%s at %4d,%4d)\n", __FUNCTION__,
+              object, impl->width, impl->height, drawable_impl_type_name (object), impl->abs_x, impl->abs_y );
+
   gdk_directfb_set_colormap (GDK_DRAWABLE (object), NULL);
-  if( impl->cairo_surface ) {
-	cairo_surface_finish(impl->cairo_surface);
-  }
-  if( impl->surface )
-  	impl->surface->Release (impl->surface);
+
+  if (impl->cairo_surface)
+    cairo_surface_finish (impl->cairo_surface);
+
+  if (impl->surface)
+    impl->surface->Release (impl->surface);
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
@@ -948,43 +905,29 @@
 
   object_class->finalize = gdk_drawable_impl_directfb_finalize;
 
-  drawable_class->create_gc      = _gdk_directfb_gc_new;
-  drawable_class->draw_rectangle = _gdk_directfb_draw_rectangle;
-  drawable_class->draw_arc       = gdk_directfb_draw_arc;
-  drawable_class->draw_polygon   = gdk_directfb_draw_polygon;
-  drawable_class->draw_text      = gdk_directfb_draw_text;
-  drawable_class->draw_text_wc   = gdk_directfb_draw_text_wc;
-  drawable_class->draw_drawable  = gdk_directfb_draw_drawable;
-  drawable_class->draw_points    = gdk_directfb_draw_points;
-  drawable_class->draw_segments  = gdk_directfb_draw_segments;
-  drawable_class->draw_lines     = gdk_directfb_draw_lines;
-#if 0
-  drawable_class->draw_glyphs    = NULL;
-  drawable_class->draw_glyphs_transformed    = NULL;
-#endif
-  drawable_class->draw_image     = gdk_directfb_draw_image;
+  drawable_class->create_gc         = gdk_directfb_gc_new;
+  drawable_class->draw_rectangle    = gdk_directfb_draw_rectangle;
+  drawable_class->draw_arc          = gdk_directfb_draw_arc;
+  drawable_class->draw_polygon      = gdk_directfb_draw_polygon;
+  drawable_class->draw_text         = gdk_directfb_draw_text;
+  drawable_class->draw_text_wc      = gdk_directfb_draw_text_wc;
+  drawable_class->draw_drawable     = gdk_directfb_draw_drawable;
+  drawable_class->draw_points       = gdk_directfb_draw_points;
+  drawable_class->draw_segments     = gdk_directfb_draw_segments;
+  drawable_class->draw_lines        = gdk_directfb_draw_lines;
+  drawable_class->draw_image        = gdk_directfb_draw_image;
 
   drawable_class->ref_cairo_surface = gdk_directfb_ref_cairo_surface;
-  drawable_class->set_colormap   = gdk_directfb_set_colormap;
-  drawable_class->get_colormap   = gdk_directfb_get_colormap;
+  drawable_class->set_colormap      = gdk_directfb_set_colormap;
+  drawable_class->get_colormap      = gdk_directfb_get_colormap;
 
-  drawable_class->get_depth      = gdk_directfb_get_depth;
-  drawable_class->get_visual     = gdk_directfb_get_visual;
+  drawable_class->get_depth         = gdk_directfb_get_depth;
+  drawable_class->get_visual        = gdk_directfb_get_visual;
 
-  drawable_class->get_size       = gdk_directfb_get_size;
+  drawable_class->get_size          = gdk_directfb_get_size;
 
-  drawable_class->_copy_to_image = _gdk_directfb_copy_to_image;
-        drawable_class->get_screen = gdk_directfb_get_screen;
-
-  /* check for hardware-accelerated alpha-blending */
-  {
-    DFBGraphicsDeviceDescription desc;
-                _gdk_display->directfb->GetDeviceDescription ( _gdk_display->directfb, &desc);
-
-    accelerated_alpha_blending =
-      ((desc.acceleration_mask & DFXL_BLIT) &&
-       (desc.blitting_flags & DSBLIT_BLEND_ALPHACHANNEL));
-  }
+  drawable_class->_copy_to_image    = gdk_directfb_copy_to_image;
+  drawable_class->get_screen        = gdk_directfb_get_screen;
 }
 
 GType
@@ -1015,44 +958,49 @@
   return object_type;
 }
 
-static GdkScreen * gdk_directfb_get_screen (GdkDrawable    *drawable){
-        return gdk_screen_get_default();
+static GdkScreen *
+gdk_directfb_get_screen (GdkDrawable *drawable)
+{
+  return gdk_screen_get_default ();
 }
 
 static void
 gdk_directfb_cairo_surface_destroy (void *data)
 {
   GdkDrawableImplDirectFB *impl = data;
+
   impl->cairo_surface = NULL;
 }
 
-
 static cairo_surface_t *
 gdk_directfb_ref_cairo_surface (GdkDrawable *drawable)
 {
-    g_return_val_if_fail (GDK_IS_DRAWABLE (drawable), NULL);
-    g_return_val_if_fail (GDK_IS_DRAWABLE_IMPL_DIRECTFB (drawable), NULL);
+  GdkDrawableImplDirectFB *impl;
+  IDirectFB               *dfb;
 
-    GdkDrawableImplDirectFB *impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
-    IDirectFB *dfb = GDK_DISPLAY_DFB(gdk_drawable_get_display(drawable))->directfb;
-    if (!impl->cairo_surface) {
-//      IDirectFBSurface *surface;
-     // if (impl->surface->GetSubSurface (impl->surface, NULL, &surface) == DFB_OK) {
-        //impl->cairo_surface = cairo_directfb_surface_create (dfb, surface);
-        g_assert( impl->surface != NULL);
-        impl->cairo_surface = cairo_directfb_surface_create (dfb,impl->surface);
-        g_assert( impl->cairo_surface != NULL);
-        cairo_surface_set_user_data (impl->cairo_surface, 
-                                     &gdk_directfb_cairo_key, drawable, 
-                                     gdk_directfb_cairo_surface_destroy);
-       // surface->Release (surface);
-      //}
-    } else {
-        cairo_surface_reference (impl->cairo_surface);
+  g_return_val_if_fail (GDK_IS_DRAWABLE (drawable), NULL);
+  g_return_val_if_fail (GDK_IS_DRAWABLE_IMPL_DIRECTFB (drawable), NULL);
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+  dfb  = GDK_DISPLAY_DFB (gdk_drawable_get_display (drawable))->directfb;
+
+  if (!impl->cairo_surface)
+    {
+      g_assert (impl->surface != NULL);
+      impl->cairo_surface = cairo_directfb_surface_create (dfb, impl->surface);
+      if (impl->cairo_surface)
+        {
+          cairo_surface_set_user_data (impl->cairo_surface,
+                                       &gdk_directfb_cairo_key, drawable,
+                                       gdk_directfb_cairo_surface_destroy);
+        }
     }
-  g_assert( impl->cairo_surface != NULL);
+    else
+      {
+        cairo_surface_reference (impl->cairo_surface);
+      }
+
+  g_assert (impl->cairo_surface != NULL);
+
   return impl->cairo_surface;
 }
-
-#define __GDK_DRAWABLE_X11_C__
-#include "gdkaliasdef.c"
--- gtk+-2.12.12.orig/gdk/directfb/gdkevents-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkevents-directfb.c
@@ -31,16 +31,13 @@
  */
 
 #include "config.h"
+
 #include "gdk.h"
 #include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
-
-#include "gdkinternals.h"
-
-#include "gdkkeysyms.h"
-
 #include "gdkinput-directfb.h"
-#include <string.h>
+
+#include <sys/poll.h>
 
 #ifndef __GDK_X_H__
 #define __GDK_X_H__
@@ -49,165 +46,272 @@
 
 #include "gdkalias.h"
 
-#define EventBuffer _gdk_display->buffer
-#define DirectFB _gdk_display->directfb
-
-
+D_DEBUG_DOMAIN( GDKDFB_Events,     "GDKDFB/Events",     "GDK DirectFB Events" );
+D_DEBUG_DOMAIN( GDKDFB_EventCheck, "GDKDFB/EventCheck", "GDK DirectFB Event Checking" );
+D_DEBUG_DOMAIN( GDKDFB_EventTrans, "GDKDFB/EventTrans", "GDK DirectFB Event Translation" );
 
+typedef struct
+{
+  GSource     source;
+  GdkDisplay *display;
+  GPollFD     event_poll_fd;
+} GdkDisplaySource;
 
-#include "gdkaliasdef.c"
+typedef struct
+{
+  const DFBWindowEvent    *event;
+  GdkWindow               *window;
+  GdkWindowObject         *priv;
+  GdkWindowImplDirectFB   *impl;
+  GdkEventType             type;
+  GdkEventMask             mask;
+  gint                     win_x;
+  gint                     win_y;
+  guint                    button;
+} GdkEventFactory;
 
 /*********************************************
  * Functions for maintaining the event queue *
  *********************************************/
 
-static GdkEvent * gdk_event_translate  (DFBWindowEvent  *dfbevent,
-                                        GdkWindow       *window);
+static gboolean gdk_event_translate   (GdkDisplay       *display,
+                                       GdkEvent         *event,
+                                       DFBWindowEvent   *dfbevent);
+
+static gboolean gdk_event_prepare     (GSource          *source,
+                                       gint             *timeout);
+static gboolean gdk_event_check       (GSource          *source);
+static gboolean gdk_event_dispatch    (GSource          *source,
+                                       GSourceFunc       callback,
+                                       gpointer          user_data);
+
+/*
+ * Private function declarations
+ */
+
+static gboolean gdk_check_dfb_pending (GdkDisplaySource *display_source);
+
+static void gdk_directfb_events_update_mouse_window (GdkWindow *window);
 
 /*
  * Private variable declarations
  */
-static GList *client_filters;  /* Filters for client messages */
 
-static void
-dfb_events_process_window_event (DFBWindowEvent *event)
+static GList *display_sources;
+
+static GSourceFuncs event_funcs = {
+  gdk_event_prepare,
+  gdk_event_check,
+  gdk_event_dispatch,
+  NULL
+};
+
+static GSource *
+gdk_display_source_new (GdkDisplay *display)
 {
-  GdkWindow *window = gdk_directfb_window_id_table_lookup (event->window_id);
+  GSource          *source         = g_source_new (&event_funcs,
+                                                   sizeof (GdkDisplaySource));
+  GdkDisplaySource *display_source = (GdkDisplaySource *) source;
 
-  if (! window)
-     return;
+  D_DEBUG_AT( GDKDFB_Events, "%s( %p )\n", __FUNCTION__, display );
 
-  gdk_event_translate (event, window);
+  display_source->display = display;
+
+  return source;
 }
 
 static gboolean
-gdk_event_send_client_message_by_window (GdkEvent *event,
-                                        GdkWindow *window)
+gdk_event_send_client_message_by_window (GdkEvent  *event,
+                                         GdkWindow *window)
 {
   GdkEvent *new_event;
 
-  g_return_val_if_fail(event != NULL, FALSE);
-  g_return_val_if_fail(GDK_IS_WINDOW(window), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+  g_return_val_if_fail (GDK_IS_WINDOW (window), FALSE);
 
   new_event = gdk_directfb_event_make (window, GDK_CLIENT_EVENT);
   new_event->client.message_type = event->client.message_type;
-  new_event->client.data_format = event->client.data_format;
-  memcpy(&new_event->client.data,
-        &event->client.data,
-        sizeof(event->client.data));
+  new_event->client.data_format  = event->client.data_format;
+  memcpy (&new_event->client.data,
+          &event->client.data,
+          sizeof(event->client.data));
 
   return TRUE;
 }
 
+static gboolean
+gdk_event_prepare (GSource *source,
+                   gint    *timeout)
+{
+  gboolean          retval;
+  GdkDisplaySource *display_source = (GdkDisplaySource *) source;
+  GdkDisplay       *display        = display_source->display;
 
-static void
-dfb_events_dispatch (void)
+  GDK_THREADS_ENTER ();
+
+  *timeout = -1;
+  retval = _gdk_event_queue_find_first (display) != NULL ||
+           gdk_check_dfb_pending (display_source);
+
+  GDK_THREADS_LEAVE ();
+
+  return retval;
+}
+
+static gboolean
+gdk_event_check (GSource *source)
+{
+  gboolean          retval;
+  GdkDisplaySource *display_source = (GdkDisplaySource *) source;
+  GdkDisplay       *display        = display_source->display;
+
+  GDK_THREADS_ENTER ();
+
+  if (display_source->event_poll_fd.revents & G_IO_IN)
+    retval = _gdk_event_queue_find_first (display) != NULL ||
+             gdk_check_dfb_pending (display_source);
+  else
+    retval = FALSE;
+
+  GDK_THREADS_LEAVE ();
+
+  return retval;
+}
+
+static gboolean
+gdk_event_dispatch (GSource     *source,
+                    GSourceFunc  callback,
+                    gpointer     user_data)
 {
-  GdkDisplay *display = gdk_display_get_default ();
+  GdkDisplay *display = ((GdkDisplaySource *) source)->display;
   GdkEvent   *event;
 
-  while ((event = _gdk_event_unqueue (display)) != NULL)
+  GDK_THREADS_ENTER ();
+
+  _gdk_events_queue (display);
+  event = _gdk_event_unqueue (display);
+
+  if (event)
     {
       if (_gdk_event_func)
         (*_gdk_event_func) (event, _gdk_event_data);
 
       gdk_event_free (event);
     }
+
+  GDK_THREADS_LEAVE ();
+
+  return TRUE;
 }
 
 static gboolean
-dfb_events_io_func (GIOChannel   *channel,
-                    GIOCondition  condition,
-                    gpointer      data)
+gdk_check_dfb_pending (GdkDisplaySource *display_source)
 {
-  gsize      i;
-  gsize      read;
-  GIOStatus  result;
-  DFBEvent   buf[23];
-  DFBEvent  *event;
+  struct pollfd pollfd;
 
-  result = g_io_channel_read_chars (channel,
-                                    (gchar *) buf, sizeof (buf), &read, NULL);
+  D_DEBUG_AT( GDKDFB_EventCheck, "%s( %p )\n", __FUNCTION__, display_source );
 
-  if (result == G_IO_STATUS_ERROR)
-    {
-      g_warning ("%s: GIOError occured", __FUNCTION__);
-      return TRUE;
-    }
+  g_return_val_if_fail (display_source != NULL, FALSE);
 
-  read /= sizeof (DFBEvent);
-
-  for (i = 0, event = buf; i < read; i++, event++)
-    {
-      switch (event->clazz)
-        {
-        case DFEC_WINDOW:
-          /* TODO workaround to prevent two DWET_ENTER in a row from being delivered */
-          if (event->window.type == DWET_ENTER ) {
-            if ( i>0 && buf[i-1].window.type != DWET_ENTER )
-              dfb_events_process_window_event (&event->window);
-          }
-          else
-            dfb_events_process_window_event (&event->window);
-          break;
-        default:
-          break;
-        }
-    }
+  D_DEBUG_AT( GDKDFB_EventCheck, "  -> 0x%02x\n", display_source->event_poll_fd.revents );
 
-  EventBuffer->Reset (EventBuffer);
+  pollfd.events = POLL_IN;
+  pollfd.fd     = display_source->event_poll_fd.fd;
 
-  dfb_events_dispatch ();
+  poll (&pollfd, 1, 0);
 
-  return TRUE;
+  return (pollfd.revents & POLL_IN) != 0;
 }
 
 void
-_gdk_events_init (void)
+_gdk_events_init (GdkDisplay *display)
 {
-  GIOChannel *channel;
-  GSource    *source;
-  DFBResult   ret;
-  gint        fd;
+  DFBResult         ret;
+  int               fd;
+  GSource          *source;
+  GdkDisplaySource *display_source;
+  GdkDisplayDFB    *display_dfb = GDK_DISPLAY_DFB (display);
+  IDirectFB        *dfb         = _gdk_display_dfb->directfb;
+
+  D_DEBUG_AT( GDKDFB_Events, "%s( %p )\n", __FUNCTION__, display );
 
-  ret = DirectFB->CreateEventBuffer (DirectFB, &EventBuffer);
+  /* Create an event buffer for this display. */
+  ret = dfb->CreateEventBuffer (dfb, &_gdk_display_dfb->buffer);
   if (ret)
     {
-      DirectFBError ("_gdk_events_init: "
-                     "IDirectFB::CreateEventBuffer() failed", ret);
+      DirectFBError ("_gdk_events_init: CreateEventBuffer() failed", ret);
       return;
     }
 
-  ret = EventBuffer->CreateFileDescriptor (EventBuffer, &fd);
+  /*
+   * Turn buffer into file descriptor mode which writes a copy of each event
+   * to the file descriptor being our "connection number".
+   */
+  ret = _gdk_display_dfb->buffer->CreateFileDescriptor (_gdk_display_dfb->buffer,
+                                                        &fd);
   if (ret)
     {
-      DirectFBError ("_gdk_events_init: "
-                     "IDirectFBEventBuffer::CreateFileDescriptor() failed",
-                     ret);
+      DirectFBError ("_gdk_events_init: CreateFileDescriptor() failed", ret);
       return;
     }
 
-  channel = g_io_channel_unix_new (fd);
+  source = gdk_display_source_new (display);
 
-  g_io_channel_set_encoding (channel, NULL, NULL);
-  g_io_channel_set_buffered (channel, FALSE);
+  display_dfb->event_fd     = fd;
+  display_dfb->event_source = source;
 
-  source = g_io_create_watch (channel, G_IO_IN);
+  display_source = (GdkDisplaySource *) source;
+  display_source->event_poll_fd.fd     = fd;
+  display_source->event_poll_fd.events = G_IO_IN;
 
-  g_source_set_priority (source, G_PRIORITY_DEFAULT);
+  g_source_set_priority (source, GDK_PRIORITY_EVENTS);
   g_source_set_can_recurse (source, TRUE);
-  g_source_set_callback (source, (GSourceFunc) dfb_events_io_func, NULL, NULL);
+  g_source_add_poll (source, &display_source->event_poll_fd);
 
   g_source_attach (source, NULL);
-  g_source_unref (source);
+
+  display_sources = g_list_prepend (display_sources, display_source);
+
+  _gdk_directfb_mouse_window = gdk_window_ref (_gdk_parent_root);
 }
 
 gboolean
 gdk_events_pending (void)
 {
-  GdkDisplay *display = gdk_display_get_default ();
+  GList *tmp_list;
+
+  D_DEBUG_AT( GDKDFB_Events, "%s()\n", __FUNCTION__ );
+
+  /* Check local queues. */
+  for (tmp_list = display_sources; tmp_list; tmp_list = tmp_list->next)
+    {
+      GdkDisplaySource *tmp_source = tmp_list->data;
+      GdkDisplay       *display    = tmp_source->display;
+      GList            *tmp_first  = _gdk_event_queue_find_first (display);
+      GdkEvent         *tmp_event  = tmp_first->data;
+
+      if (tmp_event)
+        {
+          D_DEBUG_AT( GDKDFB_Events, "  -> GDK [%d]\n", tmp_event->type );
+          return TRUE;
+        }
+    }
+
+  /* Check DirectFB queues that might contain events not being added
+   * to the local queue yet.
+   */
+  for (tmp_list = display_sources; tmp_list; tmp_list = tmp_list->next)
+    {
+      GdkDisplaySource *tmp_source = tmp_list->data;
+
+      if (gdk_check_dfb_pending (tmp_source))
+        {
+          D_DEBUG_AT( GDKDFB_Events, "  -> DFB []\n" );
+          return TRUE;
+        }
+    }
 
-  return _gdk_event_queue_find_first (display) ? TRUE : FALSE;
+  return FALSE;
 }
 
 GdkEvent *
@@ -216,6 +320,8 @@
   GdkDisplay *display;
   GList      *list;
 
+  D_DEBUG_AT( GDKDFB_Events, "%s( %p )\n", __FUNCTION__, window );
+
   g_return_val_if_fail (GDK_IS_WINDOW (window), NULL);
 
   display = gdk_drawable_get_display (GDK_DRAWABLE (window));
@@ -243,50 +349,106 @@
 void
 _gdk_events_queue (GdkDisplay *display)
 {
+  int               ret;
+  GList            *node;
+  GdkEvent         *event;
+  DFBEvent          dfbevent;
+  GdkDisplayDFB    *display_dfb = GDK_DISPLAY_DFB (display);
+  GdkDisplaySource *display_source;
+
+  display_source = (GdkDisplaySource *) display_dfb->event_source;
+
+  while (!_gdk_event_queue_find_first (display) &&
+         gdk_check_dfb_pending (display_source))
+    {
+      /* Read one event from the DirectFB queue. */
+      ret = read (display_dfb->event_fd, &dfbevent, sizeof(dfbevent));
+      if (ret <= 0)
+        {
+          g_error ("_gdk_events_queue: Failed to read from file descriptor!");
+          return;
+        }
+
+      /* Only window events are handled and no others should arrive. */
+      if (dfbevent.clazz != DFEC_WINDOW)
+        {
+          g_warning ("_gdk_events_queue: Got event of class %d", dfbevent.clazz);
+          continue;
+        }
+
+      event = gdk_event_new (GDK_NOTHING);
+
+      event->any.window     = NULL;
+      event->any.send_event = FALSE;  /* We don't use PostEvent() so far. */
+
+      ((GdkEventPrivate *) event)->flags |= GDK_EVENT_PENDING;
+
+      node = _gdk_event_queue_append (display, event);
+
+      if (gdk_event_translate (display, event, &dfbevent.window))
+        {
+          ((GdkEventPrivate *) event)->flags &= ~GDK_EVENT_PENDING;
+        }
+      else
+        {
+          _gdk_event_queue_remove_link (display, node);
+          g_list_free_1 (node);
+          gdk_event_free (event);
+        }
+    }
 }
 
 void
 gdk_flush (void)
 {
-gdk_display_flush ( GDK_DISPLAY_OBJECT(_gdk_display));
+  GSList *tmp_list = _gdk_displays;
+
+  while (tmp_list)
+    {
+      IDirectFB *dfb = GDK_DISPLAY_DFB (tmp_list->data)->directfb;
+
+      g_assert (dfb != NULL);
+
+      dfb->WaitIdle (dfb);
+
+      tmp_list = tmp_list->next;
+    }
 }
 
 /* Sends a ClientMessage to all toplevel client windows */
 gboolean
-gdk_event_send_client_message_for_display (GdkDisplay *display,
-                                           GdkEvent   *event,
-                                           guint32     xid)
+gdk_event_send_client_message_for_display (GdkDisplay      *display,
+                                           GdkEvent        *event,
+                                           GdkNativeWindow  winid)
 {
-  GdkWindow *win = NULL;
-  gboolean ret = TRUE;
+  GdkWindow *win;
+  gboolean   ret = FALSE;
 
-  g_return_val_if_fail(event != NULL, FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
 
-  win = gdk_window_lookup_for_display (display, (GdkNativeWindow) xid);
+  win = gdk_window_lookup_for_display (display, winid);
 
-  g_return_val_if_fail(win != NULL, FALSE);
+  g_return_val_if_fail (win != NULL, FALSE);
 
-  if ((GDK_WINDOW_OBJECT(win)->window_type != GDK_WINDOW_CHILD) &&
+  if ((GDK_WINDOW_OBJECT (win)->window_type != GDK_WINDOW_CHILD) &&
       (g_object_get_data (G_OBJECT (win), "gdk-window-child-handler")))
     {
       /* Managed window, check children */
-      GList *ltmp = NULL;
-      for (ltmp = GDK_WINDOW_OBJECT(win)->children; ltmp; ltmp = ltmp->next)
+      GList *l = NULL;
+      for (l = GDK_WINDOW_OBJECT (win)->children; l; l = l->next)
        {
          ret &= gdk_event_send_client_message_by_window (event,
-                                                         GDK_WINDOW(ltmp->data));
+                                                         GDK_WINDOW (l->data));
        }
     }
   else
     {
-      ret &= gdk_event_send_client_message_by_window (event, win);
+      ret = gdk_event_send_client_message_by_window (event, win);
     }
 
   return ret;
 }
 
-/*****/
-
 guint32
 gdk_directfb_get_time (void)
 {
@@ -294,7 +456,7 @@
 
   g_get_current_time (&tv);
 
-  return (guint32) tv.tv_sec * 1000 + tv.tv_usec / 1000;
+  return tv.tv_sec * 1000 + tv.tv_usec / 1000;
 }
 
 void
@@ -309,13 +471,12 @@
   if (!impl->window)
     return;
 
-  if (EventBuffer)
-    impl->window->AttachEventBuffer (impl->window, EventBuffer);
+  if (_gdk_display_dfb->buffer)
+    impl->window->AttachEventBuffer (impl->window, _gdk_display_dfb->buffer);
   else
-    impl->window->CreateEventBuffer (impl->window, &EventBuffer);
+    impl->window->CreateEventBuffer (impl->window, &_gdk_display_dfb->buffer);
 }
 
-#if (DIRECTFB_MAJOR_VERSION >= 1)
 void
 gdk_directfb_event_windows_remove (GdkWindow *window)
 {
@@ -328,11 +489,842 @@
   if (!impl->window)
     return;
 
-  if (EventBuffer)
-    impl->window->DetachEventBuffer (impl->window, EventBuffer);
-/* FIXME: should we warn if (! EventBuffer) ? */
+  if (_gdk_display_dfb->buffer)
+    impl->window->DetachEventBuffer (impl->window, _gdk_display_dfb->buffer);
+}
+
+static gint
+gdk_event_apply_filters (DFBWindowEvent *dfbevent,
+                         GdkEvent       *event,
+                         GList          *filters)
+{
+  GList *tmp_list;
+  GdkFilterReturn result;
+
+  tmp_list = filters;
+
+  while (tmp_list)
+    {
+      GdkEventFilter *filter = (GdkEventFilter *) tmp_list->data;
+
+      tmp_list = tmp_list->next;
+      result = filter->function (dfbevent, event, filter->data);
+      if (result !=  GDK_FILTER_CONTINUE)
+        return result;
+    }
+
+  return GDK_FILTER_CONTINUE;
+}
+
+static GdkEventMask
+get_event_mask_from_dfb_event (const DFBWindowEvent *dfbevent)
+{
+  GdkEventMask mask;
+
+  switch (dfbevent->type)
+    {
+    case DWET_BUTTONDOWN:
+      return GDK_BUTTON_PRESS_MASK;
+
+    case DWET_BUTTONUP:
+      return GDK_BUTTON_RELEASE_MASK;
+
+    case DWET_MOTION:
+      mask = GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK;
+
+      if (dfbevent->buttons & DIBM_LEFT)
+        {
+          mask |= GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK |
+                  GDK_BUTTON_MOTION_MASK  | GDK_BUTTON1_MOTION_MASK      |
+                  GDK_BUTTON1_MASK;
+        }
+
+      if (dfbevent->buttons & DIBM_RIGHT)
+        {
+          mask |= GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK |
+                  GDK_BUTTON_MOTION_MASK  | GDK_BUTTON3_MOTION_MASK      |
+                  GDK_BUTTON3_MASK;
+        }
+
+      if (dfbevent->buttons & DIBM_MIDDLE)
+        {
+          mask |= GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK |
+                  GDK_BUTTON_MOTION_MASK  | GDK_BUTTON2_MOTION_MASK      |
+                  GDK_BUTTON2_MASK;
+        }
+
+      return mask;
+
+    case DWET_WHEEL:
+      /* Since applications that want button press events can get
+       * scroll events on X11 (since scroll wheel events are really
+       * button press events there), we need to use GDK_BUTTON_PRESS_MASK too.
+       */
+      return GDK_SCROLL_MASK | GDK_BUTTON_PRESS_MASK;
+
+    case DWET_KEYDOWN:
+      return GDK_KEY_PRESS_MASK;
+
+    case DWET_KEYUP:
+      return GDK_KEY_RELEASE_MASK;
+
+    case DWET_CLOSE:
+    case DWET_DESTROYED:
+    case DWET_SIZE:
+    case DWET_POSITION:
+    case DWET_POSITION_SIZE:
+      return GDK_STRUCTURE_MASK;
+
+    case DWET_ENTER:
+      return GDK_ENTER_NOTIFY_MASK;
+
+    case DWET_LEAVE:
+      return GDK_LEAVE_NOTIFY_MASK;
+
+    case DWET_GOTFOCUS:
+    case DWET_LOSTFOCUS:
+      return GDK_FOCUS_CHANGE_MASK;
+
+    default:
+      g_warning ("DFBWindowEventType 0x%08x unknown", dfbevent->type);
+    }
+
+  return GDK_ALL_EVENTS_MASK;
+}
+
+static gboolean
+gdk_directfb_window_is_ancestor (GdkWindow *ancestor,
+                                 GdkWindow *window)
+{
+  if (ancestor == NULL || window == NULL)
+    return FALSE;
+
+  return (gdk_window_get_parent (window) == ancestor ||
+          gdk_directfb_window_is_ancestor (ancestor,
+                                           gdk_window_get_parent (window)));
+}
+
+static void
+fixup_event (GdkEvent *event)
+{
+  if (event->any.window)
+    g_object_ref (event->any.window);
+
+  if (((event->any.type == GDK_ENTER_NOTIFY) ||
+       (event->any.type == GDK_LEAVE_NOTIFY)) &&
+      (event->crossing.subwindow != NULL))
+    g_object_ref (event->crossing.subwindow);
+
+  event->any.send_event = FALSE;
+}
+
+static void
+append_event (GdkEvent *event)
+{
+  fixup_event (event);
+
+  _gdk_event_queue_append (GDK_DISPLAY_OBJECT (_gdk_display), event);
+}
+
+static GdkEvent *
+create_crossing_event (GdkWindow            *window,
+                       const DFBWindowEvent *dfbevent,
+                       GdkEventType          event_type,
+                       GdkCrossingMode       mode,
+                       GdkNotifyType         detail)
+{
+  GdkEvent              *event;
+  GdkWindowImplDirectFB *impl;
+
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  event = gdk_event_new (event_type);
+
+  event->crossing.window    = window;
+  event->crossing.subwindow = NULL;
+  event->crossing.time      = dfbevent->timestamp.tv_sec * 1000 +
+                              dfbevent->timestamp.tv_usec / 1000;
+  event->crossing.x         = dfbevent->cx - impl->drawable.abs_x;
+  event->crossing.y         = dfbevent->cy - impl->drawable.abs_y;
+  event->crossing.x_root    = dfbevent->cx;
+  event->crossing.y_root    = dfbevent->cy;
+  event->crossing.mode      = mode;
+  event->crossing.detail    = detail;
+  event->crossing.state     = _gdk_directfb_modifiers;
+
+  if (event_type == GDK_ENTER_NOTIFY)
+    {
+      GDK_NOTE (EVENTS,
+                g_message ("enter notify:\t\twindow: %p  detail: %d subwin: %p",
+                           event->crossing.window,
+                           event->crossing.detail,
+                           event->crossing.subwindow));
+    }
+  else
+    {
+      GDK_NOTE (EVENTS,
+                g_message ("leave notify:\t\twindow: %p  detail: %d subwin: %p",
+                           event->crossing.window,
+                           event->crossing.detail,
+                           event->crossing.subwindow));
+    }
+
+  return event;
+}
+
+static void
+synthesize_enter_event (GdkWindow            *window,
+                        const DFBWindowEvent *dfbevent,
+                        GdkCrossingMode       mode,
+                        GdkNotifyType         detail)
+{
+  GdkEvent *event;
+
+  if (_gdk_directfb_pointer_grab_window != NULL &&
+      !_gdk_directfb_pointer_grab_owner_events &&
+      !(_gdk_directfb_pointer_grab_events & GDK_ENTER_NOTIFY_MASK))
+    return;
+
+  if (!(GDK_WINDOW_OBJECT (window)->event_mask & GDK_ENTER_NOTIFY_MASK))
+    return;
+
+  event = create_crossing_event (window,
+                                 dfbevent, GDK_ENTER_NOTIFY, mode, detail);
+
+  append_event (event);
+}
+
+static void
+synthesize_enter_events (GdkWindow            *from,
+       GdkWindow            *to,
+       const DFBWindowEvent *dfbevent,
+       GdkCrossingMode       mode,
+       GdkNotifyType         detail)
+{
+  GdkWindow *prev = gdk_window_get_parent (to);
+
+  if (prev != from)
+    synthesize_enter_events (from, prev, dfbevent, mode, detail);
+
+  synthesize_enter_event (to, dfbevent, mode, detail);
+}
+
+static void
+synthesize_leave_event (GdkWindow            *window,
+                        const DFBWindowEvent *dfbevent,
+                        GdkCrossingMode       mode,
+                        GdkNotifyType         detail)
+{
+  GdkEvent *event;
+
+  if (_gdk_directfb_pointer_grab_window != NULL &&
+      !_gdk_directfb_pointer_grab_owner_events &&
+      !(_gdk_directfb_pointer_grab_events & GDK_LEAVE_NOTIFY_MASK))
+    return;
+
+  if (!(GDK_WINDOW_OBJECT (window)->event_mask & GDK_LEAVE_NOTIFY_MASK))
+    return;
+
+  event = create_crossing_event (window,
+                                 dfbevent, GDK_LEAVE_NOTIFY, mode, detail);
+
+  append_event (event);
+}
+
+static void
+synthesize_leave_events (GdkWindow            *from,
+                         GdkWindow            *to,
+                         const DFBWindowEvent *dfbevent,
+                         GdkCrossingMode       mode,
+                         GdkNotifyType         detail)
+{
+  GdkWindow *next = gdk_window_get_parent (from);
+
+  synthesize_leave_event (from, dfbevent, mode, detail);
+
+  if (next != to)
+    synthesize_leave_events (next, to, dfbevent, mode, detail);
+}
+
+static void
+synthesize_crossing_events (GdkEventFactory *factory,
+                            GdkWindow       *window,
+                            GdkCrossingMode  mode,
+                            gint             x,
+                            gint             y)
+{
+  GdkWindow *intermediate, *tem, *common_ancestor;
+
+  if (window == _gdk_directfb_mouse_window)
+    return;
+
+  if (gdk_directfb_window_is_ancestor (_gdk_directfb_mouse_window, window))
+    {
+      /* Pointer has moved to an inferior window. */
+      synthesize_leave_event (_gdk_directfb_mouse_window,
+                              factory->event, mode, GDK_NOTIFY_INFERIOR);
+
+      /* If there are intermediate windows, generate ENTER_NOTIFY
+       * events for them.
+       */
+      intermediate = gdk_window_get_parent (window);
+
+      if (intermediate != _gdk_directfb_mouse_window)
+        {
+          synthesize_enter_events (_gdk_directfb_mouse_window, intermediate,
+                                   factory->event, mode, GDK_NOTIFY_VIRTUAL);
+        }
+
+      synthesize_enter_event (window, factory->event, mode, GDK_NOTIFY_ANCESTOR);
+    }
+  else if (gdk_directfb_window_is_ancestor (window, _gdk_directfb_mouse_window))
+    {
+      /* Pointer has moved to an ancestor window. */
+      synthesize_leave_event (_gdk_directfb_mouse_window,
+                              factory->event, mode, GDK_NOTIFY_ANCESTOR);
+
+      /* If there are intermediate windows, generate LEAVE_NOTIFY
+       * events for them.
+       */
+      intermediate = gdk_window_get_parent (_gdk_directfb_mouse_window);
+
+      if (intermediate != window)
+        {
+          synthesize_leave_events (intermediate, window,
+                                   factory->event, mode, GDK_NOTIFY_VIRTUAL);
+        }
+
+      synthesize_enter_event (window, factory->event, mode, GDK_NOTIFY_INFERIOR);
+    }
+  else if (_gdk_directfb_mouse_window)
+    {
+      /* Find least common ancestor of _gdk_directfb_mouse_window and window */
+      tem = _gdk_directfb_mouse_window;
+
+      do
+        {
+          common_ancestor = gdk_window_get_parent (tem);
+          tem = common_ancestor;
+        }
+      while (common_ancestor &&
+             !gdk_directfb_window_is_ancestor (common_ancestor, window));
+
+      if (common_ancestor)
+        {
+          synthesize_leave_event (_gdk_directfb_mouse_window,
+                                  factory->event, mode, GDK_NOTIFY_NONLINEAR);
+
+          intermediate = gdk_window_get_parent (_gdk_directfb_mouse_window);
+
+          if (intermediate != common_ancestor)
+            {
+              synthesize_leave_events (intermediate, common_ancestor,
+                                       factory->event, mode,
+                                       GDK_NOTIFY_NONLINEAR_VIRTUAL);
+            }
+
+          intermediate = gdk_window_get_parent (window);
+
+          if (intermediate != common_ancestor)
+            {
+              synthesize_enter_events (common_ancestor, intermediate,
+                                       factory->event, mode,
+                                       GDK_NOTIFY_NONLINEAR_VIRTUAL);
+            }
+
+          synthesize_enter_event (window,
+                                  factory->event, mode, GDK_NOTIFY_NONLINEAR);
+        }
+    }
+  else
+    {
+      g_warning ("Trying to create crossing event "
+                 "when _gdk_directfb_mouse_window is NULL");
+    }
+
+  gdk_directfb_events_update_mouse_window (window);
+
+  /* This does't work when someone calls gdk_window_set_cursor
+   * during a grab. The right behavior is that the cursor doesn't
+   * change when a grab is in effect, but in that case it does.
+   */
+  if (window && !_gdk_directfb_pointer_grab_window)
+    gdk_directfb_events_update_cursor (window);
+}
+
+/* Synthesizes crossing events if necessary, based on the passed in
+ * DFBEvent. Uses DWET_ENTER and DWET_LEAVE for toplevels and
+ * the mouse moved/dragged events for child windows, to see if the
+ * mouse window has changed.
+ */
+static void
+factory_synthesize_crossing (GdkEventFactory *factory)
+{
+  GdkWindow *mouse_window;
+  gint       x, y;
+
+  switch (factory->event->type)
+    {
+    case DWET_MOTION:
+      /* We only handle moving the pointer to another GDK window. */
+      x = factory->event->cx;
+      y = factory->event->cy;
+      mouse_window = gdk_directfb_child_at (_gdk_parent_root, &x, &y);
+      if (mouse_window != _gdk_parent_root)
+          synthesize_crossing_events (factory,
+                                      mouse_window, GDK_CROSSING_NORMAL, x, y);
+
+      break;
+
+    case DWET_ENTER:
+      x = factory->win_x;
+      y = factory->win_y;
+
+      mouse_window = gdk_directfb_child_at (factory->window, &x, &y);
+
+      /* Treat unknown windows (like the title bar buttons or
+       * desktop) as the root window.
+       */
+      if (!mouse_window)
+        {
+          x = factory->event->cx;
+          y = factory->event->cy;
+          mouse_window = _gdk_parent_root;
+        }
+
+      synthesize_crossing_events (factory,
+                                  mouse_window, GDK_CROSSING_NORMAL, x, y);
+
+      break;
+
+    case DWET_LEAVE:
+      x = factory->event->cx;
+      y = factory->event->cy;
+
+      /* If there is a window other than the root window at this
+       * position, it means we didn't exit to the root window and we
+       * ignore the event. (Note that we can get NULL here when swithing
+       * spaces for example.)
+       *
+       * FIXME: This is not enough, it doesn't catch the case where
+       * we leave a GDK window to a non-GDK window that has GDK
+       * windows below it.
+       */
+      mouse_window = gdk_directfb_child_at (factory->window, &x, &y);
+
+      if (!mouse_window ||
+          gdk_directfb_window_find_toplevel (mouse_window) ==
+          gdk_directfb_window_find_toplevel (_gdk_directfb_mouse_window))
+        {
+          mouse_window = _gdk_parent_root;
+        }
+
+      if (mouse_window == _gdk_parent_root)
+        synthesize_crossing_events (factory, _gdk_parent_root, GDK_CROSSING_NORMAL, x, y);
+
+      break;
+
+    default:
+      break;
+    }
+}
+
+/* Checks if the passed in window is interested in the event mask, and
+ * if so, it's returned. If not, the event can be propagated through
+ * its ancestors until one with the right event mask is found, up to
+ * the nearest toplevel.
+ */
+static GdkWindow *
+find_window_interested_in_event_mask (GdkWindow    *window,
+                                      GdkEventMask  event_mask,
+                                      gboolean      propagate)
+{
+  GdkWindowObject *private;
+
+  private = GDK_WINDOW_OBJECT (window);
+
+  while (private)
+    {
+      if (private->event_mask & event_mask)
+        return GDK_WINDOW (private);
+
+      if (!propagate)
+        return NULL;
+
+      /* Don't traverse beyond toplevels. */
+      if (GDK_WINDOW_TYPE (private) != GDK_WINDOW_CHILD)
+        break;
+
+      private = private->parent;
+    }
+
+  return NULL;
+}
+
+static gboolean
+factory_process (GdkEventFactory  *factory,
+                 GdkWindow       **ret_event_window,
+                 GdkWindow       **ret_filter_window)
+{
+  int                   wx, wy;
+  const DFBWindowEvent *dfbevent;
+  GdkWindow            *event_window;
+  GdkWindow            *mouse_window;
+  GdkWindow            *filter_window;
+  guint                 mask;
+  guint                 button;
+
+  g_return_val_if_fail (factory != NULL, FALSE);
+  g_return_val_if_fail (factory->event != NULL, FALSE);
+  g_return_val_if_fail (GDK_IS_WINDOW (factory->window), FALSE);
+
+  /* Initialize with root window coords. */
+  dfbevent = factory->event;
+  wx       = dfbevent->cx;
+  wy       = dfbevent->cy;
+
+  /* Start with original window. */
+  event_window = factory->window;
+
+  /* We always run the filters for the window where the event
+   * is delivered, not the window that it relates to.
+   */
+  filter_window = factory->window;
+
+  /* Generate event mask from type, buttons etc. */
+  factory->mask = get_event_mask_from_dfb_event (dfbevent);
+
+  D_DEBUG_AT( GDKDFB_EventTrans, "  -> event mask    0x%08x\n", factory->mask );
+
+  /* Check event types. */
+  switch (dfbevent->type)
+    {
+    case DWET_BUTTONDOWN:
+    case DWET_BUTTONUP:
+    case DWET_MOTION:
+    case DWET_WHEEL:
+      _gdk_directfb_mouse_x = dfbevent->cx;
+      _gdk_directfb_mouse_y = dfbevent->cy;
+
+      /* Map button to index and mask. */
+      switch (dfbevent->button)
+        {
+        case DIBI_LEFT:
+          button = 1;
+          mask   = GDK_BUTTON1_MASK;
+          break;
+        case DIBI_MIDDLE:
+          button = 2;
+          mask   = GDK_BUTTON2_MASK;
+          break;
+        case DIBI_RIGHT:
+          button = 3;
+          mask   = GDK_BUTTON3_MASK;
+          break;
+        default:
+          button = dfbevent->button + 1;
+          mask   = 0;
+          break;
+        }
+
+      factory->button = button;
+
+      if (dfbevent->type == DWET_BUTTONDOWN)
+        _gdk_directfb_modifiers |= mask;
+      else
+        _gdk_directfb_modifiers &= ~mask;
+
+      factory->type = (dfbevent->type == DWET_BUTTONDOWN ? GDK_BUTTON_PRESS   :
+                       dfbevent->type == DWET_BUTTONUP   ? GDK_BUTTON_RELEASE :
+                       dfbevent->type == DWET_MOTION     ? GDK_MOTION_NOTIFY  :
+                       GDK_SCROLL);
+
+      /* If owner_events is True and if a generated pointer event
+       * would normally be reported to this client, it is reported
+       * as usual. Otherwise, the event is reported with respect to
+       * the grab_window and is reported only if selected by
+       * event_mask. For either value of owner_events, unreported
+       * events are discarded.
+       *
+       * This means we first try the owner, then the grab window,
+       * then give up.
+       */
+      if (_gdk_directfb_pointer_grab_window)
+        {
+          if (_gdk_directfb_pointer_grab_owner_events)
+            {
+              mouse_window = gdk_directfb_child_at (_gdk_parent_root, &wx, &wy);
+              event_window = find_window_interested_in_event_mask (mouse_window,
+                                                                   factory->mask,
+                                                                   TRUE);
+
+              /* We have to translate the coordinates if the actual
+               * window is different from the mouse window.
+               */
+              if (mouse_window && event_window && mouse_window != event_window)
+                {
+                  GdkDrawableImplDirectFB *impl;
+                  impl = GDK_DRAWABLE_IMPL_DIRECTFB (
+                    GDK_WINDOW_OBJECT (event_window)->impl);
+
+                  wx = dfbevent->cx - impl->abs_x;
+                  wy = dfbevent->cy - impl->abs_y;
+                }
+
+              if (event_window)
+                {
+                  D_DEBUG_AT( GDKDFB_EventTrans, "  -> owner       %4d,%4d (%4d,%4d) [%4d,%4d]\n",
+                              wx, wy, dfbevent->x, dfbevent->y, dfbevent->cx, dfbevent->cy );
+                  break;
+                }
+            }
+
+          /* Finally check the grab window. */
+          if (_gdk_directfb_pointer_grab_events & factory->mask)
+            {
+              GdkDrawableImplDirectFB *impl;
+              impl = GDK_DRAWABLE_IMPL_DIRECTFB (
+                GDK_WINDOW_OBJECT (_gdk_directfb_pointer_grab_window)->impl);
+
+              wx = dfbevent->cx - impl->abs_x;
+              wy = dfbevent->cy - impl->abs_y;
+
+              event_window = _gdk_directfb_pointer_grab_window;
+
+              D_DEBUG_AT( GDKDFB_EventTrans, "  -> grab        %4d,%4d (%4d,%4d) [%4d,%4d]\n",
+                          wx, wy, dfbevent->x, dfbevent->y, dfbevent->cx, dfbevent->cy );
+            }
+          else
+            event_window = NULL;
+        }
+      else
+        {
+          /* The non-grabbed case. */
+          mouse_window = gdk_directfb_child_at (_gdk_parent_root, &wx, &wy);
+          event_window = find_window_interested_in_event_mask (mouse_window,
+                                                               factory->mask,
+                                                               TRUE);
+
+          /* We have to translate the coordinates if the actual
+           * window is different from the mouse window.
+           */
+          if (mouse_window && event_window && mouse_window != event_window)
+            {
+              GdkDrawableImplDirectFB *impl;
+              impl = GDK_DRAWABLE_IMPL_DIRECTFB (
+                GDK_WINDOW_OBJECT (event_window)->impl);
+
+              wx = dfbevent->cx - impl->abs_x;
+              wy = dfbevent->cy - impl->abs_y;
+            }
+
+          D_DEBUG_AT( GDKDFB_EventTrans, "  -> normal      %4d,%4d (%4d,%4d) [%4d,%4d]\n",
+                      wx, wy, dfbevent->x, dfbevent->y, dfbevent->cx, dfbevent->cy );
+        }
+      break;
+
+    case DWET_GOTFOCUS:
+    case DWET_LOSTFOCUS:
+      factory->type = GDK_FOCUS_CHANGE;
+      event_window  = find_window_interested_in_event_mask (event_window,
+                                                            factory->mask,
+                                                            TRUE);
+      break;
+
+    case DWET_POSITION:
+    case DWET_POSITION_SIZE:
+    case DWET_SIZE:
+      factory->type = GDK_CONFIGURE;
+      event_window  = find_window_interested_in_event_mask (event_window,
+                                                            factory->mask,
+                                                            TRUE);
+      break;
+
+    case DWET_KEYDOWN:
+    case DWET_KEYUP:
+      factory->type = (dfbevent->type == DWET_KEYUP ? GDK_KEY_RELEASE :
+                                                      GDK_KEY_PRESS);
+      if (_gdk_directfb_keyboard_grab_window &&
+          !_gdk_directfb_keyboard_grab_owner_events)
+        event_window = _gdk_directfb_keyboard_grab_window;
+      else
+        {
+          if (!_gdk_directfb_keyboard_window)
+            _gdk_directfb_keyboard_window = g_object_ref (_gdk_parent_root);
+
+          event_window = find_window_interested_in_event_mask (
+                           _gdk_directfb_keyboard_window, factory->mask, TRUE);
+        }
+      break;
+
+    case DWET_LEAVE:
+      factory->type = GDK_LEAVE_NOTIFY;
+      event_window  = gdk_directfb_child_at (_gdk_parent_root, &wx, &wy);
+      if (event_window == _gdk_parent_root)
+        event_window = NULL;
+      break;
+
+    case DWET_ENTER:
+      factory->type = GDK_ENTER_NOTIFY;
+      event_window  = gdk_directfb_child_at (_gdk_parent_root, &wx, &wy);
+
+      /* this makes sure pointer is set correctly when it previously left
+       * a window being not standard shaped
+       */
+      if (event_window)
+        gdk_window_set_cursor (event_window, NULL);
+      break;
+
+    case DWET_CLOSE:
+      factory->type = GDK_DELETE;
+      event_window  = find_window_interested_in_event_mask (event_window,
+                                                            factory->mask,
+                                                            TRUE);
+      break;
+
+    case DWET_DESTROYED:
+      factory->type = GDK_DESTROY;
+      event_window  = find_window_interested_in_event_mask (event_window,
+                                                            factory->mask,
+                                                            TRUE);
+      break;
+
+    default:
+      g_warning ("DFBWindowEventType 0x%08x unknown", dfbevent->type);
+    }
+
+  /* Return information. */
+  factory->win_x = wx;
+  factory->win_y = wy;
+
+  if (ret_event_window)
+    *ret_event_window = event_window;
+
+  if (ret_filter_window)
+    *ret_filter_window = filter_window;
+
+  return TRUE;
+}
+
+static gboolean
+factory_init (GdkEventFactory      *factory,
+              GdkDisplay           *display,
+              const DFBWindowEvent *dfbevent)
+{
+  GdkWindow       *window;
+  GdkWindowObject *private;
+
+  g_return_val_if_fail (factory != NULL, FALSE);
+  g_return_val_if_fail (GDK_IS_DISPLAY (display), FALSE);
+  g_return_val_if_fail (dfbevent != NULL, FALSE);
+
+  memset (factory, 0, sizeof(GdkEventFactory));
+
+  window = gdk_window_lookup_for_display (display, dfbevent->window_id);
+  if (!window)
+    {
+      g_warning ("factory_init: Could not find window for id %u!",
+                 dfbevent->window_id);
+      return FALSE;
+    }
+
+  g_return_val_if_fail (GDK_IS_WINDOW (window), FALSE);
+
+  private = GDK_WINDOW_OBJECT (window);
+
+  factory->event  = dfbevent;
+  factory->window = window;
+  factory->priv   = private;
+  factory->impl   = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+  factory->win_x  = dfbevent->x;
+  factory->win_y  = dfbevent->y;
+
+  return TRUE;
+}
+
+static gboolean
+factory_build (GdkEventFactory *factory,
+               GdkEvent        *event,
+               GdkWindow       *window)
+{
+  const DFBWindowEvent *dfbevent;
+  guint32               the_time;
+
+  g_return_val_if_fail (factory != NULL, FALSE);
+  g_return_val_if_fail (factory->event != NULL, FALSE);
+  g_return_val_if_fail (factory->window != NULL, FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  dfbevent = factory->event;
+  the_time = dfbevent->timestamp.tv_sec * 1000 +
+             dfbevent->timestamp.tv_usec / 1000;
+
+  event->any.type       = factory->type;
+  event->any.window     = window;
+  event->any.send_event = FALSE;  /* We don't use PostEvent() so far. */
+
+  switch (factory->type)
+    {
+    case GDK_MOTION_NOTIFY:
+      event->motion.time = the_time;
+      event->motion.axes = NULL;
+      break;
+    case GDK_BUTTON_PRESS:
+    case GDK_2BUTTON_PRESS:
+    case GDK_3BUTTON_PRESS:
+    case GDK_BUTTON_RELEASE:
+      event->button.time = the_time;
+      event->button.axes = NULL;
+      break;
+    case GDK_KEY_PRESS:
+    case GDK_KEY_RELEASE:
+      event->key.time = the_time;
+      break;
+    case GDK_ENTER_NOTIFY:
+    case GDK_LEAVE_NOTIFY:
+      event->crossing.time = the_time;
+      break;
+    case GDK_PROPERTY_NOTIFY:
+      event->property.time = the_time;
+      break;
+    case GDK_SELECTION_CLEAR:
+    case GDK_SELECTION_REQUEST:
+    case GDK_SELECTION_NOTIFY:
+      event->selection.time = the_time;
+      break;
+    case GDK_PROXIMITY_IN:
+    case GDK_PROXIMITY_OUT:
+      event->proximity.time = the_time;
+      break;
+    case GDK_DRAG_ENTER:
+    case GDK_DRAG_LEAVE:
+    case GDK_DRAG_MOTION:
+    case GDK_DRAG_STATUS:
+    case GDK_DROP_START:
+    case GDK_DROP_FINISHED:
+      event->dnd.time = the_time;
+      break;
+    case GDK_SCROLL:
+      event->scroll.time = the_time;
+      break;
+    case GDK_FOCUS_CHANGE:
+      event->focus_change.in = (dfbevent->type == DWET_GOTFOCUS);
+      break;
+    case GDK_CONFIGURE:
+    case GDK_MAP:
+    case GDK_UNMAP:
+    case GDK_CLIENT_EVENT:
+    case GDK_VISIBILITY_NOTIFY:
+    case GDK_NO_EXPOSE:
+    case GDK_DELETE:
+    case GDK_DESTROY:
+    case GDK_EXPOSE:
+    default:
+      break;
+    }
+
+  return TRUE;
 }
-#endif
 
 GdkWindow *
 gdk_directfb_child_at (GdkWindow *window,
@@ -345,289 +1337,272 @@
   g_return_val_if_fail (GDK_IS_WINDOW (window), NULL);
 
   private = GDK_WINDOW_OBJECT (window);
+
   for (list = private->children; list; list = list->next)
     {
       GdkWindowObject *win = list->data;
 
       if (GDK_WINDOW_IS_MAPPED (win) &&
-          *winx >= win->x  &&
-          *winx <  win->x + GDK_DRAWABLE_IMPL_DIRECTFB (win->impl)->width  &&
-          *winy >= win->y  &&
+          *winx >= win->x &&
+          *winx <  win->x + GDK_DRAWABLE_IMPL_DIRECTFB (win->impl)->width &&
+          *winy >= win->y &&
           *winy <  win->y + GDK_DRAWABLE_IMPL_DIRECTFB (win->impl)->height)
         {
           *winx -= win->x;
           *winy -= win->y;
 
-          return gdk_directfb_child_at (GDK_WINDOW (win), winx, winy );
+          return gdk_directfb_child_at (GDK_WINDOW (win), winx, winy);
         }
     }
 
   return window;
 }
 
-static GdkEvent *
-gdk_event_translate (DFBWindowEvent *dfbevent,
-                     GdkWindow      *window)
+static gboolean
+gdk_event_translate (GdkDisplay     *display,
+                     GdkEvent       *event,
+                     DFBWindowEvent *dfbevent)
 {
-  GdkWindowObject *private;
-  GdkDisplay      *display;
-  GdkEvent        *event    = NULL;
+  GdkEventFactory  factory;
+  GdkWindow       *event_window  = NULL;
+  GdkWindowObject *event_private = NULL;
+  GdkWindow       *filter_window = NULL;
+  gboolean         return_val    = FALSE;
+
+  g_return_val_if_fail (GDK_IS_DISPLAY_DFB (display), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+  g_return_val_if_fail (dfbevent != NULL, FALSE);
 
-  g_return_val_if_fail (dfbevent != NULL, NULL);
-  g_return_val_if_fail (GDK_IS_WINDOW (window), NULL);
+  D_DEBUG_AT( GDKDFB_EventTrans, "%s( %p, %p, %p )\n", __FUNCTION__, display, event, dfbevent );
+  D_DEBUG_AT( GDKDFB_EventTrans, "  -> type       %s\n", dfb_window_event_type_name (dfbevent->type) );
 
-  private = GDK_WINDOW_OBJECT (window);
+  /* Apply global filters. */
+  if (_gdk_default_filters)
+    {
+      GdkFilterReturn result = gdk_event_apply_filters (dfbevent, event,
+                                                        _gdk_default_filters);
+      if (result != GDK_FILTER_CONTINUE)
+        {
+          return_val = (result == GDK_FILTER_TRANSLATE) ? TRUE : FALSE;
+          goto done;
+        }
+    }
 
-  g_object_ref (G_OBJECT (window));
-  display = gdk_drawable_get_display (GDK_DRAWABLE (window));
+  /* Determine the original window of the event, type, mask etc. */
+  if (!factory_init (&factory, display, dfbevent))
+    goto done;
+
+  if (factory.impl)
+    D_DEBUG_AT( GDKDFB_EventTrans, "  -> window     [" GDKDFB_WIMPL_FORM "]\n",
+                GDKDFB_WIMPL_V (factory.impl) );
+
+  /* Take care of DWET_ENTER/LEAVE events and mouse movement
+   * events and emit the right GDK crossing events.
+   */
+  factory_synthesize_crossing (&factory);
+
+  /* Main part of adaption, may synthesize some events, will determine actual window
+   * to which the event should be sent and return the window that filters it.
+   */
+  if (!factory_process (&factory, &event_window, &filter_window))
+    goto done;
+
+  /* We always run the filters for the window where the event
+   * is delivered, not the window that it relates to.
+   */
+  if (filter_window && !GDK_IS_WINDOW (filter_window))
+    filter_window = NULL;
 
-  switch (dfbevent->type)
+  /* Check window receiving the event. */
+  if (event_window)
     {
-    case DWET_BUTTONDOWN:
-    case DWET_BUTTONUP:
-      {
-        static gboolean  click_grab = FALSE;
-        GdkWindow       *child;
-        gint             wx, wy;
-        guint            mask;
-        guint            button;
+      if (GDK_IS_WINDOW (event_window))
+        {
+          GdkWindowImplDirectFB *event_impl;
 
-        _gdk_directfb_mouse_x = wx = dfbevent->cx;
-        _gdk_directfb_mouse_y = wy = dfbevent->cy;
+          GDK_DFB_UNUSED_P (event_impl);
 
-        switch (dfbevent->button)
-          {
-          case DIBI_LEFT:
-            button = 1;
-            mask   = GDK_BUTTON1_MASK;
-            break;
-          case DIBI_MIDDLE:
-            button = 2;
-            mask   = GDK_BUTTON2_MASK;
-            break;
-          case DIBI_RIGHT:
-            button = 3;
-            mask   = GDK_BUTTON3_MASK;
-            break;
-          default:
-            button = dfbevent->button + 1;
-            mask   = 0;
-            break;
-          }
+          g_object_ref (G_OBJECT (event_window));
 
-        child = gdk_directfb_child_at (_gdk_parent_root, &wx, &wy);
+          event_private = GDK_WINDOW_OBJECT (event_window);
+          event_impl = GDK_WINDOW_IMPL_DIRECTFB (event_private->impl);
 
-        if (_gdk_directfb_pointer_grab_window &&
-            (_gdk_directfb_pointer_grab_events & (dfbevent->type ==
-                                                  DWET_BUTTONDOWN ?
-                                                  GDK_BUTTON_PRESS_MASK :
-                                                  GDK_BUTTON_RELEASE_MASK)) &&
-            (_gdk_directfb_pointer_grab_owner_events == FALSE ||
-             child == _gdk_parent_root) )
-          {
-            GdkDrawableImplDirectFB *impl;
+          D_DEBUG_AT( GDKDFB_EventTrans, "  -> event win  [" GDKDFB_WIMPL_FORM "]\n",
+                      GDKDFB_WIMPL_V (event_impl) );
+        }
+      else
+        event_window = NULL;
+    }
 
-            child = _gdk_directfb_pointer_grab_window;
-            impl  = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (child)->impl);
+  if (event_private && GDK_WINDOW_DESTROYED (event_window))
+    {
+      if (dfbevent->type != DWET_DESTROYED)
+        goto done;
+    }
+  else if (filter_window)
+    {
+      /* Apply per-window filters. */
+      GdkWindowObject *filter_private = GDK_WINDOW_OBJECT (filter_window);
 
-            dfbevent->x = dfbevent->cx - impl->abs_x;
-            dfbevent->y = dfbevent->cy - impl->abs_y;
-          }
-        else if (!_gdk_directfb_pointer_grab_window ||
-                 (_gdk_directfb_pointer_grab_owner_events == TRUE))
-          {
-            dfbevent->x = wx;
-            dfbevent->y = wy;
-          }
-        else
-          {
-            child = NULL;
-          }
+      if (filter_private->filters)
+        {
+          GdkFilterReturn result;
 
-        if (dfbevent->type == DWET_BUTTONDOWN)
-          _gdk_directfb_modifiers |= mask;
-        else
-          _gdk_directfb_modifiers &= ~mask;
+          g_object_ref (filter_window);
 
-        if (child)
-          {
-            event =
-              gdk_directfb_event_make (child,
-                                       dfbevent->type == DWET_BUTTONDOWN ?
-                                       GDK_BUTTON_PRESS : GDK_BUTTON_RELEASE);
-
-            event->button.x_root = _gdk_directfb_mouse_x;
-            event->button.y_root = _gdk_directfb_mouse_y;
-
-            event->button.x = dfbevent->x;
-            event->button.y = dfbevent->y;
-
-            event->button.state  = _gdk_directfb_modifiers;
-            event->button.button = button;
-            event->button.device = display->core_pointer;
-
-            GDK_NOTE (EVENTS,
-                      g_message ("button: %d at %d,%d %s with state 0x%08x",
-                                 event->button.button,
-                                 (int)event->button.x, (int)event->button.y,
-                                 dfbevent->type == DWET_BUTTONDOWN ?
-                                 "pressed" : "released",
-                                 _gdk_directfb_modifiers));
+          result = gdk_event_apply_filters (dfbevent, event,
+                                            filter_private->filters);
 
-            if (dfbevent->type == DWET_BUTTONDOWN)
-              _gdk_event_button_generate (display, event);
-          }
+          g_object_unref (filter_window);
 
-        /* Handle implicit button grabs: */
-        if (dfbevent->type == DWET_BUTTONDOWN  &&  !click_grab  &&  child)
-          {
-            if (gdk_directfb_pointer_grab (child, FALSE,
-                                           gdk_window_get_events (child),
-                                           NULL, NULL,
-                                           GDK_CURRENT_TIME,
-                                           TRUE) == GDK_GRAB_SUCCESS)
-              click_grab = TRUE;
-          }
-        else if (dfbevent->type == DWET_BUTTONUP &&
-                 !(_gdk_directfb_modifiers & (GDK_BUTTON1_MASK |
-                                              GDK_BUTTON2_MASK |
-                                              GDK_BUTTON3_MASK)) && click_grab)
-          {
+          if (result != GDK_FILTER_CONTINUE)
+            {
+              return_val = (result == GDK_FILTER_TRANSLATE) ? TRUE : FALSE;
+              goto done;
+            }
+        }
+    }
+
+  /* Fill out GDK Event structure. */
+  if (!factory_build (&factory, event, event_window))
+    goto done;
+
+  switch (dfbevent->type)
+    {
+    case DWET_BUTTONDOWN:
+    case DWET_BUTTONUP:
+      if (dfbevent->type == DWET_BUTTONDOWN)
+        {
+          GdkEventMask event_mask;
+
+          GDK_NOTE (EVENTS,
+                    g_message ("button press:\t\twindow: %p  x,y: %d %d (%d)",
+                               event_window,
+                               factory.win_x, factory.win_y,
+                               event->button.button));
+
+          /* Emulate implicit grab, when the window has both PRESS and RELEASE
+           * in its mask, like X.
+           */
+          event_mask = (GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK);
+          if (!_gdk_directfb_pointer_grab_window && event_window &&
+              (GDK_WINDOW_OBJECT (event_window)->event_mask & event_mask)
+                == event_mask)
+            {
+              gdk_directfb_pointer_grab (event_window, FALSE,
+                                         gdk_window_get_events (event_window),
+                                         NULL, NULL, GDK_CURRENT_TIME, TRUE);
+            }
+        }
+      else
+        {
+          GDK_NOTE (EVENTS,
+                    g_message ("button release:\t\twindow: %p  x,y: %d %d (%d)",
+                               event_window,
+                               factory.win_x, factory.win_y,
+                               event->button.button));
+
+          if (!(_gdk_directfb_modifiers & (GDK_BUTTON1_MASK |
+                                           GDK_BUTTON2_MASK |
+                                           GDK_BUTTON3_MASK)))
             gdk_directfb_pointer_ungrab (GDK_CURRENT_TIME, TRUE);
-            click_grab = FALSE;
-          }
-      }
+        }
+
+      if (event_window)
+        {
+          event->button.x_root = _gdk_directfb_mouse_x;
+          event->button.y_root = _gdk_directfb_mouse_y;
+          event->button.x      = factory.win_x;
+          event->button.y      = factory.win_y;
+          event->button.state  = _gdk_directfb_modifiers;
+          event->button.button = factory.button;
+          event->button.device = display->core_pointer;
+
+          D_DEBUG_AT( GDKDFB_EventTrans, "  => BUTTON   %c%d %4.0f,%4.0f (0x%08x)\n",
+                      (dfbevent->type == DWET_BUTTONDOWN) ? '+' : '-',
+                      event->button.button, event->button.x, event->button.y, event->button.state );
+
+          if (dfbevent->type == DWET_BUTTONDOWN)
+            _gdk_event_button_generate (display, event);
+
+          return_val = TRUE;
+        }
       break;
 
     case DWET_MOTION:
-      {
-        GdkWindow *event_win=NULL;
-        GdkWindow *child;
+      GDK_NOTE (EVENTS,
+                g_message ("motion notify:\t\twindow: %p  x,y: %d %d  hint: %s",
+                           event_window,
+                           factory.win_x, factory.win_y,
+                           event->motion.is_hint ? "true" : "false"));
 
-        _gdk_directfb_mouse_x = dfbevent->cx;
-        _gdk_directfb_mouse_y = dfbevent->cy;
+      if (event_window)
+        {
+          event->motion.x_root  = _gdk_directfb_mouse_x;
+          event->motion.y_root  = _gdk_directfb_mouse_y;
+          event->motion.x       = factory.win_x;
+          event->motion.y       = factory.win_y;
+          event->motion.state   = _gdk_directfb_modifiers;
+          event->motion.is_hint = FALSE;
+          event->motion.device  = display->core_pointer;
 
-	//child = gdk_directfb_child_at (window, &dfbevent->x, &dfbevent->y);
-    /* Go all the way to root to catch popup menus */
-    int wx=_gdk_directfb_mouse_x;
-    int wy=_gdk_directfb_mouse_y;
-	child = gdk_directfb_child_at (_gdk_parent_root, &wx, &wy);
-
-    /* first let's see if any cossing event has to be send */
-    gdk_directfb_window_send_crossing_events (NULL, child, GDK_CROSSING_NORMAL);
-
-    /* then dispatch the motion event to the window the cursor it's inside */
-	event_win = gdk_directfb_pointer_event_window (child, GDK_MOTION_NOTIFY);
-
-
-	if (event_win)
-	  {
-
-	    if (event_win == _gdk_directfb_pointer_grab_window) {
-		GdkDrawableImplDirectFB *impl;
-
-		child = _gdk_directfb_pointer_grab_window;
-		impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (child)->impl);
-
-		dfbevent->x = _gdk_directfb_mouse_x - impl->abs_x;
-		dfbevent->y = _gdk_directfb_mouse_y - impl->abs_y;
-	      }
-
-	    event = gdk_directfb_event_make (child, GDK_MOTION_NOTIFY);
-
-	    event->motion.x_root = _gdk_directfb_mouse_x;
-	    event->motion.y_root = _gdk_directfb_mouse_y;
-
-	    //event->motion.x = dfbevent->x;
-	    //event->motion.y = dfbevent->y;
-	    event->motion.x = wx;
-	    event->motion.y = wy;
-
-	    event->motion.state   = _gdk_directfb_modifiers;
-	    event->motion.is_hint = FALSE;
-	    event->motion.device  = display->core_pointer;
-
-	    if (GDK_WINDOW_OBJECT (event_win)->event_mask &
-		GDK_POINTER_MOTION_HINT_MASK)
-	      {
-		while (EventBuffer->PeekEvent (EventBuffer,
-					       DFB_EVENT (dfbevent)) == DFB_OK
-		       && dfbevent->type == DWET_MOTION)
-		  {
-		    EventBuffer->GetEvent (EventBuffer, DFB_EVENT (dfbevent));
-		    event->motion.is_hint = TRUE;
-		  }
-	      }
-	  }
-          /* make sure crossing events go to the event window found */
-/*        GdkWindow *ev_win = ( event_win == NULL ) ? gdk_window_at_pointer (NULL,NULL) :event_win;
-	     gdk_directfb_window_send_crossing_events (NULL,ev_win,GDK_CROSSING_NORMAL);
-*/
-      }
+          D_DEBUG_AT( GDKDFB_EventTrans, "  => MOTION      %4.0f,%4.0f (0x%08x)\n",
+                      event->motion.x, event->motion.y, event->motion.state );
+
+          return_val = TRUE;
+        }
       break;
 
     case DWET_GOTFOCUS:
-      gdk_directfb_change_focus (window);
-
+      gdk_directfb_change_focus (event_window);
+      return_val = TRUE;
       break;
 
     case DWET_LOSTFOCUS:
       gdk_directfb_change_focus (_gdk_parent_root);
-
+      return_val = TRUE;
       break;
 
     case DWET_POSITION:
-      {
-        GdkWindow *event_win;
+      factory.priv->x = dfbevent->x;
+      factory.priv->y = dfbevent->y;
 
-        private->x = dfbevent->x;
-        private->y = dfbevent->y;
-
-        event_win = gdk_directfb_other_event_window (window, GDK_CONFIGURE);
+      if (event_window)
+        {
+          event->configure.x      = dfbevent->x;
+          event->configure.y      = dfbevent->y;
+          event->configure.width  = factory.impl->drawable.width;
+          event->configure.height = factory.impl->drawable.height;
 
-        if (event_win)
-          {
-            event = gdk_directfb_event_make (event_win, GDK_CONFIGURE);
-            event->configure.x = dfbevent->x;
-            event->configure.y = dfbevent->y;
-            event->configure.width =
-              GDK_DRAWABLE_IMPL_DIRECTFB (private->impl)->width;
-            event->configure.height =
-              GDK_DRAWABLE_IMPL_DIRECTFB (private->impl)->height;
-          }
+          return_val = TRUE;
+        }
 
-        _gdk_directfb_calc_abs (window);
-      }
+      gdk_directfb_calc_abs (factory.window);
       break;
 
     case DWET_POSITION_SIZE:
-      private->x = dfbevent->x;
-      private->y = dfbevent->y;
+      factory.priv->x = dfbevent->x;
+      factory.priv->y = dfbevent->y;
       /* fallthru */
 
     case DWET_SIZE:
       {
-        GdkDrawableImplDirectFB *impl;
-        GdkWindow               *event_win;
-        GList                   *list;
+        GList *list;
 
-        impl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
-
-        event_win = gdk_directfb_other_event_window (window, GDK_CONFIGURE);
-
-        if (event_win)
+        if (event_window)
           {
-            event = gdk_directfb_event_make (event_win, GDK_CONFIGURE);
-            event->configure.x      = private->x;
-            event->configure.y      = private->y;
+            event->configure.x      = factory.priv->x;
+            event->configure.y      = factory.priv->y;
             event->configure.width  = dfbevent->w;
             event->configure.height = dfbevent->h;
+
+            return_val = TRUE;
           }
 
-        impl->width  = dfbevent->w;
-        impl->height = dfbevent->h;
+        factory.impl->drawable.width  = dfbevent->w;
+        factory.impl->drawable.height = dfbevent->h;
 
-        for (list = private->children; list; list = list->next)
+        for (list = factory.priv->children; list; list = list->next)
           {
             GdkWindowObject         *win;
             GdkDrawableImplDirectFB *impl;
@@ -635,150 +1610,95 @@
             win  = GDK_WINDOW_OBJECT (list->data);
             impl = GDK_DRAWABLE_IMPL_DIRECTFB (win->impl);
 
-            _gdk_directfb_move_resize_child (GDK_WINDOW (win),
-                                             win->x, win->y,
-                                             impl->width, impl->height);
+            gdk_directfb_move_resize_child (GDK_WINDOW (win),
+                                            win->x, win->y,
+                                            impl->width, impl->height);
           }
 
-        _gdk_directfb_calc_abs (window);
+        if (dfbevent->type != DWET_SIZE)
+          gdk_directfb_calc_abs (factory.window);
 
-        gdk_window_clear (window);
-        gdk_window_invalidate_rect (window, NULL, TRUE);
+        gdk_window_clear (factory.window);
+        gdk_window_invalidate_rect (factory.window, NULL, TRUE);
       }
       break;
 
     case DWET_KEYDOWN:
     case DWET_KEYUP:
-      {
-
-        GdkEventType type = (dfbevent->type == DWET_KEYUP ?
-                             GDK_KEY_RELEASE : GDK_KEY_PRESS);
-        GdkWindow *event_win =
-          gdk_directfb_keyboard_event_window (gdk_directfb_window_find_focus (),
-                                              type);
-        if (event_win)
-          {
-            event = gdk_directfb_event_make (event_win, type);
-            gdk_directfb_translate_key_event (dfbevent, &event->key);
-          }
-      }
+      if (event_window)
+        {
+          gdk_directfb_translate_key_event (dfbevent, &event->key);
+          return_val = TRUE;
+        }
       break;
 
     case DWET_LEAVE:
-      _gdk_directfb_mouse_x = dfbevent->cx;
-      _gdk_directfb_mouse_y = dfbevent->cy;
-
-      gdk_directfb_window_send_crossing_events (NULL, _gdk_parent_root,
-                                                GDK_CROSSING_NORMAL);
-
-      if (gdk_directfb_apply_focus_opacity)
-        {
-          if (GDK_WINDOW_IS_MAPPED (window))
-            GDK_WINDOW_IMPL_DIRECTFB (private->impl)->window->SetOpacity
-              (GDK_WINDOW_IMPL_DIRECTFB (private->impl)->window,
-               (GDK_WINDOW_IMPL_DIRECTFB (private->impl)->opacity >> 1) +
-               (GDK_WINDOW_IMPL_DIRECTFB (private->impl)->opacity >> 2));
-        }
+      if (gdk_directfb_apply_focus_opacity &&
+          GDK_WINDOW_IS_MAPPED (factory.window))
+        factory.impl->window->SetOpacity (factory.impl->window,
+                                          factory.impl->opacity / 2 +
+                                          factory.impl->opacity / 4);
       break;
 
     case DWET_ENTER:
-      {
-        GdkWindow *child;
-
-        _gdk_directfb_mouse_x = dfbevent->cx;
-        _gdk_directfb_mouse_y = dfbevent->cy;
-
-        child = gdk_directfb_child_at (window, &dfbevent->x, &dfbevent->y);
-
-        /* this makes sure pointer is set correctly when it previously left
-         * a window being not standard shaped
-         */
-        gdk_window_set_cursor (window, NULL);
-        gdk_directfb_window_send_crossing_events (NULL, child,
-                                                  GDK_CROSSING_NORMAL);
-
-        if (gdk_directfb_apply_focus_opacity)
-          {
-            GDK_WINDOW_IMPL_DIRECTFB (private->impl)->window->SetOpacity
-              (GDK_WINDOW_IMPL_DIRECTFB (private->impl)->window,
-               GDK_WINDOW_IMPL_DIRECTFB (private->impl)->opacity);
-          }
-      }
+      if (gdk_directfb_apply_focus_opacity &&
+          GDK_WINDOW_IS_MAPPED (factory.window))
+        factory.impl->window->SetOpacity (factory.impl->window,
+                                          factory.impl->opacity);
       break;
 
     case DWET_CLOSE:
-      {
- 
-        GdkWindow *event_win;
-
-        event_win = gdk_directfb_other_event_window (window, GDK_DELETE);
-
-        if (event_win)
-          event = gdk_directfb_event_make (event_win, GDK_DELETE);
-      }
+      return_val = TRUE;
       break;
 
     case DWET_DESTROYED:
-      {
-        GdkWindow *event_win;
-
-        event_win = gdk_directfb_other_event_window (window, GDK_DESTROY);
-
-        if (event_win)
-          event = gdk_directfb_event_make (event_win, GDK_DESTROY);
-
-	gdk_window_destroy_notify (window);
-      }
+      gdk_window_destroy_notify (factory.window);
+      return_val = TRUE;
       break;
 
     case DWET_WHEEL:
-      {
-        GdkWindow *event_win;
-
-        _gdk_directfb_mouse_x = dfbevent->cx;
-        _gdk_directfb_mouse_y = dfbevent->cy;
-
-        if (_gdk_directfb_pointer_grab_window)
-          {
-            GdkDrawableImplDirectFB *impl;
-
-            event_win = _gdk_directfb_pointer_grab_window;
-            impl =
-              GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (event_win)->impl);
-
-            dfbevent->x = dfbevent->cx - impl->abs_x;
-            dfbevent->y = dfbevent->cy - impl->abs_y;
-          }
-        else
-          {
-            event_win = gdk_directfb_child_at (window,
-                                               &dfbevent->x, &dfbevent->y);
-          }
-
-        if (event_win)
-          {
-            event = gdk_directfb_event_make (event_win, GDK_SCROLL);
+      if (event_window)
+        {
+          event->scroll.direction = (dfbevent->step < 0 ?
+                                     GDK_SCROLL_DOWN : GDK_SCROLL_UP);
 
-            event->scroll.direction = (dfbevent->step < 0 ?
-                                       GDK_SCROLL_DOWN : GDK_SCROLL_UP);
+          event->scroll.x_root    = _gdk_directfb_mouse_x;
+          event->scroll.y_root    = _gdk_directfb_mouse_y;
+          event->scroll.x         = factory.win_x;
+          event->scroll.y         = factory.win_y;
+          event->scroll.state     = _gdk_directfb_modifiers;
+          event->scroll.device    = display->core_pointer;
 
-            event->scroll.x_root = _gdk_directfb_mouse_x;
-            event->scroll.y_root = _gdk_directfb_mouse_y;
-            event->scroll.x      = dfbevent->x;
-            event->scroll.y      = dfbevent->y;
-            event->scroll.state  = _gdk_directfb_modifiers;
-            event->scroll.device = display->core_pointer;
-          }
-      }
+          return_val = TRUE;
+        }
       break;
 
     default:
       g_message ("unhandled DirectFB windowing event 0x%08x", dfbevent->type);
     }
 
-  g_object_unref (G_OBJECT (window));
+done:
+  if (return_val)
+    {
+      if (event->any.window)
+        g_object_ref (event->any.window);
 
-  return event;
+      if (((event->any.type == GDK_ENTER_NOTIFY) ||
+           (event->any.type == GDK_LEAVE_NOTIFY)) &&
+          (event->crossing.subwindow != NULL))
+        g_object_ref (event->crossing.subwindow);
+    }
+  else
+    {
+      /* Mark this event as having no resources to be freed. */
+      event->any.window = NULL;
+      event->any.type   = GDK_NOTHING;
+    }
+
+  if (event_window)
+    g_object_unref (event_window);
+
+  return return_val;
 }
 
 gboolean
@@ -795,13 +1715,18 @@
                                        GdkFilterFunc func,
                                        gpointer      data)
 {
-  /* XXX: display should be used */
-  GdkClientFilter *filter = g_new (GdkClientFilter, 1);
+  GdkClientFilter *filter;
+
+  g_return_if_fail (GDK_IS_DISPLAY (display));
 
-  filter->type = message_type;
+  filter = g_new (GdkClientFilter, 1);
+
+  filter->type     = message_type;
   filter->function = func;
-  filter->data = data;
-  client_filters = g_list_append (client_filters, filter);
+  filter->data     = data;
+
+  GDK_DISPLAY_DFB (display)->client_filters =
+    g_list_append (GDK_DISPLAY_DFB (display)->client_filters, filter);
 }
 
 
@@ -816,42 +1741,75 @@
 
 void
 gdk_screen_broadcast_client_message (GdkScreen *screen,
-				     GdkEvent  *sev)
+                                     GdkEvent  *event)
 {
-  GdkWindow *root_window;
+  GdkWindow       *root_window;
+  GdkDisplay      *display;
   GdkWindowObject *private;
-  GList *top_level = NULL;
+  GList           *top_level = NULL;
 
   g_return_if_fail (GDK_IS_SCREEN (screen));
-  g_return_if_fail(sev != NULL);
+  g_return_if_fail (event != NULL);
 
   root_window = gdk_screen_get_root_window (screen);
 
-  g_return_if_fail(GDK_IS_WINDOW(root_window));
+  g_return_if_fail (GDK_IS_WINDOW (root_window));
+
+  display = gdk_drawable_get_display (GDK_DRAWABLE (root_window));
 
   private = GDK_WINDOW_OBJECT (root_window);
 
   for (top_level = private->children; top_level; top_level = top_level->next)
     {
-      gdk_event_send_client_message_for_display (gdk_drawable_get_display(GDK_DRAWABLE(root_window)),
-                                                sev,
-                                                (guint32)(GDK_WINDOW_DFB_ID(GDK_WINDOW(top_level->data))));
+      GdkNativeWindow winid = GDK_WINDOW_DFB_ID (GDK_WINDOW (top_level->data));
+
+      gdk_event_send_client_message_for_display (display, event, winid);
    }
 }
 
+/* Update mouse window */
+static void
+gdk_directfb_events_update_mouse_window (GdkWindow *window)
+{
+  if (window == _gdk_directfb_mouse_window)
+    return;
+
+  if (window)
+    g_object_ref (window);
+  if (_gdk_directfb_mouse_window)
+    g_object_unref (_gdk_directfb_mouse_window);
 
-/**
- * gdk_net_wm_supports:
- * @property: a property atom.
- *
- * This function is specific to the X11 backend of GDK, and indicates
- * whether the window manager for the default screen supports a certain
- * hint from the Extended Window Manager Hints Specification. See
- * gdk_x11_screen_supports_net_wm_hint() for complete details.
- *
- * Return value: %TRUE if the window manager supports @property
- **/
+  _gdk_directfb_mouse_window = window;
+}
 
+/* Update current cursor */
+void
+gdk_directfb_events_update_cursor (GdkWindow *window)
+{
+  static GdkCursorDirectFB *last_cursor = NULL;
+
+  GdkWindowObject       *priv = GDK_WINDOW_OBJECT (window);
+  GdkWindowImplDirectFB *impl = GDK_WINDOW_IMPL_DIRECTFB (priv->impl);
+  GdkCursorDirectFB     *cursor;
+
+  if (_gdk_directfb_pointer_grab_cursor)
+    cursor = (GdkCursorDirectFB *) _gdk_directfb_pointer_grab_cursor;
+  else
+    cursor = (GdkCursorDirectFB *) impl->cursor;
+
+  if (cursor != last_cursor)
+    {
+      window = gdk_directfb_window_find_toplevel (window);
+      priv   = GDK_WINDOW_OBJECT (window);
+      impl   = GDK_WINDOW_IMPL_DIRECTFB (priv->impl);
+
+      if (impl->window)
+        impl->window->SetCursorShape (impl->window,
+                                      cursor->shape,
+                                      cursor->hot_x, cursor->hot_y);
+      last_cursor = cursor;
+    }
+}
 
 gboolean
 gdk_net_wm_supports (GdkAtom property)
--- gtk+-2.12.12.orig/gdk/directfb/gdkfont-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkfont-directfb.c
@@ -30,31 +30,17 @@
  *            Sven Neumann <sven@convergence.de>
  */
 
-#undef GDK_DISABLE_DEPRECATED
+#include "config.h"
 
-#include <config.h>
-#include "gdk.h"
-
-#include <string.h>
-
-#include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
-
-#include "gdkinternals.h"
-
-#include "gdkfont.h"
 #include "gdkalias.h"
 
-
-typedef struct _GdkFontDirectFB  GdkFontDirectFB;
-
-struct _GdkFontDirectFB
+typedef struct
 {
-  GdkFontPrivate    base;
-  gint              size;
-  IDirectFBFont    *dfbfont;
-};
-
+  GdkFontPrivate  base;
+  gint            size;
+  IDirectFBFont  *dfbfont;
+} GdkFontDirectFB;
 
 static GdkFont *
 gdk_directfb_bogus_font (gint height)
@@ -63,18 +49,21 @@
   GdkFontDirectFB *private;
 
   private = g_new0 (GdkFontDirectFB, 1);
-  font = (GdkFont *)private;
+  font = (GdkFont *) private;
+
+  font->type    = GDK_FONT_FONT;
+  font->ascent  = height * 3 / 4;
+  font->descent = height / 4;
 
-  font->type = GDK_FONT_FONT;
-  font->ascent = height*3/4;
-  font->descent = height/4;
-  private->size = height;
+  private->size           = height;
   private->base.ref_count = 1;
+
   return font;
 }
 
 GdkFont*
-gdk_font_from_description_for_display (GdkDisplay * display,PangoFontDescription *font_desc)
+gdk_font_from_description_for_display (GdkDisplay           *display,
+                                       PangoFontDescription *font_desc)
 {
   gint size;
 
@@ -85,21 +74,22 @@
   return gdk_directfb_bogus_font (PANGO_PIXELS (size));
 }
 
-/* ********************* */
-
-GdkFont*
+GdkFont *
 gdk_fontset_load (const gchar *fontset_name)
 {
   return gdk_directfb_bogus_font (10);
 }
 
 GdkFont *
-gdk_fontset_load_for_display (GdkDisplay *display,const gchar *font_name) {
+gdk_fontset_load_for_display (GdkDisplay  *display,
+                              const gchar *font_name)
+{
   return gdk_directfb_bogus_font (10);
 }
 
 GdkFont *
-gdk_font_load_for_display (GdkDisplay *display,const gchar *font_name)
+gdk_font_load_for_display (GdkDisplay  *display,
+                           const gchar *font_name)
 {
   return gdk_directfb_bogus_font (10);
 }
@@ -114,7 +104,7 @@
     case GDK_FONT_FONTSET:
       break;
     default:
-      g_error ("unknown font type.");
+      g_error ("unknown font type");
       break;
     }
 
@@ -125,17 +115,14 @@
 _gdk_font_strlen (GdkFont     *font,
                   const gchar *str)
 {
-  GdkFontDirectFB *font_private;
   gint length = 0;
 
   g_return_val_if_fail (font != NULL, -1);
   g_return_val_if_fail (str != NULL, -1);
 
-  font_private = (GdkFontDirectFB*) font;
-
   if (font->type == GDK_FONT_FONT)
     {
-      guint16 *string_2b = (guint16 *)str;
+      guint16 *string_2b = (guint16 *) str;
 
       while (*(string_2b++))
         length++;
@@ -145,7 +132,7 @@
       length = strlen (str);
     }
   else
-    g_error("undefined font type\n");
+    g_error ("undefined font type");
 
   return length;
 }
@@ -153,12 +140,8 @@
 gint
 gdk_font_id (const GdkFont *font)
 {
-  const GdkFontDirectFB *font_private;
-
   g_return_val_if_fail (font != NULL, 0);
 
-  font_private = (const GdkFontDirectFB*) font;
-
   if (font->type == GDK_FONT_FONT)
     {
       return -1;
@@ -173,29 +156,23 @@
 gdk_font_equal (const GdkFont *fonta,
                 const GdkFont *fontb)
 {
-  const GdkFontDirectFB *privatea;
-  const GdkFontDirectFB *privateb;
-
   g_return_val_if_fail (fonta != NULL, FALSE);
   g_return_val_if_fail (fontb != NULL, FALSE);
 
-  privatea = (const GdkFontDirectFB*) fonta;
-  privateb = (const GdkFontDirectFB*) fontb;
-
-  if(fonta == fontb)
+  if (fonta == fontb)
     return TRUE;
 
   return FALSE;
 }
 
 gint
-gdk_text_width (GdkFont      *font,
-                const gchar  *text,
-                gint          text_length)
+gdk_text_width (GdkFont     *font,
+                const gchar *text,
+                gint         text_length)
 {
   GdkFontDirectFB *private;
 
-  private = (GdkFontDirectFB*) font;
+  private = (GdkFontDirectFB *) font;
 
   return (text_length * private->size) / 2;
 }
@@ -218,15 +195,15 @@
                   gint        *ascent,
                   gint        *descent)
 {
-  if(ascent)
+  if (ascent)
     *ascent = font->ascent;
-  if(descent)
+  if (descent)
     *descent = font->descent;
-  if(width)
-    *width = gdk_text_width(font, text, text_length);
-  if(lbearing)
+  if (width)
+    *width = gdk_text_width (font, text, text_length);
+  if (lbearing)
     *lbearing = 0;
-  if(rbearing)
+  if (rbearing)
     *rbearing = 0;
 }
 
@@ -245,7 +222,7 @@
 
   realstr = alloca (text_length + 1);
 
-  for(i = 0; i < text_length; i++)
+  for (i = 0; i < text_length; i++)
     realstr[i] = text[i];
 
   realstr[i] = '\0';
@@ -263,14 +240,16 @@
 GdkFont *
 gdk_font_lookup (GdkNativeWindow xid)
 {
-	g_warning(" gdk_font_lookup unimplemented \n");
+  D_UNIMPLEMENTED();
+
   return NULL;
 }
 
-GdkDisplay*
+GdkDisplay *
 gdk_font_get_display (GdkFont* font)
 {
-	g_warning(" gdk_font_get_display unimplemented \n");
+  D_UNIMPLEMENTED();
+
   return NULL;
 }
 
--- gtk+-2.12.12.orig/gdk/directfb/gdkgc-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkgc-directfb.c
@@ -30,21 +30,10 @@
  *            Sven Neumann <sven@convergence.de>
  */
 
-#undef GDK_DISABLE_DEPRECATED
+#include "config.h"
 
-#include <config.h>
-#include "gdk.h"
-
-#include <string.h>
-
-#include "gdkdirectfb.h"
-#include "gdkprivate-directfb.h"
-
-#include "gdkgc.h"
-#include "gdkfont.h"
 #include "gdkpixmap.h"
-#include "gdkregion-generic.h"
-
+#include "gdkprivate-directfb.h"
 #include "gdkalias.h"
 
 static void gdk_directfb_gc_get_values (GdkGC           *gc,
@@ -60,10 +49,8 @@
 static void gdk_gc_directfb_class_init (GdkGCDirectFBClass *klass);
 static void gdk_gc_directfb_finalize   (GObject            *object);
 
-
 static gpointer parent_class = NULL;
 
-
 GType
 gdk_gc_directfb_get_type (void)
 {
@@ -113,8 +100,8 @@
   GdkGC         *gc      = GDK_GC (object);
   GdkGCDirectFB *private = GDK_GC_DIRECTFB (gc);
 
-  if (private->clip_region)
-    gdk_region_destroy (private->clip_region);
+  if (private->clip_region.numRects)
+    temp_region_deinit (&private->clip_region);
   if (private->values.clip_mask)
     g_object_unref (private->values.clip_mask);
   if (private->values.stipple)
@@ -126,10 +113,10 @@
     G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
-GdkGC*
-_gdk_directfb_gc_new (GdkDrawable     *drawable,
-                      GdkGCValues     *values,
-                      GdkGCValuesMask  values_mask)
+GdkGC *
+gdk_directfb_gc_new (GdkDrawable     *drawable,
+                     GdkGCValues     *values,
+                     GdkGCValuesMask  values_mask)
 {
   GdkGC         *gc;
   GdkGCDirectFB *private;
@@ -141,17 +128,6 @@
   _gdk_gc_init (gc, drawable, values, values_mask);
 
   private = GDK_GC_DIRECTFB (gc);
-#if 0
-  private->values.background.pixel = 0;
-  private->values.background.red   =
-  private->values.background.green =
-  private->values.background.blue  = 0;
-
-  private->values.foreground.pixel = 0;
-  private->values.foreground.red   =
-  private->values.foreground.green =
-  private->values.foreground.blue  = 0;
-#endif
 
   private->values.cap_style = GDK_CAP_BUTT;
 
@@ -167,19 +143,6 @@
   *values = GDK_GC_DIRECTFB (gc)->values;
 }
 
-#if 0
-void
-_gdk_windowing_gc_get_foreground (GdkGC    *gc,
-                                  GdkColor *color)
-{
-  GdkGCDirectFB *private;
-  private = GDK_GC_DIRECTFB (gc);
-  *color =private->values.foreground;
-
-
-}
-#endif
-
 static void
 gdk_directfb_gc_set_values (GdkGC           *gc,
                             GdkGCValues     *values,
@@ -262,11 +225,7 @@
       if (oldpm)
         g_object_unref (oldpm);
 
-      if (private->clip_region)
-        {
-          gdk_region_destroy (private->clip_region);
-          private->clip_region = NULL;
-        }
+      temp_region_reset (&private->clip_region);
     }
 
   if (values_mask & GDK_GC_SUBWINDOW)
@@ -289,13 +248,15 @@
 
   if (values_mask & GDK_GC_CLIP_X_ORIGIN)
     {
-      private->values.clip_x_origin = GDK_GC (gc)->clip_x_origin = values->clip_x_origin;
+      private->values.clip_x_origin = GDK_GC (gc)->clip_x_origin
+                                    = values->clip_x_origin;
       private->values_mask |= GDK_GC_CLIP_X_ORIGIN;
     }
 
   if (values_mask & GDK_GC_CLIP_Y_ORIGIN)
     {
-      private->values.clip_y_origin = GDK_GC (gc)->clip_y_origin = values->clip_y_origin;
+      private->values.clip_y_origin = GDK_GC (gc)->clip_y_origin
+                                    = values->clip_y_origin;
       private->values_mask |= GDK_GC_CLIP_Y_ORIGIN;
     }
 
@@ -336,7 +297,7 @@
                             gint8  dash_list[],
                             gint   n)
 {
-  g_warning ("gdk_directfb_gc_set_dashes not implemented");
+  D_UNIMPLEMENTED();
 }
 
 static void
@@ -352,10 +313,9 @@
     }
 }
 
-
 void
 _gdk_windowing_gc_set_clip_region (GdkGC     *gc,
-                        GdkRegion *region)
+                                   GdkRegion *region)
 {
   GdkGCDirectFB *data;
 
@@ -363,20 +323,17 @@
 
   data = GDK_GC_DIRECTFB (gc);
 
-  if (region == data->clip_region)
+  if (region == &data->clip_region)
     return;
 
-  if (data->clip_region)
-    {
-      gdk_region_destroy (data->clip_region);
-      data->clip_region = NULL;
-    }
-
   if (region)
-    data->clip_region = gdk_region_copy (region);
+    temp_region_init_copy (&data->clip_region, region);
+  else
+    temp_region_reset (&data->clip_region);
 
   gc->clip_x_origin = 0;
   gc->clip_y_origin = 0;
+
   data->values.clip_x_origin = 0;
   data->values.clip_y_origin = 0;
 
@@ -385,7 +342,7 @@
 
 void
 _gdk_windowing_gc_copy (GdkGC *dst_gc,
-             GdkGC *src_gc)
+                        GdkGC *src_gc)
 {
   GdkGCDirectFB *dst_private;
 
@@ -394,8 +351,7 @@
 
   dst_private = GDK_GC_DIRECTFB (dst_gc);
 
-  if (dst_private->clip_region)
-    gdk_region_destroy(dst_private->clip_region);
+  temp_region_reset (&dst_private->clip_region);
 
   if (dst_private->values_mask & GDK_GC_FONT)
     gdk_font_unref (dst_private->values.font);
@@ -407,6 +363,7 @@
     g_object_unref (dst_private->values.clip_mask);
 
   *dst_gc = *src_gc;
+
   if (dst_private->values_mask & GDK_GC_FONT)
     gdk_font_ref (dst_private->values.font);
   if (dst_private->values_mask & GDK_GC_TILE)
@@ -415,26 +372,12 @@
     g_object_ref (dst_private->values.stipple);
   if (dst_private->values_mask & GDK_GC_CLIP_MASK)
     g_object_ref (dst_private->values.clip_mask);
-  if (dst_private->clip_region)
-    dst_private->clip_region = gdk_region_copy (dst_private->clip_region);
 }
 
-/**
- * gdk_gc_get_screen:
- * @gc: a #GdkGC.
- *
- * Gets the #GdkScreen for which @gc was created
- *
- * Returns: the #GdkScreen for @gc.
- *
- * Since: 2.2
- */
-GdkScreen *  
+GdkScreen *
 gdk_gc_get_screen (GdkGC *gc)
 {
   g_return_val_if_fail (GDK_IS_GC_DIRECTFB (gc), NULL);
-  
+
   return _gdk_screen;
 }
-#define __GDK_GC_X11_C__
-#include "gdkaliasdef.c"
--- gtk+-2.12.12.orig/gdk/directfb/gdkgeometry-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkgeometry-directfb.c
@@ -31,14 +31,13 @@
  */
 
 #include "config.h"
-#include "gdk.h"        /* For gdk_rectangle_intersect */
 
+#include "gdk.h"
 #include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
-
-#include "gdkinternals.h"
 #include "gdkalias.h"
 
+D_DEBUG_DOMAIN( GDKDFB_Scroll, "GDKDFB/Scroll", "GDK DirectFB Scrolling" );
 
 void
 _gdk_windowing_window_get_offsets (GdkWindow *window,
@@ -58,16 +57,6 @@
   return FALSE;
 }
 
-/**
- * gdk_window_scroll:
- * @window: a #GdkWindow
- * @dx: Amount to scroll in the X direction
- * @dy: Amount to scroll in the Y direction
- *
- * Scroll the contents of its window, both pixels and children, by
- * the given amount. Portions of the window that the scroll operation
- * brings in from offscreen areas are invalidated.
- **/
 void
 gdk_window_scroll (GdkWindow *window,
                    gint       dx,
@@ -78,6 +67,8 @@
   GdkRegion               *invalidate_region = NULL;
   GList                   *list;
 
+  D_DEBUG_AT( GDKDFB_Scroll, "%s( %p, %d, %d )\n", __FUNCTION__, window, dx, dy );
+
   g_return_if_fail (GDK_IS_WINDOW (window));
 
   if (GDK_WINDOW_DESTROYED (window))
@@ -116,10 +107,13 @@
                                    rect.x + rect.width  - 1,
                                    rect.y + rect.height - 1 };
 
+              impl->surface->SetBlittingFlags (impl->surface, DSBLIT_NOFX);
               impl->surface->SetClip (impl->surface, &update);
               impl->surface->Blit (impl->surface, impl->surface, NULL, dx, dy);
-              impl->surface->SetClip (impl->surface, NULL);
-              impl->surface->Flip(impl->surface,&update,0);
+
+              D_DEBUG_AT( GDKDFB_Scroll, "  -> flip           " DFB_RECT_FORMAT "\n", DFB_RECTANGLE_VALS_FROM_REGION (&update) );
+
+              impl->surface->Flip (impl->surface,&update, DSFLIP_NONE);
             }
         }
     }
@@ -129,14 +123,14 @@
       GdkWindowObject         *obj      = GDK_WINDOW_OBJECT (list->data);
       GdkDrawableImplDirectFB *obj_impl = GDK_DRAWABLE_IMPL_DIRECTFB (obj->impl);
 
-      _gdk_directfb_move_resize_child (list->data,
-                                       obj->x + dx,
-                                       obj->y + dy,
-                                       obj_impl->width,
-                                       obj_impl->height);
+      gdk_directfb_move_resize_child (list->data,
+                                      obj->x + dx,
+                                      obj->y + dy,
+                                      obj_impl->width,
+                                      obj_impl->height);
     }
 
-  _gdk_directfb_calc_abs (window);
+  gdk_directfb_calc_abs (window);
 
   if (invalidate_region)
     {
@@ -145,49 +139,36 @@
     }
 }
 
-/**
- * gdk_window_move_region:
- * @window: a #GdkWindow
- * @region: The #GdkRegion to move
- * @dx: Amount to move in the X direction
- * @dy: Amount to move in the Y direction
- * 
- * Move the part of @window indicated by @region by @dy pixels in the Y 
- * direction and @dx pixels in the X direction. The portions of @region 
- * that not covered by the new position of @region are invalidated.
- * 
- * Child windows are not moved.
- * 
- * Since: 2.8
- **/
 void
 gdk_window_move_region (GdkWindow *window,
-			GdkRegion *region,
-			gint       dx,
-			gint       dy)
+                        GdkRegion *region,
+                        gint       dx,
+                        gint       dy)
 {
   GdkWindowObject         *private;
   GdkDrawableImplDirectFB *impl;
-  GdkRegion *window_clip;
-  GdkRegion *src_region;
-  GdkRegion *brought_in;
-  GdkRegion *dest_region;
-  GdkRegion *moving_invalid_region;
-  GdkRectangle dest_extents;
-  
+  GdkRegion               *window_clip;
+  GdkRegion               *src_region;
+  GdkRegion               *brought_in;
+  GdkRegion               *dest_region;
+  GdkRegion               *moving_invalid_region = NULL;
+  GdkRectangle             dest_extents;
+
+  D_DEBUG_AT( GDKDFB_Scroll, "%s( %p, %p, %d, %d )\n", __FUNCTION__, window, region, dx, dy );
+
   g_return_if_fail (GDK_IS_WINDOW (window));
   g_return_if_fail (region != NULL);
-  
+
   if (GDK_WINDOW_DESTROYED (window))
     return;
-  
+
   private = GDK_WINDOW_OBJECT (window);
-  impl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);  
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
 
   if (dx == 0 && dy == 0)
     return;
 
-  GdkRectangle  clip_rect = {  0,  0, impl->width, impl->height };
+  GdkRectangle clip_rect = { 0,  0, impl->width, impl->height };
   window_clip = gdk_region_rectangle (&clip_rect);
 
   /* compute source regions */
@@ -207,21 +188,20 @@
   gdk_region_destroy (window_clip);
 
   /* calculating moving part of current invalid area */
-  moving_invalid_region = NULL;
   if (private->update_area)
     {
       moving_invalid_region = gdk_region_copy (private->update_area);
       gdk_region_intersect (moving_invalid_region, src_region);
       gdk_region_offset (moving_invalid_region, dx, dy);
     }
-  
+
   /* invalidate all of the src region */
   gdk_window_invalidate_region (window, src_region, FALSE);
 
   /* un-invalidate destination region */
   if (private->update_area)
     gdk_region_subtract (private->update_area, dest_region);
-  
+
   /* invalidate moving parts of existing update area */
   if (moving_invalid_region)
     {
@@ -234,22 +214,26 @@
   gdk_region_destroy (brought_in);
 
   /* Actually do the moving */
-	if (impl->surface)
-	{
-    	DFBRectangle source = { dest_extents.x - dx, 
-					    dest_extents.y - dy,
-                             dest_extents.width,
-                             dest_extents.height};
-    	DFBRegion destination = { dest_extents.x, 
-						 dest_extents.y,
-                             	 dest_extents.x+dest_extents.width-1,
-                             	 dest_extents.y+dest_extents.height-1};
-
-              impl->surface->SetClip (impl->surface, &destination);
-              impl->surface->Blit (impl->surface, impl->surface,&source,dx,dy);
-              impl->surface->SetClip (impl->surface, NULL);
-              impl->surface->Flip(impl->surface,&destination,0);
-	}
+  if (impl->surface)
+    {
+      DFBRectangle source   = { dest_extents.x - dx,
+                                dest_extents.y - dy,
+                                dest_extents.width,
+                                dest_extents.height };
+      DFBRegion destination = { dest_extents.x,
+                                dest_extents.y,
+                                dest_extents.x + dest_extents.width  - 1,
+                                dest_extents.y + dest_extents.height - 1 };
+
+      impl->surface->SetBlittingFlags (impl->surface, DSBLIT_NOFX);
+      impl->surface->SetClip (impl->surface, &destination);
+      impl->surface->Blit (impl->surface, impl->surface,&source, dx, dy);
+
+      D_DEBUG_AT( GDKDFB_Scroll, "  -> flip           " DFB_RECT_FORMAT "\n", DFB_RECTANGLE_VALS_FROM_REGION (&destination) );
+
+      impl->surface->Flip (impl->surface, &destination, DSFLIP_NONE);
+  }
+
   gdk_region_destroy (src_region);
   gdk_region_destroy (dest_region);
 }
--- gtk+-2.12.12.orig/gdk/directfb/gdkglobals-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkglobals-directfb.c
@@ -30,33 +30,52 @@
  *            Sven Neumann <sven@convergence.de>
  */
 
-#include <config.h>
-#include "gdk.h"
+#include "config.h"
 
-#include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
 
-#include "gdkalias.h"
+/* Display object */
+GdkDisplay          *_gdk_display                             = NULL;
+GdkDisplayDFB       *_gdk_display_dfb                         = NULL;
 
+/* Screen object */
+GdkScreen           *_gdk_screen                              = NULL;
 
-GdkDisplayDFB *_gdk_display = NULL;
-GdkScreen          * _gdk_screen                              = NULL;
-
+/* GdkDirectFB options */
 gboolean              gdk_directfb_apply_focus_opacity        = FALSE;
 gboolean              gdk_directfb_enable_color_keying        = FALSE;
 DFBColor              gdk_directfb_bg_color                   = { 0, 0, 0, 0 };
 DFBColor              gdk_directfb_bg_color_key               = { 0, 0, 0, 0 };
-gboolean              gdk_directfb_monochrome_fonts           = FALSE;
 
-GdkWindow          * _gdk_directfb_pointer_grab_window        = NULL;
-GdkWindow          * _gdk_directfb_keyboard_grab_window       = NULL;
-GdkWindow          * _gdk_directfb_pointer_grab_confine       = NULL;
+/* Root window */
+GdkWindow           *_gdk_parent_root                         = NULL;
+
+/* Entered window */
+GdkWindow           *_gdk_directfb_mouse_window               = NULL;
+
+/* Focused window */
+GdkWindow           *_gdk_directfb_keyboard_window            = NULL;
+
+/* Pointer grabs */
+gboolean             _gdk_directfb_pointer_implicit_grab      = FALSE;
+GdkWindow           *_gdk_directfb_pointer_grab_window        = NULL;
+GdkWindow           *_gdk_directfb_pointer_grab_confine       = NULL;
 gboolean             _gdk_directfb_pointer_grab_owner_events  = FALSE;
-gboolean             _gdk_directfb_keyboard_grab_owner_events = FALSE;
 GdkEventMask         _gdk_directfb_pointer_grab_events        = 0;
-GdkEventMask         _gdk_directfb_keyboard_grab_events       = 0;
-GdkCursor          * _gdk_directfb_pointer_grab_cursor        = NULL;
+GdkCursor           *_gdk_directfb_pointer_grab_cursor        = NULL;
+
+/* Keyboard grabs */
+GdkWindow           *_gdk_directfb_keyboard_grab_window       = NULL;
+gboolean             _gdk_directfb_keyboard_grab_owner_events = FALSE;
 
+/* Properties */
 GdkAtom              _gdk_selection_property                  = 0;
 
-#include "gdkaliasdef.c"
+/* Input Device List */
+GdkDevice           *_gdk_core_pointer                        = NULL;
+GList               *_gdk_input_devices                       = NULL;
+
+/* Input Device State */
+int                  _gdk_directfb_mouse_x                    = 0;
+int                  _gdk_directfb_mouse_y                    = 0;
+GdkModifierType      _gdk_directfb_modifiers                  = 0;
--- gtk+-2.12.12.orig/gdk/directfb/gdkim-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkim-directfb.c
@@ -32,24 +32,10 @@
 
 #include "config.h"
 
-#include <string.h>
 #include <locale.h>
 
 #include "gdkdirectfb.h"
 
-/*
- *--------------------------------------------------------------
- * gdk_set_locale
- *
- * Arguments:
- *
- * Results:
- *
- * Side effects:
- *
- *--------------------------------------------------------------
- */
-
 gchar*
 gdk_set_locale (void)
 {
@@ -58,22 +44,13 @@
 
   return setlocale (LC_ALL, NULL);
 }
-/*
- * gdk_wcstombs
- *
- * Returns a multi-byte string converted from the specified array
- * of wide characters. The string is newly allocated. The array of
- * wide characters must be null-terminated. If the conversion is
- * failed, it returns NULL.
- *
- * On Win32, we always use UTF-8.
- */
+
 gchar *
 gdk_wcstombs (const GdkWChar *src)
 {
-  gint len;
+  gint           len;
   const GdkWChar *wcp;
-  guchar *mbstr, *bp;
+  guchar         *mbstr, *bp;
 
   wcp = src;
   len = 0;
@@ -135,7 +112,6 @@
           len = 6;
         }
 
-      /* Woo-hoo! */
       switch (len)
         {
         case 6: bp[5] = (c & 0x3f) | 0x80; c >>= 6; /* Fall through */
@@ -151,35 +127,19 @@
 
   *bp = 0;
 
-  return mbstr;
+  return (gchar *) mbstr;
 }
 
-
-/*
- * gdk_mbstowcs
- *
- * Converts the specified string into GDK wide characters, and,
- * returns the number of wide characters written. The string 'src'
- * must be null-terminated. If the conversion is failed, it returns
- * -1.
- *
- * On Win32, the string is assumed to be in UTF-8.  Also note that
- * GdkWChar is 32 bits, while wchar_t, and the wide characters the
- * Windows API uses, are 16 bits!
- */
-
-/* First a helper function for not zero-terminated strings */
 gint
-gdk_nmbstowcs (GdkWChar    *dest,
-               const gchar *src,
-               gint         src_len,
-               gint         dest_max)
+gdk_mbstowcs (GdkWChar    *dest,
+              const gchar *src,
+              gint         dest_max)
 {
   guchar *cp, *end;
   gint n;
 
   cp = (guchar *) src;
-  end = cp + src_len;
+  end = cp + strlen (src);
   n = 0;
   while (cp != end && dest != dest + dest_max)
     {
@@ -239,79 +199,6 @@
       n++;
     }
 
-  if (cp != end)
-    return -1;
-
-  return n;
-}
-
-gint
-gdk_mbstowcs (GdkWChar    *dest,
-              const gchar *src,
-              gint         dest_max)
-{
-  return gdk_nmbstowcs (dest, src, strlen (src), dest_max);
-}
-
-
-/* A version that converts to wchar_t wide chars */
-
-gint
-gdk_nmbstowchar_ts (wchar_t     *dest,
-                    const gchar *src,
-                    gint         src_len,
-                    gint         dest_max)
-{
-  wchar_t *wcp;
-  guchar *cp, *end;
-  gint n;
-
-  wcp = dest;
-  cp = (guchar *) src;
-  end = cp + src_len;
-  n = 0;
-  while (cp != end && wcp != dest + dest_max)
-    {
-      gint i, mask = 0, len;
-      guchar c = *cp;
-
-      if (c < 0x80)
-        {
-          len = 1;
-          mask = 0x7f;
-        }
-      else if ((c & 0xe0) == 0xc0)
-        {
-          len = 2;
-          mask = 0x1f;
-        }
-      else if ((c & 0xf0) == 0xe0)
-        {
-          len = 3;
-          mask = 0x0f;
-        }
-      else /* Other lengths are not possible with 16-bit wchar_t! */
-        return -1;
-
-      if (cp + len > end)
-        return -1;
-
-      *wcp = (cp[0] & mask);
-      for (i = 1; i < len; i++)
-        {
-          if ((cp[i] & 0xc0) != 0x80)
-            return -1;
-          *wcp <<= 6;
-          *wcp |= (cp[i] & 0x3f);
-        }
-      if (*wcp == 0xFFFF)
-        return -1;
-
-      cp += len;
-      wcp++;
-      n++;
-    }
-
   if (cp != end)
     return -1;
 
--- gtk+-2.12.12.orig/gdk/directfb/gdkimage-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkimage-directfb.c
@@ -30,19 +30,12 @@
  *            Sven Neumann <sven@convergence.de>
  */
 
-#include <config.h>
-#include "gdk.h"
-
+#include "config.h"
 
 #include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
-
-#include "gdkinternals.h"
-
-#include "gdkimage.h"
 #include "gdkalias.h"
 
-
 static GList    *image_list   = NULL;
 static gpointer  parent_class = NULL;
 
@@ -83,7 +76,7 @@
 gdk_image_init (GdkImage *image)
 {
   image->windowing_data = g_new0 (GdkImageDirectFB, 1);
-  image->mem = NULL;
+  image->mem            = NULL;
 
   image_list = g_list_prepend (image_list, image);
 }
@@ -116,8 +109,6 @@
     G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
-
-/* this function is called from the atexit handler! */
 void
 _gdk_image_exit (void)
 {
@@ -137,30 +128,23 @@
                       gint       w,
                       gint       h)
 {
-  GdkImage         *image;
-  GdkImageDirectFB *private;
+  GdkImage *image;
 
   image = g_object_new (gdk_image_get_type (), NULL);
-  private = image->windowing_data;
-
-  image->type   = GDK_IMAGE_SHARED;
-  image->visual = visual;
-  image->width  = w;
-  image->height = h;
-  image->depth  = 1;
 
-  GDK_NOTE (MISC, g_print ("gdk_image_new_bitmap: %dx%d\n", w, h));
-
-  g_message ("not fully implemented %s", G_STRLOC);
-
-  image->bpl = (w + 7) / 8;
-  image->mem = g_malloc (image->bpl * h);
+  image->type       = GDK_IMAGE_SHARED;
+  image->visual     = visual;
+  image->width      = w;
+  image->height     = h;
+  image->depth      = 1;
+  image->bpl        = (w + 7) / 8;
+  image->mem        = g_malloc (image->bpl * h);
 #if G_BYTE_ORDER == G_BIG_ENDIAN
   image->byte_order = GDK_MSB_FIRST;
 #else
   image->byte_order = GDK_LSB_FIRST;
 #endif
-  image->bpp = 1;
+  image->bpp        = 1;
 
   return image;
 }
@@ -209,59 +193,65 @@
       format = DSPF_ARGB;
       break;
     default:
-      g_message ("unimplemented %s for depth %d", G_STRLOC, depth);
+      g_message ("unsupported depth %d", depth);
       return NULL;
     }
 
-  surface = gdk_display_dfb_create_surface(_gdk_display,format,width,height);
+  surface = gdk_display_dfb_create_surface (_gdk_display_dfb,format,width,height);
   if (!surface)
     {
       return NULL;
     }
-  surface->GetPixelFormat( surface, &format );
+
+  surface->GetPixelFormat (surface, &format);
 
   image = g_object_new (gdk_image_get_type (), NULL);
   private = image->windowing_data;
 
   private->surface = surface;
 
-  surface->Lock( surface, DSLF_WRITE, &image->mem, &pitch );
+  ret = surface->Lock (surface, DSLF_WRITE, &image->mem, &pitch);
+  if (ret)
+    {
+      DirectFBError ("_gdk_image_new_for_depth: Lock() failed", ret );
+      gdk_image_unref (image);
+      return NULL;
+    }
 
   image->type           = type;
   image->visual         = visual;
 #if G_BYTE_ORDER == G_BIG_ENDIAN
-  image->byte_order		= GDK_MSB_FIRST;
+  image->byte_order     = GDK_MSB_FIRST;
 #else
-  image->byte_order 	= GDK_LSB_FIRST;
+  image->byte_order     = GDK_LSB_FIRST;
 #endif
   image->width          = width;
   image->height         = height;
   image->depth          = depth;
   image->bpp            = DFB_BYTES_PER_PIXEL (format);
   image->bpl            = pitch;
-  image->bits_per_pixel = DFB_BITS_PER_PIXEL (format);
+  image->bits_per_pixel = GDK_DFB_BITS_PER_PIXEL (format);
 
   image_list = g_list_prepend (image_list, image);
 
   return image;
 }
 
-
 GdkImage*
-_gdk_directfb_copy_to_image (GdkDrawable *drawable,
-                             GdkImage    *image,
-                             gint         src_x,
-                             gint         src_y,
-                             gint         dest_x,
-                             gint         dest_y,
-                             gint         width,
-                             gint         height)
+gdk_directfb_copy_to_image (GdkDrawable *drawable,
+                            GdkImage    *image,
+                            gint         src_x,
+                            gint         src_y,
+                            gint         dest_x,
+                            gint         dest_y,
+                            gint         width,
+                            gint         height)
 {
   GdkDrawableImplDirectFB *impl;
   GdkImageDirectFB        *private;
   int                      pitch;
   DFBRectangle             rect = { src_x, src_y, width, height };
-  IDirectFBDisplayLayer *layer = _gdk_display->layer;
+  IDirectFBDisplayLayer   *layer = _gdk_display_dfb->layer;
 
   g_return_val_if_fail (GDK_IS_DRAWABLE_IMPL_DIRECTFB (drawable), NULL);
   g_return_val_if_fail (image != NULL || (dest_x == 0 && dest_y == 0), NULL);
@@ -272,11 +262,11 @@
     {
       DFBResult ret;
 
-      ret = layer->SetCooperativeLevel (layer, DLSCL_EXCLUSIVE);
+      ret = layer->SetCooperativeLevel (layer, DLSCL_ADMINISTRATIVE);
       if (ret)
         {
-          DirectFBError ("_gdk_directfb_copy_to_image - SetCooperativeLevel",
-                         ret);
+          DirectFBError ("gdk_directfb_copy_to_image: "
+                         "SetCooperativeLevel() failed", ret);
           return NULL;
         }
 
@@ -284,7 +274,8 @@
       if (ret)
         {
           layer->SetCooperativeLevel (layer, DLSCL_SHARED);
-          DirectFBError ("_gdk_directfb_copy_to_image - GetSurface", ret);
+          DirectFBError ("gdk_directfb_copy_to_image: "
+                         "GetSurface() failed", ret);
           return NULL;
         }
     }
@@ -294,16 +285,20 @@
 
   if (!image)
     image =  gdk_image_new (GDK_IMAGE_NORMAL,
-                            gdk_visual_get_system (), width, height);
+                            gdk_drawable_get_visual (drawable), width, height);
 
   private = image->windowing_data;
 
-  private->surface->Unlock( private->surface );
+  private->surface->Unlock (private->surface);
+
+  private->surface->SetBlittingFlags (private->surface, DSBLIT_NOFX);
+  private->surface->SetClip (private->surface, NULL);
+  private->surface->Blit (private->surface, impl->surface,
+                          &rect, dest_x, dest_y);
 
-  private->surface->Blit( private->surface,
-                          impl->surface, &rect, dest_x, dest_y );
+  private->surface->Lock (private->surface, DSLF_READ | DSLF_WRITE,
+                          &image->mem, &pitch);
 
-  private->surface->Lock( private->surface, DSLF_WRITE, &image->mem, &pitch );
   image->bpl = pitch;
 
   if (impl->wrapper == _gdk_parent_root)
@@ -329,7 +324,11 @@
     return 0;
 
   if (image->depth == 1)
-    pixel = (((guchar *) image->mem)[y * image->bpl + (x >> 3)] & (1 << (7 - (x & 0x7)))) != 0;
+    {
+      gint i = y * image->bpl + (x >> 3);
+
+      pixel = (((guchar *) image->mem)[i] & (1 << (7 - (x & 0x7)))) != 0;
+    }
   else
     {
       guchar *pixelp = (guchar *) image->mem + y * image->bpl + x * image->bpp;
@@ -369,10 +368,14 @@
     return;
 
   if (image->depth == 1)
-    if (pixel & 1)
-      ((guchar *) image->mem)[y * image->bpl + (x >> 3)] |= (1 << (7 - (x & 0x7)));
-    else
-      ((guchar *) image->mem)[y * image->bpl + (x >> 3)] &= ~(1 << (7 - (x & 0x7)));
+    {
+      gint i = y * image->bpl + (x >> 3);
+
+      if (pixel & 1)
+        ((guchar *) image->mem)[i] |= (1 << (7 - (x & 0x7)));
+      else
+        ((guchar *) image->mem)[i] &= ~(1 << (7 - (x & 0x7)));
+    }
   else
     {
       guchar *pixelp = (guchar *) image->mem + y * image->bpl + x * image->bpp;
@@ -403,11 +406,8 @@
   if (!private)
     return;
 
-  GDK_NOTE (MISC, g_print ("gdk_directfb_image_destroy: %#x\n",
-                           (guint) private->surface));
-
-  private->surface->Unlock( private->surface );
-  private->surface->Release( private->surface );
+  private->surface->Unlock (private->surface);
+  private->surface->Release (private->surface);
 
   g_free (private);
   image->windowing_data = NULL;
--- gtk+-2.12.12.orig/gdk/directfb/gdkinput-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkinput-directfb.c
@@ -31,37 +31,22 @@
  *            Sven Neumann <sven@convergence.de>
  */
 
-#include <config.h>
-#include "gdk.h"
+#include "config.h"
 
-#include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
 #include "gdkinput-directfb.h"
-
-#include "gdkinput.h"
-#include "gdkkeysyms.h"
 #include "gdkalias.h"
 
-
-static GdkDeviceAxis gdk_input_core_axes[] =
-{
+static GdkDeviceAxis gdk_input_core_axes[] = {
   { GDK_AXIS_X, 0, 0 },
   { GDK_AXIS_Y, 0, 0 }
 };
 
-
-GdkDevice     * _gdk_core_pointer       = NULL;
-GList         * _gdk_input_devices      = NULL;
-gboolean        _gdk_input_ignore_core  = FALSE;
-
-int             _gdk_directfb_mouse_x   = 0;
-int             _gdk_directfb_mouse_y   = 0;
-
-
 void
 _gdk_init_input_core (void)
 {
- GdkDisplay *display = GDK_DISPLAY_OBJECT(_gdk_display);
+  GdkDisplay *display = GDK_DISPLAY_OBJECT (_gdk_display);
+
   _gdk_core_pointer = g_object_new (GDK_TYPE_DEVICE, NULL);
 
   _gdk_core_pointer->name       = "Core Pointer";
@@ -72,7 +57,8 @@
   _gdk_core_pointer->axes       = gdk_input_core_axes;
   _gdk_core_pointer->num_keys   = 0;
   _gdk_core_pointer->keys       = NULL;
-  display->core_pointer         = _gdk_core_pointer;
+
+  display->core_pointer = _gdk_core_pointer;
 }
 
 static void
@@ -115,13 +101,11 @@
   return object_type;
 }
 
-
 void
 _gdk_input_init (void)
 {
   _gdk_init_input_core ();
   _gdk_input_devices = g_list_append (NULL, _gdk_core_pointer);
-  _gdk_input_ignore_core = FALSE;
 }
 
 void
@@ -132,33 +116,21 @@
 
   for (tmp_list = _gdk_input_devices; tmp_list; tmp_list = tmp_list->next)
     {
-      gdkdev = (GdkDevice *)(tmp_list->data);
+      gdkdev = (GdkDevice *) tmp_list->data;
       if (!GDK_IS_CORE (gdkdev))
-	{
-	  gdk_device_set_mode ((GdkDevice *)gdkdev, GDK_MODE_DISABLED);
+        {
+          gdk_device_set_mode ((GdkDevice *) gdkdev, GDK_MODE_DISABLED);
 
-	  g_free (gdkdev->name);
-	  g_free (gdkdev->axes);
-	  g_free (gdkdev->keys);
-	  g_free (gdkdev);
-	}
+          g_free (gdkdev->name);
+          g_free (gdkdev->axes);
+          g_free (gdkdev->keys);
+          g_free (gdkdev);
+        }
     }
 
   g_list_free (_gdk_input_devices);
 }
 
-/**
- * gdk_device_get_axis:
- * @device: a #GdkDevice
- * @axes: pointer to an array of axes
- * @use: the use to look for
- * @value: location to store the found value.
- *
- * Interprets an array of double as axis values for a given device,
- * and locates the value in the array for a given axis use.
- *
- * Return value: %TRUE if the given axis use was found, otherwise %FALSE
- **/
 gboolean
 gdk_device_get_axis (GdkDevice  *device,
                      gdouble    *axes,
@@ -166,6 +138,7 @@
                      gdouble    *value)
 {
   gint i;
+
   g_return_val_if_fail (device != NULL, FALSE);
 
   if (axes == NULL)
@@ -174,9 +147,10 @@
   for (i = 0; i < device->num_axes; i++)
     if (device->axes[i].use == use)
       {
-	if (value)
-	  *value = axes[i];
-	return TRUE;
+        if (value)
+          *value = axes[i];
+
+        return TRUE;
       }
 
   return FALSE;
@@ -196,9 +170,9 @@
 }
 
 void
-gdk_device_set_axis_use (GdkDevice   *device,
-                         guint        index,
-                         GdkAxisUse   use)
+gdk_device_set_axis_use (GdkDevice  *device,
+                         guint       index,
+                         GdkAxisUse  use)
 {
   g_return_if_fail (device != NULL);
   g_return_if_fail (index < device->num_axes);
@@ -228,18 +202,18 @@
 gdk_device_set_mode (GdkDevice    *device,
                      GdkInputMode  mode)
 {
-  g_message ("unimplemented %s", G_STRLOC);
+  D_UNIMPLEMENTED();
 
   return FALSE;
 }
 
 gboolean
-gdk_device_get_history  (GdkDevice      *device,
-                         GdkWindow      *window,
-                         guint32         start,
-                         guint32         stop,
-                         GdkTimeCoord ***events,
-                         gint           *n_events)
+gdk_device_get_history (GdkDevice      *device,
+                        GdkWindow      *window,
+                        guint32         start,
+                        guint32         stop,
+                        GdkTimeCoord ***events,
+                        gint           *n_events)
 {
   g_return_val_if_fail (GDK_IS_WINDOW (window), FALSE);
   g_return_val_if_fail (events != NULL, FALSE);
@@ -255,7 +229,6 @@
     return FALSE;
   else
     return FALSE;
-  //TODODO_gdk_device_get_history (device, window, start, stop, events, n_events);
 }
 
 void
@@ -303,7 +276,7 @@
                                 gint              mask,
                                 GdkExtensionMode  mode)
 {
-  g_message ("unimplemented %s", G_STRLOC);
+  D_UNIMPLEMENTED();
 }
 
 GList *
@@ -312,7 +285,6 @@
   return _gdk_input_devices;
 }
 
-
 GList *
 gdk_display_list_devices (GdkDisplay *dpy)
 {
@@ -324,6 +296,7 @@
                        GdkInputSource  source)
 {
   g_return_if_fail (device != NULL);
+
   device->source = source;
 }
 
--- gtk+-2.12.12.orig/gdk/directfb/gdkinput-directfb.h
+++ gtk+-2.12.12/gdk/directfb/gdkinput-directfb.h
@@ -33,112 +33,20 @@
 #ifndef __GDK_INPUT_DIRECTFB_H__
 #define __GDK_INPUT_DIRECTFB_H__
 
-extern GdkModifierType _gdk_directfb_modifiers;
-extern int _gdk_directfb_mouse_x, _gdk_directfb_mouse_y;
-
-typedef struct _GdkAxisInfo      GdkAxisInfo;
-typedef struct _GdkInputWindow   GdkInputWindow;
-
-/* information about a device axis */
-struct _GdkAxisInfo
-{
-  /* reported x resolution */
-  gint xresolution;
-
-  /* reported x minimum/maximum values */
-  gint xmin_value, xmax_value;
-
-  /* calibrated resolution (for aspect ration) - only relative values
-     between axes used */
-  gint resolution;
-
-  /* calibrated minimum/maximum values */
-  gint min_value, max_value;
-};
-
-#define GDK_INPUT_NUM_EVENTC 6
+#include <directfb.h>
+#include "gdkevents.h"
 
 struct _GdkDeviceClass
 {
   GObjectClass parent_class;
 };
 
-struct _GdkInputWindow
-{
-  /* gdk window */
-  GdkWindow *window;
-
-  /* Extension mode (GDK_EXTENSION_EVENTS_ALL/CURSOR) */
-  GdkExtensionMode mode;
-
-  /* position relative to root window */
-  gint root_x;
-  gint root_y;
-
-  /* rectangles relative to window of windows obscuring this one */
-  GdkRectangle *obscuring;
-  gint num_obscuring;
-
-  /* Is there a pointer grab for this window ? */
-  gint grabbed;
-};
-
-/* Global data */
-
-#define GDK_IS_CORE(d) (((GdkDevice *)(d)) == _gdk_core_pointer)
-
-extern GList *_gdk_input_devices;
-extern GList *_gdk_input_windows;
-
-extern gint   _gdk_input_ignore_core;
-
 /* Function declarations */
 
-/* The following functions are provided by each implementation
- */
-gint             _gdk_input_window_none_event(GdkEvent          *event,
-                                              gchar             *msg);
-void             _gdk_input_configure_event  (GdkEventConfigure *event,
-                                              GdkWindow         *window);
-void             _gdk_input_enter_event      (GdkEventCrossing  *event,
-                                              GdkWindow         *window);
-gint             _gdk_input_other_event      (GdkEvent          *event,
-                                              gchar             *msg,
-                                              GdkWindow         *window);
-
-/* These should be in gdkinternals.h */
-
-GdkInputWindow  * gdk_input_window_find      (GdkWindow         *window);
-
-void              gdk_input_window_destroy   (GdkWindow         *window);
-
-gint             _gdk_input_enable_window    (GdkWindow         *window,
-                                              GdkDevice         *gdkdev);
-gint             _gdk_input_disable_window   (GdkWindow         *window,
-                                              GdkDevice         *gdkdev);
-gint             _gdk_input_grab_pointer     (GdkWindow         *window,
-                                              gint               owner_events,
-                                              GdkEventMask       event_mask,
-                                              GdkWindow         *confine_to,
-                                              guint32            time);
-void             _gdk_input_ungrab_pointer   (guint32            time);
-gboolean         _gdk_device_get_history     (GdkDevice         *device,
-                                              GdkWindow         *window,
-                                              guint32            start,
-                                              guint32            stop,
-                                              GdkTimeCoord    ***events,
-                                              gint              *n_events);
-
-gint             gdk_input_common_init        (gint              include_core);
-gint             gdk_input_common_other_event (GdkEvent         *event,
-                                               gchar            *msg,
-                                               GdkInputWindow   *input_window,
-                                               GdkWindow        *window);
-
-void         _gdk_directfb_keyboard_init      (void);
-void         _gdk_directfb_keyboard_exit      (void);
+void _gdk_directfb_keyboard_init      (void);
+void _gdk_directfb_keyboard_exit      (void);
 
-void         gdk_directfb_translate_key_event (DFBWindowEvent   *dfb_event,
-                                               GdkEventKey      *event);
+void gdk_directfb_translate_key_event (DFBWindowEvent *dfb_event,
+                                       GdkEventKey    *event);
 
 #endif /* __GDK_INPUT_DIRECTFB_H__ */
--- gtk+-2.12.12.orig/gdk/directfb/gdkkeys-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkkeys-directfb.c
@@ -30,29 +30,19 @@
  *            Sven Neumann <sven@convergence.de>
  */
 
-#include <config.h>
-#include "gdk.h"
+#include "config.h"
 
-#include <stdlib.h>
-#include <string.h>
-
-
-#include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
-
 #include "gdkkeysyms.h"
 #include "gdkalias.h"
 
 static struct gdk_key *gdk_keys_by_name = NULL;
 
-GdkModifierType  _gdk_directfb_modifiers = 0;
-
-static guint     *directfb_keymap        = NULL;
-static gint       directfb_min_keycode   = 0;
-static gint       directfb_max_keycode   = 0;
-
+static guint *directfb_keymap      = NULL;
+static gint   directfb_min_keycode = 0;
+static gint   directfb_max_keycode = 0;
 
-/* 
+/*
  *  This array needs to be sorted by key values. It can be generated
  *  from gdkkeysyms.h using a few lines of Perl. This is a bit more
  *  complex as one would expect since GDK defines multiple names for a
@@ -61,12 +51,12 @@
  *
  *      while (<>) {
  *          if (/^\#define GDK\_(\w+) 0x([0-9|a-f|A-F|]+)/) {
- *	        push @{ $names{hex $2} }, $1;
+ *              push @{ $names{hex $2} }, $1;
  *          }
  *      }
  *      foreach $value (sort { $a <=> $b } keys %names) {
  *          for (@{ $names{$value} } ) {
- * 	        next if (/^[R|L]\d+/);
+ *              next if (/^[R|L]\d+/);
  *              print "  { GDK_$_, \"$_\" },\n";
  *          }
  *      }
@@ -1390,7 +1380,6 @@
 
 #define GDK_NUM_KEYS (G_N_ELEMENTS (gdk_keys_by_keyval))
 
-
 static gint
 gdk_keys_keyval_compare (const void *pkey,
                          const void *pbase)
@@ -1452,18 +1441,18 @@
   if (gdk_keys_by_name == NULL)
     {
       gdk_keys_by_name = g_new (struct gdk_key, GDK_NUM_KEYS);
-      
+
       memcpy (gdk_keys_by_name, gdk_keys_by_keyval,
               GDK_NUM_KEYS * sizeof (struct gdk_key));
-      
+
       qsort (gdk_keys_by_name, GDK_NUM_KEYS, sizeof (struct gdk_key),
              gdk_key_compare_by_name);
     }
-  
+
   found = bsearch (keyval_name, gdk_keys_by_name,
                    GDK_NUM_KEYS, sizeof (struct gdk_key),
                    gdk_keys_name_compare);
-  
+
   if (found)
     return found->keyval;
   else
@@ -1472,527 +1461,486 @@
 
 static void
 gdk_directfb_convert_modifiers (DFBInputDeviceModifierMask dfbmod,
-		DFBInputDeviceLockState    dfblock)
+                                DFBInputDeviceLockState    dfblock)
 {
-	if (dfbmod & DIMM_ALT)
-		_gdk_directfb_modifiers |= GDK_MOD1_MASK;
-	else
-		_gdk_directfb_modifiers &= ~GDK_MOD1_MASK;
-
-	if (dfbmod & DIMM_ALTGR)
-		_gdk_directfb_modifiers |= GDK_MOD2_MASK;
-	else
-		_gdk_directfb_modifiers &= ~GDK_MOD2_MASK;
-
-	if (dfbmod & DIMM_CONTROL)
-		_gdk_directfb_modifiers |= GDK_CONTROL_MASK;
-	else
-		_gdk_directfb_modifiers &= ~GDK_CONTROL_MASK;
-
-	if (dfbmod & DIMM_SHIFT)
-		_gdk_directfb_modifiers |= GDK_SHIFT_MASK;
-	else
-		_gdk_directfb_modifiers &= ~GDK_SHIFT_MASK;
-
-	if (dfblock & DILS_CAPS)
-		_gdk_directfb_modifiers |= GDK_LOCK_MASK;
-	else
-		_gdk_directfb_modifiers &= ~GDK_LOCK_MASK;
+  if (dfbmod & DIMM_ALT)
+    _gdk_directfb_modifiers |= GDK_MOD1_MASK;
+  else
+    _gdk_directfb_modifiers &= ~GDK_MOD1_MASK;
+
+  if (dfbmod & DIMM_ALTGR)
+    _gdk_directfb_modifiers |= GDK_MOD2_MASK;
+  else
+    _gdk_directfb_modifiers &= ~GDK_MOD2_MASK;
+
+  if (dfbmod & DIMM_CONTROL)
+    _gdk_directfb_modifiers |= GDK_CONTROL_MASK;
+  else
+    _gdk_directfb_modifiers &= ~GDK_CONTROL_MASK;
+
+  if (dfbmod & DIMM_SHIFT)
+    _gdk_directfb_modifiers |= GDK_SHIFT_MASK;
+  else
+    _gdk_directfb_modifiers &= ~GDK_SHIFT_MASK;
+
+  if (dfblock & DILS_CAPS)
+    _gdk_directfb_modifiers |= GDK_LOCK_MASK;
+  else
+    _gdk_directfb_modifiers &= ~GDK_LOCK_MASK;
 }
 
 static guint
 gdk_directfb_translate_key (DFBInputDeviceKeyIdentifier key_id,
-		DFBInputDeviceKeySymbol     key_symbol)
+                            DFBInputDeviceKeySymbol     key_symbol)
 {
-	guint keyval = GDK_VoidSymbol;
+  guint keyval = GDK_VoidSymbol;
 
-	/* special case numpad */
-	if (key_id >= DIKI_KP_DIV && key_id <= DIKI_KP_9)
-	{
-		switch (key_symbol)
-		{
-			case DIKS_SLASH:         keyval = GDK_KP_Divide;    break;
-			case DIKS_ASTERISK:      keyval = GDK_KP_Multiply;  break;
-			case DIKS_PLUS_SIGN:     keyval = GDK_KP_Add;       break;
-			case DIKS_MINUS_SIGN:    keyval = GDK_KP_Subtract;  break;
-			case DIKS_ENTER:         keyval = GDK_KP_Enter;     break;
-			case DIKS_SPACE:         keyval = GDK_KP_Space;     break;
-			case DIKS_TAB:           keyval = GDK_KP_Tab;       break;
-			case DIKS_EQUALS_SIGN:   keyval = GDK_KP_Equal;     break;
-			case DIKS_COMMA:
-			case DIKS_PERIOD:        keyval = GDK_KP_Decimal;   break;
-			case DIKS_HOME:          keyval = GDK_KP_Home;      break;
-			case DIKS_END:           keyval = GDK_KP_End;       break;
-			case DIKS_PAGE_UP:       keyval = GDK_KP_Page_Up;   break;
-			case DIKS_PAGE_DOWN:     keyval = GDK_KP_Page_Down; break;
-			case DIKS_CURSOR_LEFT:   keyval = GDK_KP_Left;      break;
-			case DIKS_CURSOR_RIGHT:  keyval = GDK_KP_Right;     break;
-			case DIKS_CURSOR_UP:     keyval = GDK_KP_Up;        break;
-			case DIKS_CURSOR_DOWN:   keyval = GDK_KP_Down;      break;
-			case DIKS_BEGIN:         keyval = GDK_KP_Begin;     break;
-
-			case DIKS_0 ... DIKS_9:
-						 keyval = GDK_KP_0 + key_symbol - DIKS_0;
-						 break;
-			case DIKS_F1 ... DIKS_F4:
-						 keyval = GDK_KP_F1 + key_symbol - DIKS_F1;
-						 break;
-
-			default:
-						 break;
-		}
-	}
-	else
-	{
-		switch (DFB_KEY_TYPE (key_symbol))
-		{
-			case DIKT_UNICODE:
-				switch (key_symbol)
-				{
-					case DIKS_NULL:       keyval = GDK_VoidSymbol; break;
-					case DIKS_BACKSPACE:  keyval = GDK_BackSpace;  break;
-					case DIKS_TAB:        keyval = GDK_Tab;        break;
-					case DIKS_RETURN:     keyval = GDK_Return;     break;
-					case DIKS_CANCEL:     keyval = GDK_Cancel;     break;
-					case DIKS_ESCAPE:     keyval = GDK_Escape;     break;
-					case DIKS_SPACE:      keyval = GDK_space;      break;
-					case DIKS_DELETE:     keyval = GDK_Delete;     break;
-
-					default:
-							      keyval = gdk_unicode_to_keyval (key_symbol);
-							      if (keyval & 0x01000000)
-								      keyval = GDK_VoidSymbol;
-				}
-				break;
-
-			case DIKT_SPECIAL:
-				switch (key_symbol)
-				{
-					case DIKS_CURSOR_LEFT:   keyval = GDK_Left;      break;
-					case DIKS_CURSOR_RIGHT:  keyval = GDK_Right;     break;
-					case DIKS_CURSOR_UP:     keyval = GDK_Up;        break;
-					case DIKS_CURSOR_DOWN:   keyval = GDK_Down;      break;
-					case DIKS_INSERT:        keyval = GDK_Insert;    break;
-					case DIKS_HOME:          keyval = GDK_Home;      break;
-					case DIKS_END:           keyval = GDK_End;       break;
-					case DIKS_PAGE_UP:       keyval = GDK_Page_Up;   break;
-					case DIKS_PAGE_DOWN:     keyval = GDK_Page_Down; break;
-					case DIKS_PRINT:         keyval = GDK_Print;     break;
-					case DIKS_PAUSE:         keyval = GDK_Pause;     break;
-					case DIKS_SELECT:        keyval = GDK_Select;    break;
-					case DIKS_CLEAR:         keyval = GDK_Clear;     break;
-					case DIKS_MENU:          keyval = GDK_Menu;      break;
-					case DIKS_HELP:          keyval = GDK_Help;      break;
-					case DIKS_NEXT:          keyval = GDK_Next;      break;
-					case DIKS_BEGIN:         keyval = GDK_Begin;     break;
-					case DIKS_BREAK:         keyval = GDK_Break;     break;
-					default:
-								 break;
-				}
-				break;
-
-			case DIKT_FUNCTION:
-				keyval = GDK_F1 + key_symbol - DIKS_F1;
-				if (keyval > GDK_F35)
-					keyval = GDK_VoidSymbol;
-				break;
-
-			case DIKT_MODIFIER:
-				switch (key_id)
-				{
-					case DIKI_SHIFT_L:    keyval = GDK_Shift_L;     break;
-					case DIKI_SHIFT_R:    keyval = GDK_Shift_R;     break;
-					case DIKI_CONTROL_L:  keyval = GDK_Control_L;   break;
-					case DIKI_CONTROL_R:  keyval = GDK_Control_R;   break;
-					case DIKI_ALT_L:      keyval = GDK_Alt_L;       break;
-					case DIKI_ALT_R:      keyval = GDK_Alt_R;       break;
-					case DIKI_META_L:     keyval = GDK_Meta_L;      break;
-					case DIKI_META_R:     keyval = GDK_Meta_R;      break;
-					case DIKI_SUPER_L:    keyval = GDK_Super_L;     break;
-					case DIKI_SUPER_R:    keyval = GDK_Super_R;     break;
-					case DIKI_HYPER_L:    keyval = GDK_Hyper_L;     break;
-					case DIKI_HYPER_R:    keyval = GDK_Hyper_R;     break;
-					default:
-							      break;
-				}
-				break;
-
-			case DIKT_LOCK:
-				switch (key_symbol)
-				{
-					case DIKS_CAPS_LOCK:    keyval = GDK_Caps_Lock;   break;
-					case DIKS_NUM_LOCK:     keyval = GDK_Num_Lock;    break;
-					case DIKS_SCROLL_LOCK:  keyval = GDK_Scroll_Lock; break;
-					default:
-								break;
-				}
-				break;
-
-			case DIKT_DEAD:
-				switch (key_symbol)
-				{
-					case DIKS_DEAD_ABOVEDOT:     keyval = GDK_dead_abovedot;     break;
-					case DIKS_DEAD_ABOVERING:    keyval = GDK_dead_abovering;    break;
-					case DIKS_DEAD_ACUTE:        keyval = GDK_dead_acute;        break;
-					case DIKS_DEAD_BREVE:        keyval = GDK_dead_breve;        break;
-					case DIKS_DEAD_CARON:        keyval = GDK_dead_caron;        break;
-					case DIKS_DEAD_CEDILLA:      keyval = GDK_dead_cedilla;      break;
-					case DIKS_DEAD_CIRCUMFLEX:   keyval = GDK_dead_circumflex;   break;
-					case DIKS_DEAD_DIAERESIS:    keyval = GDK_dead_diaeresis;    break;
-					case DIKS_DEAD_DOUBLEACUTE:  keyval = GDK_dead_doubleacute;  break;
-					case DIKS_DEAD_GRAVE:        keyval = GDK_dead_grave;        break;
-					case DIKS_DEAD_IOTA:         keyval = GDK_dead_iota;         break;
-					case DIKS_DEAD_MACRON:       keyval = GDK_dead_macron;       break;
-					case DIKS_DEAD_OGONEK:       keyval = GDK_dead_ogonek;       break;
-					case DIKS_DEAD_SEMIVOICED_SOUND:
-								     keyval = GDK_dead_semivoiced_sound;                        break;
-					case DIKS_DEAD_TILDE:        keyval = GDK_dead_tilde;        break;
-					case DIKS_DEAD_VOICED_SOUND: keyval = GDK_dead_voiced_sound; break;
-					default:
-								     break;
-				}
-				break;
-
-			case DIKT_CUSTOM:
-				break;
-		}
-	}
+  /* special case numpad */
+  if (key_id >= DIKI_KP_DIV && key_id <= DIKI_KP_9)
+    {
+      switch (key_symbol)
+        {
+        case DIKS_SLASH:                 keyval = GDK_KP_Divide;         break;
+        case DIKS_ASTERISK:              keyval = GDK_KP_Multiply;       break;
+        case DIKS_PLUS_SIGN:             keyval = GDK_KP_Add;            break;
+        case DIKS_MINUS_SIGN:            keyval = GDK_KP_Subtract;       break;
+        case DIKS_ENTER:                 keyval = GDK_KP_Enter;          break;
+        case DIKS_SPACE:                 keyval = GDK_KP_Space;          break;
+        case DIKS_TAB:                   keyval = GDK_KP_Tab;            break;
+        case DIKS_EQUALS_SIGN:           keyval = GDK_KP_Equal;          break;
+        case DIKS_COMMA:
+        case DIKS_PERIOD:                keyval = GDK_KP_Decimal;        break;
+        case DIKS_HOME:                  keyval = GDK_KP_Home;           break;
+        case DIKS_END:                   keyval = GDK_KP_End;            break;
+        case DIKS_PAGE_UP:               keyval = GDK_KP_Page_Up;        break;
+        case DIKS_PAGE_DOWN:             keyval = GDK_KP_Page_Down;      break;
+        case DIKS_CURSOR_LEFT:           keyval = GDK_KP_Left;           break;
+        case DIKS_CURSOR_RIGHT:          keyval = GDK_KP_Right;          break;
+        case DIKS_CURSOR_UP:             keyval = GDK_KP_Up;             break;
+        case DIKS_CURSOR_DOWN:           keyval = GDK_KP_Down;           break;
+        case DIKS_BEGIN:                 keyval = GDK_KP_Begin;          break;
+
+        case DIKS_0 ... DIKS_9:
+                                         keyval = GDK_KP_0 + key_symbol - DIKS_0;
+                                         break;
+        case DIKS_F1 ... DIKS_F4:
+                                         keyval = GDK_KP_F1 + key_symbol - DIKS_F1;
+                                         break;
+
+        default:
+                                         break;
+      }
+    }
+  else
+    {
+      switch (DFB_KEY_TYPE (key_symbol))
+        {
+        case DIKT_UNICODE:
+          switch (key_symbol)
+            {
+            case DIKS_NULL:              keyval = GDK_VoidSymbol;        break;
+            case DIKS_BACKSPACE:         keyval = GDK_BackSpace;         break;
+            case DIKS_TAB:               keyval = GDK_Tab;               break;
+            case DIKS_RETURN:            keyval = GDK_Return;            break;
+            case DIKS_CANCEL:            keyval = GDK_Cancel;            break;
+            case DIKS_ESCAPE:            keyval = GDK_Escape;            break;
+            case DIKS_SPACE:             keyval = GDK_space;             break;
+            case DIKS_DELETE:            keyval = GDK_Delete;            break;
+
+            default:
+                                         keyval = gdk_unicode_to_keyval (key_symbol);
+                                         if (keyval & 0x01000000)
+                                           keyval = GDK_VoidSymbol;
+            }
+          break;
+
+        case DIKT_SPECIAL:
+          switch (key_symbol)
+            {
+            case DIKS_CURSOR_LEFT:       keyval = GDK_Left;              break;
+            case DIKS_CURSOR_RIGHT:      keyval = GDK_Right;             break;
+            case DIKS_CURSOR_UP:         keyval = GDK_Up;                break;
+            case DIKS_CURSOR_DOWN:       keyval = GDK_Down;              break;
+            case DIKS_INSERT:            keyval = GDK_Insert;            break;
+            case DIKS_HOME:              keyval = GDK_Home;              break;
+            case DIKS_END:               keyval = GDK_End;               break;
+            case DIKS_PAGE_UP:           keyval = GDK_Page_Up;           break;
+            case DIKS_PAGE_DOWN:         keyval = GDK_Page_Down;         break;
+            case DIKS_PRINT:             keyval = GDK_Print;             break;
+            case DIKS_PAUSE:             keyval = GDK_Pause;             break;
+            case DIKS_SELECT:            keyval = GDK_Select;            break;
+            case DIKS_CLEAR:             keyval = GDK_Clear;             break;
+            case DIKS_MENU:              keyval = GDK_Menu;              break;
+            case DIKS_HELP:              keyval = GDK_Help;              break;
+            case DIKS_NEXT:              keyval = GDK_Next;              break;
+            case DIKS_BEGIN:             keyval = GDK_Begin;             break;
+            case DIKS_BREAK:             keyval = GDK_Break;             break;
+            default:
+                                         break;
+            }
+          break;
+
+        case DIKT_FUNCTION:
+          keyval = GDK_F1 + key_symbol - DIKS_F1;
+          if (keyval > GDK_F35)
+            keyval = GDK_VoidSymbol;
+          break;
+
+        case DIKT_MODIFIER:
+          switch (key_id)
+            {
+            case DIKI_SHIFT_L:           keyval = GDK_Shift_L;           break;
+            case DIKI_SHIFT_R:           keyval = GDK_Shift_R;           break;
+            case DIKI_CONTROL_L:         keyval = GDK_Control_L;         break;
+            case DIKI_CONTROL_R:         keyval = GDK_Control_R;         break;
+            case DIKI_ALT_L:             keyval = GDK_Alt_L;             break;
+            case DIKI_ALT_R:             keyval = GDK_Alt_R;             break;
+            case DIKI_META_L:            keyval = GDK_Meta_L;            break;
+            case DIKI_META_R:            keyval = GDK_Meta_R;            break;
+            case DIKI_SUPER_L:           keyval = GDK_Super_L;           break;
+            case DIKI_SUPER_R:           keyval = GDK_Super_R;           break;
+            case DIKI_HYPER_L:           keyval = GDK_Hyper_L;           break;
+            case DIKI_HYPER_R:           keyval = GDK_Hyper_R;           break;
+            default:
+                                         break;
+            }
+          break;
+
+        case DIKT_LOCK:
+          switch (key_symbol)
+            {
+            case DIKS_CAPS_LOCK:         keyval = GDK_Caps_Lock;         break;
+            case DIKS_NUM_LOCK:          keyval = GDK_Num_Lock;          break;
+            case DIKS_SCROLL_LOCK:       keyval = GDK_Scroll_Lock;       break;
+            default:
+                                         break;
+            }
+          break;
+
+        case DIKT_DEAD:
+          switch (key_symbol)
+            {
+            case DIKS_DEAD_ABOVEDOT:     keyval = GDK_dead_abovedot;     break;
+            case DIKS_DEAD_ABOVERING:    keyval = GDK_dead_abovering;    break;
+            case DIKS_DEAD_ACUTE:        keyval = GDK_dead_acute;        break;
+            case DIKS_DEAD_BREVE:        keyval = GDK_dead_breve;        break;
+            case DIKS_DEAD_CARON:        keyval = GDK_dead_caron;        break;
+            case DIKS_DEAD_CEDILLA:      keyval = GDK_dead_cedilla;      break;
+            case DIKS_DEAD_CIRCUMFLEX:   keyval = GDK_dead_circumflex;   break;
+            case DIKS_DEAD_DIAERESIS:    keyval = GDK_dead_diaeresis;    break;
+            case DIKS_DEAD_DOUBLEACUTE:  keyval = GDK_dead_doubleacute;  break;
+            case DIKS_DEAD_GRAVE:        keyval = GDK_dead_grave;        break;
+            case DIKS_DEAD_IOTA:         keyval = GDK_dead_iota;         break;
+            case DIKS_DEAD_MACRON:       keyval = GDK_dead_macron;       break;
+            case DIKS_DEAD_OGONEK:       keyval = GDK_dead_ogonek;       break;
+            case DIKS_DEAD_SEMIVOICED_SOUND:
+                                         keyval = GDK_dead_semivoiced_sound;
+                                         break;
+            case DIKS_DEAD_TILDE:        keyval = GDK_dead_tilde;        break;
+            case DIKS_DEAD_VOICED_SOUND: keyval = GDK_dead_voiced_sound; break;
+            default:
+                                         break;
+            }
+          break;
+
+        case DIKT_CUSTOM:
+          break;
+        }
+    }
 
-	return keyval;
+  return keyval;
 }
 
-	void
+void
 _gdk_directfb_keyboard_init (void)
 {
-	DFBInputDeviceDescription desc;
-	gint i, n, length;
-	IDirectFBInputDevice   *keyboard=_gdk_display->keyboard;
+  DFBInputDeviceDescription  desc;
+  gint                       i, n, length;
+  IDirectFBInputDevice      *keyboard = _gdk_display_dfb->keyboard;
 
-	if (!keyboard)
-		return;
-    if( directfb_keymap )    
-            return;
+  if (!keyboard)
+    return;
+  if (directfb_keymap)
+    return;
 
-	keyboard->GetDescription (keyboard, &desc);
-	_gdk_display->keymap=g_object_new (gdk_keymap_get_type (), NULL);
+  keyboard->GetDescription (keyboard, &desc);
+  _gdk_display_dfb->keymap = g_object_new (gdk_keymap_get_type (), NULL);
 
-	if (desc.min_keycode < 0 || desc.max_keycode < desc.min_keycode)
-		return;
+  if (desc.min_keycode < 0 || desc.max_keycode < desc.min_keycode)
+    return;
 
-	directfb_min_keycode = desc.min_keycode;
-	directfb_max_keycode = desc.max_keycode;
+  directfb_min_keycode = desc.min_keycode;
+  directfb_max_keycode = desc.max_keycode;
 
-	length = directfb_max_keycode - desc.min_keycode + 1;
+  length = directfb_max_keycode - desc.min_keycode + 1;
 
 
-	directfb_keymap = g_new0 (guint, 4 * length);
+  directfb_keymap = g_new0 (guint, 4 * length);
 
-	for (i = 0; i < length; i++)
-	{
-		DFBInputDeviceKeymapEntry  entry;
-
-		if (keyboard->GetKeymapEntry (keyboard,
-					i + desc.min_keycode, &entry) != DFB_OK)
-			continue;
-		for (n = 0; n < 4; n++) {
-			directfb_keymap[i * 4 + n] = 
-				gdk_directfb_translate_key (entry.identifier, entry.symbols[n]);
-		}
-	}
+  for (i = 0; i < length; i++)
+    {
+      DFBInputDeviceKeymapEntry entry;
+      if (keyboard->GetKeymapEntry (keyboard,
+                                    i + desc.min_keycode, &entry) != DFB_OK)
+          continue;
+      for (n = 0; n < 4; n++)
+        {
+          directfb_keymap[i * 4 + n] =
+            gdk_directfb_translate_key (entry.identifier, entry.symbols[n]);
+        }
+    }
 }
 
-	void
+void
 _gdk_directfb_keyboard_exit (void)
 {
-	if (!directfb_keymap)
-		return;
+  if (!directfb_keymap)
+    return;
 
-	g_free (directfb_keymap);
-	g_free(_gdk_display->keymap);
-	_gdk_display->keymap = NULL;
-	directfb_keymap = NULL;
+  g_free (directfb_keymap);
+  directfb_keymap = NULL;
 }
 
 void
 gdk_directfb_translate_key_event (DFBWindowEvent *dfb_event,
-		GdkEventKey    *event)
+                                  GdkEventKey    *event)
 {
-	gint  len;
-	gchar buf[6];
+  gint  len;
+  gchar buf[6];
 
-	g_return_if_fail (dfb_event != NULL);
-	g_return_if_fail (event != NULL);
+  g_return_if_fail (dfb_event != NULL);
+  g_return_if_fail (event != NULL);
 
-	gdk_directfb_convert_modifiers (dfb_event->modifiers, dfb_event->locks);
+  gdk_directfb_convert_modifiers (dfb_event->modifiers, dfb_event->locks);
 
-	event->state            = _gdk_directfb_modifiers;
-	event->group            = (dfb_event->modifiers & DIMM_ALTGR) ? 1 : 0;
-	event->hardware_keycode = dfb_event->key_code;
-	event->keyval           = gdk_directfb_translate_key (dfb_event->key_id,
-			dfb_event->key_symbol);
-	/* If the device driver didn't send a key_code (happens with remote
-	   controls), we try to find a suitable key_code by looking at the
-	   default keymap. */
-	if (dfb_event->key_code == -1 && directfb_keymap)
-	{
-		gint i;
-
-		for (i = directfb_min_keycode; i <= directfb_max_keycode; i++)
-		{
-			if (directfb_keymap[(i - directfb_min_keycode) * 4] == event->keyval)
-			{
-				event->hardware_keycode = i;
-				break;
-			}
-		}
-	} 
+  event->state            = _gdk_directfb_modifiers;
+  event->group            = (dfb_event->modifiers & DIMM_ALTGR) ? 1 : 0;
+  event->hardware_keycode = dfb_event->key_code;
+  event->keyval           = gdk_directfb_translate_key (dfb_event->key_id,
+                                                        dfb_event->key_symbol);
+  /* If the device driver didn't send a key_code (happens with remote
+     controls), we try to find a suitable key_code by looking at the
+     default keymap. */
+  if (dfb_event->key_code == -1 && directfb_keymap)
+    {
+      gint i;
+
+      for (i = directfb_min_keycode; i <= directfb_max_keycode; i++)
+        {
+          if (directfb_keymap[(i - directfb_min_keycode) * 4] == event->keyval)
+            {
+              event->hardware_keycode = i;
+              break;
+            }
+        }
+    }
 
-	len = g_unichar_to_utf8 (dfb_event->key_symbol, buf);
+  len = g_unichar_to_utf8 (dfb_event->key_symbol, buf);
 
-	event->string = g_strndup (buf, len);
-	event->length = len;
+  event->string = g_strndup (buf, len);
+  event->length = len;
 }
 
-/**
- * gdk_keymap_get_entries_for_keycode:
- * @keymap: a #GdkKeymap or %NULL to use the default keymap
- * @hardware_keycode: a keycode
- * @keys: return location for array of #GdkKeymapKey, or NULL
- * @keyvals: return location for array of keyvals, or NULL
- * @n_entries: length of @keys and @keyvals
- *
- * Returns the keyvals bound to @hardware_keycode.
- * The Nth #GdkKeymapKey in @keys is bound to the Nth
- * keyval in @keyvals. Free the returned arrays with g_free().
- * When a keycode is pressed by the user, the keyval from
- * this list of entries is selected by considering the effective
- * keyboard group and level. See gdk_keymap_translate_keyboard_state().
- *
- * Returns: %TRUE if there were any entries
- **/
 gboolean
 gdk_keymap_get_entries_for_keycode (GdkKeymap     *keymap,
-		guint          hardware_keycode,
-		GdkKeymapKey **keys,
-		guint        **keyvals,
-		gint          *n_entries)
+                                    guint          hardware_keycode,
+                                    GdkKeymapKey **keys,
+                                    guint        **keyvals,
+                                    gint          *n_entries)
 {
-	gint num = 0;
-	gint i, j;
-	gint index;
-
-	index = (hardware_keycode - directfb_min_keycode) * 4;
-
-	if (directfb_keymap && (hardware_keycode >= directfb_min_keycode && 
-				hardware_keycode <= directfb_max_keycode))
-	{
-		for (i = 0; i < 4; i++)
-			if (directfb_keymap[index + i] != GDK_VoidSymbol)
-				num++;
-	}
-
-	if (keys)
-	{
-		*keys = g_new (GdkKeymapKey, num);
-
-		for (i = 0, j = 0; num > 0 && i < 4; i++)
-			if (directfb_keymap[index + i] != GDK_VoidSymbol)
-			{
-				(*keys)[j].keycode = hardware_keycode;
-				(*keys)[j].level   = j % 2;
-				(*keys)[j].group   = j > DIKSI_BASE_SHIFT ? 1 : 0;
-				j++;
-			}
-	}
-	if (keyvals)
-	{
-		*keyvals = g_new (guint, num);
-
-		for (i = 0, j = 0; num > 0 && i < 4; i++)
-			if (directfb_keymap[index + i] != GDK_VoidSymbol)
-			{
-				(*keyvals)[j] = directfb_keymap[index + i];
-				j++;
-			}
-	}
+  gint num = 0;
+  gint i, j;
+  gint index;
+
+  index = (hardware_keycode - directfb_min_keycode) * 4;
+
+  if (directfb_keymap &&
+      hardware_keycode >= directfb_min_keycode &&
+      hardware_keycode <= directfb_max_keycode)
+    {
+      for (i = 0; i < 4; i++)
+        if (directfb_keymap[index + i] != GDK_VoidSymbol)
+          num++;
+    }
+
+  if (keys)
+    {
+      *keys = g_new (GdkKeymapKey, num);
 
-	if (n_entries)
-		*n_entries = num;
+      for (i = 0, j = 0; num > 0 && i < 4; i++)
+        if (directfb_keymap[index + i] != GDK_VoidSymbol)
+          {
+            (*keys)[j].keycode = hardware_keycode;
+            (*keys)[j].level   = j % 2;
+            (*keys)[j].group   = j > DIKSI_BASE_SHIFT ? 1 : 0;
+            j++;
+          }
+    }
+  if (keyvals)
+    {
+      *keyvals = g_new (guint, num);
+
+      for (i = 0, j = 0; num > 0 && i < 4; i++)
+        if (directfb_keymap[index + i] != GDK_VoidSymbol)
+          {
+            (*keyvals)[j] = directfb_keymap[index + i];
+            j++;
+          }
+    }
 
-	return (num > 0);
+  if (n_entries)
+    *n_entries = num;
+
+  return (num > 0);
 }
 
 static inline void
 append_keymap_key (GArray *array,
-		guint   keycode,
-		gint    group,
-		gint    level)
+                   guint   keycode,
+                   gint    group,
+                   gint    level)
 {
-	GdkKeymapKey key = { keycode, group, level };
+  GdkKeymapKey key = { keycode, group, level };
 
-	g_array_append_val (array, key);
+  g_array_append_val (array, key);
 }
 
-/**
- * gdk_keymap_get_entries_for_keyval:
- * @keymap: a #GdkKeymap, or %NULL to use the default keymap
- * @keyval: a keyval, such as %GDK_a, %GDK_Up, %GDK_Return, etc.
- * @keys: return location for an array of #GdkKeymapKey
- * @n_keys: return location for number of elements in returned array
- * 
- * Obtains a list of keycode/group/level combinations that will
- * generate @keyval. Groups and levels are two kinds of keyboard mode;
- * in general, the level determines whether the top or bottom symbol
- * on a key is used, and the group determines whether the left or
- * right symbol is used. On US keyboards, the shift key changes the
- * keyboard level, and there are no groups. A group switch key might
- * convert a keyboard between Hebrew to English modes, for example.
- * #GdkEventKey contains a %group field that indicates the active
- * keyboard group. The level is computed from the modifier mask.
- * The returned array should be freed
- * with g_free().
- *
- * Return value: %TRUE if keys were found and returned
- **/
 gboolean
 gdk_keymap_get_entries_for_keyval (GdkKeymap     *keymap,
-		guint          keyval,
-		GdkKeymapKey **keys,
-		gint          *n_keys)
+                                   guint          keyval,
+                                   GdkKeymapKey **keys,
+                                   gint          *n_keys)
 {
-	GArray *retval;
-	gint    i, j;
+  GArray *retval;
+  gint    i, j;
 
-	g_return_val_if_fail (keys != NULL, FALSE);
-	g_return_val_if_fail (n_keys != NULL, FALSE);
-	g_return_val_if_fail (keyval != GDK_VoidSymbol, FALSE);
-
-	retval = g_array_new (FALSE, FALSE, sizeof (GdkKeymapKey));
-
-	for (i = directfb_min_keycode;
-			directfb_keymap && i <= directfb_max_keycode;
-			i++)
-	{
-		gint index = i - directfb_min_keycode;
-
-		for (j = 0; j < 4; j++)
-		{
-			if (directfb_keymap[index * 4 + j] == keyval)
-				append_keymap_key (retval, i, j % 2, j > DIKSI_BASE_SHIFT ? 1 : 0);
-		}
-	}
-
-	if (retval->len > 0)
-	{
-		*keys = (GdkKeymapKey *) retval->data;
-		*n_keys = retval->len;
-	}
-	else
-	{
-		*keys = NULL;
-		*n_keys = 0;
-	}
+  g_return_val_if_fail (keys != NULL, FALSE);
+  g_return_val_if_fail (n_keys != NULL, FALSE);
+  g_return_val_if_fail (keyval != GDK_VoidSymbol, FALSE);
+
+  retval = g_array_new (FALSE, FALSE, sizeof (GdkKeymapKey));
+
+  for (i = directfb_min_keycode;
+       directfb_keymap && i <= directfb_max_keycode;
+       i++)
+    {
+      gint index = i - directfb_min_keycode;
 
-	g_array_free (retval, retval->len > 0 ? FALSE : TRUE);
+      for (j = 0; j < 4; j++)
+        {
+          if (directfb_keymap[index * 4 + j] == keyval)
+            append_keymap_key (retval, i, j % 2, j > DIKSI_BASE_SHIFT ? 1 : 0);
+        }
+    }
 
-	return (*n_keys > 0);
+  if (retval->len > 0)
+    {
+      *keys = (GdkKeymapKey *) retval->data;
+      *n_keys = retval->len;
+    }
+  else
+    {
+      *keys = NULL;
+      *n_keys = 0;
+    }
+
+  g_array_free (retval, retval->len > 0 ? FALSE : TRUE);
+
+  return (*n_keys > 0);
 }
 
 gboolean
 gdk_keymap_translate_keyboard_state (GdkKeymap       *keymap,
-		guint            keycode,
-		GdkModifierType  state,
-		gint             group,
-		guint           *keyval,
-		gint            *effective_group,
-		gint            *level,
-		GdkModifierType *consumed_modifiers)
+                                     guint            keycode,
+                                     GdkModifierType  state,
+                                     gint             group,
+                                     guint           *keyval,
+                                     gint            *effective_group,
+                                     gint            *level,
+                                     GdkModifierType *consumed_modifiers)
 {
-	if (directfb_keymap &&
-			(keycode >= directfb_min_keycode && keycode <= directfb_max_keycode) &&
-			(group == 0 || group == 1))
-	{
-		gint index = (keycode - directfb_min_keycode) * 4;
-		gint i =     (state & GDK_SHIFT_MASK) ? 1 : 0;
-
-		if (directfb_keymap[index + i + 2 * group] != GDK_VoidSymbol)
-		{
-			if (keyval)
-				*keyval = directfb_keymap[index + i + 2 * group];
-
-			if (group && directfb_keymap[index + i] == *keyval)
-			{
-				if (effective_group)
-					*effective_group = 0;
-                if(consumed_modifiers)
-				    *consumed_modifiers = 0;
-			}
-			else
-			{
-				if (effective_group)
-					*effective_group = group;
-                if(consumed_modifiers)
-				    *consumed_modifiers = GDK_MOD2_MASK;
-			}
-			if (level)
-				*level = i;
-
-			if (i && directfb_keymap[index + 2 * *effective_group] != *keyval)
-                if(consumed_modifiers)
-				    *consumed_modifiers |= GDK_SHIFT_MASK;
-
-			return TRUE;
-		}
-	}
-	if (keyval)
-		*keyval             = 0;
-	if (effective_group)
-		*effective_group    = 0;
-	if (level)
-		*level              = 0;
-    if(consumed_modifiers)
-	    *consumed_modifiers = 0;
+  if (directfb_keymap &&
+      keycode >= directfb_min_keycode &&
+      keycode <= directfb_max_keycode &&
+      (group == 0 || group == 1))
+    {
+      gint index = (keycode - directfb_min_keycode) * 4;
+      gint i     = (state & GDK_SHIFT_MASK) ? 1 : 0;
 
-	return FALSE;
+      if (directfb_keymap[index + i + 2 * group] != GDK_VoidSymbol)
+        {
+          if (keyval)
+            *keyval = directfb_keymap[index + i + 2 * group];
+
+          if (group && directfb_keymap[index + i] == *keyval)
+            {
+              if (effective_group)
+                *effective_group = 0;
+              if (consumed_modifiers)
+                *consumed_modifiers = 0;
+            }
+            else
+            {
+              if (effective_group)
+                *effective_group = group;
+              if (consumed_modifiers)
+                *consumed_modifiers = GDK_MOD2_MASK;
+            }
+          if (level)
+            *level = i;
+
+          if (keyval && i &&
+              directfb_keymap[index + effective_group ?
+                                      2 * *effective_group : 0] != *keyval)
+            {
+              if (consumed_modifiers)
+                *consumed_modifiers |= GDK_SHIFT_MASK;
+            }
+
+          return TRUE;
+        }
+    }
+  if (keyval)
+    *keyval             = 0;
+  if (effective_group)
+    *effective_group    = 0;
+  if (level)
+    *level              = 0;
+  if (consumed_modifiers)
+    *consumed_modifiers = 0;
+
+  return FALSE;
 }
 
-	GdkKeymap*
+GdkKeymap *
 gdk_keymap_get_for_display (GdkDisplay *display)
 {
-	if( display == NULL ) return NULL;
-	g_assert(GDK_IS_DISPLAY_DFB(display));
-	GdkDisplayDFB *gdisplay = GDK_DISPLAY_DFB(display);
-	g_assert( gdisplay->keymap != NULL);
-	return gdisplay->keymap;
+  if (!display)
+    return NULL;
+
+  g_assert (GDK_IS_DISPLAY_DFB (display));
+
+  GdkDisplayDFB *gdisplay = GDK_DISPLAY_DFB (display);
+
+  g_assert ( gdisplay->keymap != NULL);
+
+  return gdisplay->keymap;
 }
 
-	PangoDirection
+PangoDirection
 gdk_keymap_get_direction (GdkKeymap *keymap)
 {
-	return PANGO_DIRECTION_NEUTRAL;
+  return PANGO_DIRECTION_NEUTRAL;
 }
 
-/**
- * gdk_keymap_lookup_key:
- * @keymap: a #GdkKeymap or %NULL to use the default keymap
- * @key: a #GdkKeymapKey with keycode, group, and level initialized
- *
- * Looks up the keyval mapped to a keycode/group/level triplet.
- * If no keyval is bound to @key, returns 0. For normal user input,
- * you want to use gdk_keymap_translate_keyboard_state() instead of
- * this function, since the effective group/level may not be
- * the same as the current keyboard state.
- *
- * Return value: a keyval, or 0 if none was mapped to the given @key
- **/
 guint
 gdk_keymap_lookup_key (GdkKeymap          *keymap,
-		const GdkKeymapKey *key)
+                       const GdkKeymapKey *key)
 {
-	g_warning("gdk_keymap_lookup_key unimplemented \n");	
-	return 0;
-}
+  D_UNIMPLEMENTED();
 
+  return 0;
+}
 
 #define __GDK_KEYS_DIRECTFB_C__
 #include "gdkaliasdef.c"
--- gtk+-2.12.12.orig/gdk/directfb/gdkmain-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkmain-directfb.c
@@ -32,36 +32,24 @@
  */
 
 /*
- Main entry point for 2.6 seems to be open_display so 
+ Main entry point for 2.6 seems to be open_display so
  most stuff in main is moved over to gdkdisplay-directfb.c
  I'll move stub functions here that make no sense for directfb
  and true globals
  Michael Emmel
 */
 
-#include <config.h>
-#include <string.h> 
-#include <stdlib.h> 
-#include "gdk.h"
+#include "config.h"
 
-#include "gdkdisplay.h"
-#include "gdkdirectfb.h"
+#include "gdk.h"
 #include "gdkprivate-directfb.h"
-
-#include "gdkinternals.h"
-
 #include "gdkinput-directfb.h"
-
-#include "gdkintl.h"
 #include "gdkalias.h"
 
-
 void
 _gdk_windowing_init (void)
 {
-  /** 
-    Not that usable called before parse_args
-  **/
+  _gdk_selection_property = gdk_atom_intern ("GDK_SELECTION", FALSE);
 }
 
 void
@@ -72,34 +60,30 @@
 gboolean
 gdk_get_use_xshm (void)
 {
-  return FALSE;
+  return TRUE;
 }
 
 void
-_gdk_windowing_display_set_sm_client_id (GdkDisplay *display,const gchar *sm_client_id)
+_gdk_windowing_display_set_sm_client_id (GdkDisplay  *display,
+                                         const gchar *sm_client_id)
 {
-  g_message ("gdk_set_sm_client_id() is unimplemented.");
+  D_UNIMPLEMENTED();
 }
 
-
 void
 _gdk_windowing_exit (void)
 {
- 
-  if (_gdk_display->buffer)
-    _gdk_display->buffer->Release (_gdk_display->buffer);
+  if (_gdk_display_dfb->buffer)
+    _gdk_display_dfb->buffer->Release (_gdk_display_dfb->buffer);
 
   _gdk_directfb_keyboard_exit ();
 
-  if (_gdk_display->keyboard)
-    _gdk_display->keyboard->Release (_gdk_display->keyboard);
+  if (_gdk_display_dfb->keyboard)
+    _gdk_display_dfb->keyboard->Release (_gdk_display_dfb->keyboard);
 
-  _gdk_display->layer->Release (_gdk_display->layer);
+  _gdk_display_dfb->layer->Release (_gdk_display_dfb->layer);
 
-   _gdk_display->directfb->Release (_gdk_display->directfb);
-
-  g_free (_gdk_display);
-  _gdk_display = NULL;
+  _gdk_display_dfb->directfb->Release (_gdk_display_dfb->directfb);
 }
 
 gchar *
@@ -108,183 +92,84 @@
   return g_strdup (gdk_display_get_name (gdk_display_get_default ()));
 }
 
-
 /* utils */
 static const guint type_masks[] =
 {
-  GDK_STRUCTURE_MASK,        /* GDK_DELETE            =  0, */
-  GDK_STRUCTURE_MASK,        /* GDK_DESTROY           =  1, */
-  GDK_EXPOSURE_MASK,         /* GDK_EXPOSE            =  2, */
-  GDK_POINTER_MOTION_MASK,   /* GDK_MOTION_NOTIFY     =  3, */
-  GDK_BUTTON_PRESS_MASK,     /* GDK_BUTTON_PRESS      =  4, */
-  GDK_BUTTON_PRESS_MASK,     /* GDK_2BUTTON_PRESS     =  5, */
-  GDK_BUTTON_PRESS_MASK,     /* GDK_3BUTTON_PRESS     =  6, */
-  GDK_BUTTON_RELEASE_MASK,   /* GDK_BUTTON_RELEASE    =  7, */
-  GDK_KEY_PRESS_MASK,        /* GDK_KEY_PRESS         =  8, */
-  GDK_KEY_RELEASE_MASK,      /* GDK_KEY_RELEASE       =  9, */
-  GDK_ENTER_NOTIFY_MASK,     /* GDK_ENTER_NOTIFY      = 10, */
-  GDK_LEAVE_NOTIFY_MASK,     /* GDK_LEAVE_NOTIFY      = 11, */
-  GDK_FOCUS_CHANGE_MASK,     /* GDK_FOCUS_CHANGE      = 12, */
-  GDK_STRUCTURE_MASK,        /* GDK_CONFIGURE         = 13, */
-  GDK_VISIBILITY_NOTIFY_MASK,/* GDK_MAP               = 14, */
-  GDK_VISIBILITY_NOTIFY_MASK,/* GDK_UNMAP             = 15, */
-  GDK_PROPERTY_CHANGE_MASK,  /* GDK_PROPERTY_NOTIFY   = 16, */
-  GDK_PROPERTY_CHANGE_MASK,  /* GDK_SELECTION_CLEAR   = 17, */
-  GDK_PROPERTY_CHANGE_MASK,  /* GDK_SELECTION_REQUEST = 18, */
-  GDK_PROPERTY_CHANGE_MASK,  /* GDK_SELECTION_NOTIFY  = 19, */
-  GDK_PROXIMITY_IN_MASK,     /* GDK_PROXIMITY_IN      = 20, */
-  GDK_PROXIMITY_OUT_MASK,    /* GDK_PROXIMITY_OUT     = 21, */
-  GDK_ALL_EVENTS_MASK,       /* GDK_DRAG_ENTER        = 22, */
-  GDK_ALL_EVENTS_MASK,       /* GDK_DRAG_LEAVE        = 23, */
-  GDK_ALL_EVENTS_MASK,       /* GDK_DRAG_MOTION       = 24, */
-  GDK_ALL_EVENTS_MASK,       /* GDK_DRAG_STATUS       = 25, */
-  GDK_ALL_EVENTS_MASK,       /* GDK_DROP_START        = 26, */
-  GDK_ALL_EVENTS_MASK,       /* GDK_DROP_FINISHED     = 27, */
-  GDK_ALL_EVENTS_MASK,       /* GDK_CLIENT_EVENT      = 28, */
-  GDK_VISIBILITY_NOTIFY_MASK,/* GDK_VISIBILITY_NOTIFY = 29, */
-  GDK_EXPOSURE_MASK,         /* GDK_NO_EXPOSE         = 30, */
-  GDK_SCROLL_MASK            /* GDK_SCROLL            = 31  */
+  GDK_STRUCTURE_MASK,                       /* GDK_DELETE            =  0, */
+  GDK_STRUCTURE_MASK,                       /* GDK_DESTROY           =  1, */
+  GDK_EXPOSURE_MASK,                        /* GDK_EXPOSE            =  2, */
+  GDK_POINTER_MOTION_MASK,                  /* GDK_MOTION_NOTIFY     =  3, */
+  GDK_BUTTON_PRESS_MASK,                    /* GDK_BUTTON_PRESS      =  4, */
+  GDK_BUTTON_PRESS_MASK,                    /* GDK_2BUTTON_PRESS     =  5, */
+  GDK_BUTTON_PRESS_MASK,                    /* GDK_3BUTTON_PRESS     =  6, */
+  GDK_BUTTON_RELEASE_MASK,                  /* GDK_BUTTON_RELEASE    =  7, */
+  GDK_KEY_PRESS_MASK,                       /* GDK_KEY_PRESS         =  8, */
+  GDK_KEY_RELEASE_MASK,                     /* GDK_KEY_RELEASE       =  9, */
+  GDK_ENTER_NOTIFY_MASK,                    /* GDK_ENTER_NOTIFY      = 10, */
+  GDK_LEAVE_NOTIFY_MASK,                    /* GDK_LEAVE_NOTIFY      = 11, */
+  GDK_FOCUS_CHANGE_MASK,                    /* GDK_FOCUS_CHANGE      = 12, */
+  GDK_STRUCTURE_MASK,                       /* GDK_CONFIGURE         = 13, */
+  GDK_VISIBILITY_NOTIFY_MASK,               /* GDK_MAP               = 14, */
+  GDK_VISIBILITY_NOTIFY_MASK,               /* GDK_UNMAP             = 15, */
+  GDK_PROPERTY_CHANGE_MASK,                 /* GDK_PROPERTY_NOTIFY   = 16, */
+  GDK_PROPERTY_CHANGE_MASK,                 /* GDK_SELECTION_CLEAR   = 17, */
+  GDK_PROPERTY_CHANGE_MASK,                 /* GDK_SELECTION_REQUEST = 18, */
+  GDK_PROPERTY_CHANGE_MASK,                 /* GDK_SELECTION_NOTIFY  = 19, */
+  GDK_PROXIMITY_IN_MASK,                    /* GDK_PROXIMITY_IN      = 20, */
+  GDK_PROXIMITY_OUT_MASK,                   /* GDK_PROXIMITY_OUT     = 21, */
+  GDK_ALL_EVENTS_MASK,                      /* GDK_DRAG_ENTER        = 22, */
+  GDK_ALL_EVENTS_MASK,                      /* GDK_DRAG_LEAVE        = 23, */
+  GDK_ALL_EVENTS_MASK,                      /* GDK_DRAG_MOTION       = 24, */
+  GDK_ALL_EVENTS_MASK,                      /* GDK_DRAG_STATUS       = 25, */
+  GDK_ALL_EVENTS_MASK,                      /* GDK_DROP_START        = 26, */
+  GDK_ALL_EVENTS_MASK,                      /* GDK_DROP_FINISHED     = 27, */
+  GDK_ALL_EVENTS_MASK,                      /* GDK_CLIENT_EVENT      = 28, */
+  GDK_VISIBILITY_NOTIFY_MASK,               /* GDK_VISIBILITY_NOTIFY = 29, */
+  GDK_EXPOSURE_MASK,                        /* GDK_NO_EXPOSE         = 30, */
+  GDK_SCROLL_MASK | GDK_BUTTON_PRESS_MASK,  /* GDK_SCROLL            = 31, */
+  GDK_WINDOW_STATE,                         /* GDK_WINDOW_STATE      = 32, */
+  GDK_SETTING,                              /* GDK_SETTING,          = 33, */
+  GDK_OWNER_CHANGE,                         /* GDK_OWNER_CHANGE      = 34, */
+  GDK_GRAB_BROKEN,                          /* GDK_GRAB_BROKEN       = 35, */
 };
 
-GdkWindow *
-gdk_directfb_other_event_window (GdkWindow    *window,
-                                 GdkEventType  type)
+static GdkEventMask
+gdk_directfb_event_type_mask (GdkEventType type)
 {
-  guint32    evmask;
-  GdkWindow *w;
+  unsigned int index = type;
 
-  w = window;
-  while (w != _gdk_parent_root)
-    {
-      /* Huge hack, so that we don't propagate events to GtkWindow->frame */
-      if ((w != window) &&
-          (GDK_WINDOW_OBJECT (w)->window_type != GDK_WINDOW_CHILD) &&
-          (g_object_get_data (G_OBJECT (w), "gdk-window-child-handler")))
-        break;
-
-      evmask = GDK_WINDOW_OBJECT (w)->event_mask;
-
-      if (evmask & type_masks[type])
-        return w;
+  if (index < G_N_ELEMENTS (type_masks))
+    return type_masks[index];
 
-      w = gdk_window_get_parent (w);
-    }
-
-  return NULL;
+  return GDK_ALL_EVENTS_MASK;
 }
 
 GdkWindow *
-gdk_directfb_pointer_event_window (GdkWindow    *window,
-                                   GdkEventType  type)
-{
-  guint            evmask;
-  GdkModifierType  mask;
-  GdkWindow       *w;
-
-  gdk_directfb_mouse_get_info (NULL, NULL, &mask);
-
-  if (_gdk_directfb_pointer_grab_window && !_gdk_directfb_pointer_grab_owner_events )
-    {
-      evmask = _gdk_directfb_pointer_grab_events;
-
-      if (evmask & (GDK_BUTTON1_MOTION_MASK |
-                    GDK_BUTTON2_MOTION_MASK |
-                    GDK_BUTTON3_MOTION_MASK))
-        {
-          if (((mask & GDK_BUTTON1_MASK) &&
-               (evmask & GDK_BUTTON1_MOTION_MASK)) ||
-              ((mask & GDK_BUTTON2_MASK) &&
-               (evmask & GDK_BUTTON2_MOTION_MASK)) ||
-              ((mask & GDK_BUTTON3_MASK) &&
-               (evmask & GDK_BUTTON3_MOTION_MASK)))
-            evmask |= GDK_POINTER_MOTION_MASK;
-        }
-
-      if (evmask & type_masks[type]) {
-
-        if( _gdk_directfb_pointer_grab_owner_events ) {
-        return _gdk_directfb_pointer_grab_window;
-        }else {
-                GdkWindowObject *obj= GDK_WINDOW_OBJECT(window);
-                while (obj != NULL && 
-                    obj != GDK_WINDOW_OBJECT(_gdk_directfb_pointer_grab_window)) {
-                    obj = (GdkWindowObject *)obj->parent;
-                }
-                if( obj ==GDK_WINDOW_OBJECT(_gdk_directfb_pointer_grab_window) ) {
-                    return  window;
-                }else {
-                    //was not  child of the grab window so return the grab window
-                    return _gdk_directfb_pointer_grab_window;
-                }
-         }
-        }
-    }
-
-  w = window;
-  while (w != _gdk_parent_root)
-    {
-      /* Huge hack, so that we don't propagate events to GtkWindow->frame */
-      if ((w != window) &&
-          (GDK_WINDOW_OBJECT (w)->window_type != GDK_WINDOW_CHILD) &&
-          (g_object_get_data (G_OBJECT (w), "gdk-window-child-handler")))
-        break;
-
-      evmask = GDK_WINDOW_OBJECT (w)->event_mask;
-
-      if (evmask & (GDK_BUTTON1_MOTION_MASK |
-                    GDK_BUTTON2_MOTION_MASK |
-                    GDK_BUTTON3_MOTION_MASK))
-        {
-          if (((mask & GDK_BUTTON1_MASK) &&
-               (evmask & GDK_BUTTON1_MOTION_MASK)) ||
-              ((mask & GDK_BUTTON2_MASK) &&
-               (evmask & GDK_BUTTON2_MOTION_MASK)) ||
-              ((mask & GDK_BUTTON3_MASK) &&
-               (evmask & GDK_BUTTON3_MOTION_MASK)))
-            evmask |= GDK_POINTER_MOTION_MASK;
-        }
-
-      if (evmask & type_masks[type])
-        return w;
-
-      w = gdk_window_get_parent (w);
-    }
-
-  return NULL;
-}
-
-GdkWindow *
-gdk_directfb_keyboard_event_window (GdkWindow    *window,
-                                    GdkEventType  type)
+gdk_directfb_other_event_window (GdkWindow    *window,
+                                 GdkEventType  type)
 {
   guint32    evmask;
   GdkWindow *w;
 
-  if (_gdk_directfb_keyboard_grab_window &&
-      !_gdk_directfb_keyboard_grab_owner_events)
-    {
-      return _gdk_directfb_keyboard_grab_window;
-    }
-
   w = window;
   while (w != _gdk_parent_root)
     {
       /* Huge hack, so that we don't propagate events to GtkWindow->frame */
-      if ((w != window) &&
-          (GDK_WINDOW_OBJECT (w)->window_type != GDK_WINDOW_CHILD) &&
-          (g_object_get_data (G_OBJECT (w), "gdk-window-child-handler")))
+      if (w != window &&
+          GDK_WINDOW_OBJECT (w)->window_type != GDK_WINDOW_CHILD &&
+          g_object_get_data (G_OBJECT (w), "gdk-window-child-handler"))
         break;
 
       evmask = GDK_WINDOW_OBJECT (w)->event_mask;
 
-      if (evmask & type_masks[type])
+      if (evmask & gdk_directfb_event_type_mask (type))
         return w;
 
       w = gdk_window_get_parent (w);
     }
-   return w;
-}
 
+  return NULL;
+}
 
 GdkEvent *
 gdk_directfb_event_make (GdkWindow    *window,
@@ -292,6 +177,7 @@
 {
   GdkEvent *event    = gdk_event_new (GDK_NOTHING);
   guint32   the_time = gdk_directfb_get_time ();
+
   event->any.type       = type;
   event->any.window     = g_object_ref (window);
   event->any.send_event = FALSE;
@@ -370,27 +256,15 @@
   return 0;
 }
 
-
-/**
- * gdk_pointer_grab_info_libgtk_only:
- * @grab_window: location to store current grab window
- * @owner_events: location to store boolean indicating whether
- *   the @owner_events flag to gdk_pointer_grab() was %TRUE.
- *
- * Determines information about the current pointer grab.
- * This is not public API and must not be used by applications.
- *
- * Return value: %TRUE if this application currently has the
- *  pointer grabbed.
- **/
 gboolean
-gdk_pointer_grab_info_libgtk_only (GdkDisplay *display,GdkWindow **grab_window,
-				   gboolean    *owner_events)
+gdk_pointer_grab_info_libgtk_only (GdkDisplay  *display,
+                                   GdkWindow  **grab_window,
+                                   gboolean    *owner_events)
 {
   if (_gdk_directfb_pointer_grab_window)
     {
       if (grab_window)
-        *grab_window = (GdkWindow *)_gdk_directfb_pointer_grab_window;
+        *grab_window = _gdk_directfb_pointer_grab_window;
       if (owner_events)
         *owner_events = _gdk_directfb_pointer_grab_owner_events;
 
@@ -400,26 +274,15 @@
   return FALSE;
 }
 
-/**
- * gdk_keyboard_grab_info_libgtk_only:
- * @grab_window: location to store current grab window
- * @owner_events: location to store boolean indicating whether
- *   the @owner_events flag to gdk_keyboard_grab() was %TRUE.
- *
- * Determines information about the current keyboard grab.
- * This is not public API and must not be used by applications.
- *
- * Return value: %TRUE if this application currently has the
- *  keyboard grabbed.
- **/
 gboolean
-gdk_keyboard_grab_info_libgtk_only (GdkDisplay *display,GdkWindow **grab_window,
-				    gboolean    *owner_events)
+gdk_keyboard_grab_info_libgtk_only (GdkDisplay  *display,
+                                    GdkWindow  **grab_window,
+                                    gboolean    *owner_events)
 {
   if (_gdk_directfb_keyboard_grab_window)
     {
       if (grab_window)
-        *grab_window = (GdkWindow *) _gdk_directfb_keyboard_grab_window;
+        *grab_window = _gdk_directfb_keyboard_grab_window;
       if (owner_events)
         *owner_events = _gdk_directfb_keyboard_grab_owner_events;
 
@@ -429,73 +292,29 @@
   return FALSE;
 }
 
-
 GdkGrabStatus
 gdk_keyboard_grab (GdkWindow *window,
                    gint       owner_events,
-                   guint32    time) 
+                   guint32    time)
 {
-	return gdk_display_keyboard_grab(gdk_display_get_default(),
-			window,
-			owner_events,
-			time);
+  return gdk_directfb_keyboard_grab (gdk_display_get_default (),
+                                     window,
+                                     owner_events,
+                                     time);
 
 }
 
-/*
- *--------------------------------------------------------------
- * gdk_pointer_grab
- *
- *   Grabs the pointer to a specific window
- *
- * Arguments:
- *   "window" is the window which will receive the grab
- *   "owner_events" specifies whether events will be reported as is,
- *     or relative to "window"
- *   "event_mask" masks only interesting events
- *   "confine_to" limits the cursor movement to the specified window
- *   "cursor" changes the cursor for the duration of the grab
- *   "time" specifies the time
- *
- * Results:
- *
- * Side effects:
- *   requires a corresponding call to gdk_pointer_ungrab
- *
- *--------------------------------------------------------------
- */
-
-
 GdkGrabStatus
-gdk_display_pointer_grab (GdkDisplay *display,GdkWindow    *window,
+gdk_pointer_grab (GdkWindow    *window,
                   gint          owner_events,
                   GdkEventMask  event_mask,
                   GdkWindow    *confine_to,
                   GdkCursor    *cursor,
                   guint32       time)
 {
-  g_return_val_if_fail (GDK_IS_WINDOW (window), 0);
-  g_return_val_if_fail (confine_to == NULL || GDK_IS_WINDOW (confine_to), 0);
-
-  return gdk_directfb_pointer_grab (window,
-                                    owner_events,
+  return gdk_directfb_pointer_grab (window, owner_events,
                                     event_mask,
-                                    confine_to,
-                                    cursor,
-                                    time,
-                                    FALSE);
-}
-
-GdkGrabStatus
-gdk_pointer_grab (GdkWindow *     window,
-                  gint            owner_events,
-                  GdkEventMask    event_mask,
-                  GdkWindow *     confine_to,
-                  GdkCursor *     cursor,
-                  guint32         time)
-{
-	return gdk_directfb_pointer_grab(window, owner_events,event_mask,
-		confine_to,cursor,time,FALSE);	
+                                    confine_to, cursor, time, FALSE);
 }
 
 #define __GDK_MAIN_X11_C__
--- gtk+-2.12.12.orig/gdk/directfb/gdkpixmap-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkpixmap-directfb.c
@@ -31,29 +31,19 @@
  *            Sven Neumann <sven@convergence.de>
  */
 
-#include <config.h>
-#include "gdk.h"
-
-#include <stdlib.h>
-#include <string.h>
+#include "config.h"
 
 #include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
-
-#include "gdkinternals.h"
-
 #include "gdkpixmap.h"
 #include "gdkalias.h"
 
-
 static void gdk_pixmap_impl_directfb_init       (GdkPixmapImplDirectFB      *pixmap);
 static void gdk_pixmap_impl_directfb_class_init (GdkPixmapImplDirectFBClass *klass);
 static void gdk_pixmap_impl_directfb_finalize   (GObject                    *object);
 
-
 static gpointer parent_class = NULL;
 
-
 GType
 gdk_pixmap_impl_directfb_get_type (void)
 {
@@ -92,6 +82,7 @@
 gdk_pixmap_impl_directfb_init (GdkPixmapImplDirectFB *impl)
 {
   GdkDrawableImplDirectFB *draw_impl = GDK_DRAWABLE_IMPL_DIRECTFB (impl);
+
   draw_impl->width  = 1;
   draw_impl->height = 1;
 }
@@ -109,17 +100,15 @@
 static void
 gdk_pixmap_impl_directfb_finalize (GObject *object)
 {
-  GdkDrawableImplDirectFB *impl = GDK_DRAWABLE_IMPL_DIRECTFB (object);
-
   if (G_OBJECT_CLASS (parent_class)->finalize)
     G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
 GdkPixmap*
 gdk_pixmap_new (GdkDrawable *drawable,
-                gint       width,
-                gint       height,
-                gint       depth)
+                gint         width,
+                gint         height,
+                gint         depth)
 {
   DFBSurfacePixelFormat    format;
   IDirectFBSurface        *surface;
@@ -147,7 +136,7 @@
       g_return_val_if_fail (draw_impl != NULL, NULL);
 
       draw_impl->surface->GetPixelFormat (draw_impl->surface, &format);
-      depth = DFB_BITS_PER_PIXEL (format);
+      depth = GDK_DFB_BITS_PER_PIXEL (format);
     }
   else
     {
@@ -166,22 +155,21 @@
           format = DSPF_RGB16;
           break;
         case 24:
-          format = DSPF_RGB24;
+          format = DSPF_RGB32;
           break;
         case 32:
-          format = DSPF_RGB32;
+          format = DSPF_ARGB;
           break;
         default:
-          g_message ("unimplemented %s for depth %d", G_STRLOC, depth);
+          g_message ("unsupported depth %d", depth);
           return NULL;
         }
     }
 
-  if( !(surface = 
-	gdk_display_dfb_create_surface(_gdk_display,format,width,height) )) { 
-    g_assert( surface != NULL);
-    return NULL;
-  }
+  surface = gdk_display_dfb_create_surface (_gdk_display_dfb,
+                                            format, width, height);
+  if (!surface)
+      return NULL;
 
   pixmap = g_object_new (gdk_pixmap_get_type (), NULL);
   draw_impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (pixmap)->impl);
@@ -198,7 +186,7 @@
 }
 
 GdkPixmap *
-gdk_bitmap_create_from_data (GdkDrawable   *drawable,
+gdk_bitmap_create_from_data (GdkDrawable *drawable,
                              const gchar *data,
                              gint         width,
                              gint         height)
@@ -219,29 +207,32 @@
 
   if (pixmap)
     {
-      guchar *dst;
-      gint    pitch;
+      DFBResult  ret;
+      void      *ptr;
+      gint       pitch;
 
       IDirectFBSurface *surface;
 
       surface = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (pixmap)->impl)->surface;
 
-      if (surface->Lock( surface, DSLF_WRITE, (void**)(&dst), &pitch ) == DFB_OK)
+      ret = surface->Lock (surface, DSLF_WRITE, &ptr, &pitch);
+      if (ret == DFB_OK)
         {
-          gint i, j;
+          gint    i, j;
+          guchar *dst = ptr;
 
           for (i = 0; i < height; i++)
             {
-	      for (j = 0; j < width; j++)
-		{
-		  dst[j] = GET_PIXEL (data, j) * 255;
-		}
+              for (j = 0; j < width; j++)
+                {
+                  dst[j] = GET_PIXEL (data, j) * 255;
+                }
 
               data += (width + 7) / 8;
-	      dst += pitch;
+              dst += pitch;
             }
 
-          surface->Unlock( surface );
+          surface->Unlock (surface);
         }
     }
 
@@ -251,13 +242,13 @@
 }
 
 GdkPixmap*
-gdk_pixmap_create_from_data (GdkDrawable   *drawable,
-                             const gchar *data,
-                             gint         width,
-                             gint         height,
-                             gint         depth,
-                             const GdkColor    *fg,
-                             const GdkColor    *bg)
+gdk_pixmap_create_from_data (GdkDrawable    *drawable,
+                             const gchar    *data,
+                             gint            width,
+                             gint            height,
+                             gint            depth,
+                             const GdkColor *fg,
+                             const GdkColor *bg)
 {
   GdkPixmap *pixmap;
 
@@ -273,9 +264,10 @@
 
   if (pixmap)
     {
+      DFBResult         ret;
       IDirectFBSurface *surface;
-      gchar            *dst;
-      gint              pitch;
+      void             *ptr;
+      int               pitch;
       gint              src_pitch;
 
       depth = gdk_drawable_get_depth (pixmap);
@@ -283,10 +275,11 @@
 
       surface = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (pixmap)->impl)->surface;
 
-      if (surface->Lock( surface,
-                         DSLF_WRITE, (void**)(&dst), &pitch ) == DFB_OK)
+      ret = surface->Lock (surface, DSLF_WRITE, &ptr, &pitch);
+      if (ret == DFB_OK)
         {
-          gint i;
+          gint   i;
+          gchar *dst = ptr;
 
           for (i = 0; i < height; i++)
             {
@@ -295,22 +288,24 @@
               data += src_pitch;
             }
 
-          surface->Unlock( surface );
+          surface->Unlock (surface);
         }
     }
 
   return pixmap;
 }
 
-GdkPixmap*
+GdkPixmap *
 gdk_pixmap_foreign_new (GdkNativeWindow anid)
 {
-  g_warning(" gdk_pixmap_foreign_new unsuporrted \n");
+  D_UNIMPLEMENTED();
+
   return NULL;
 }
 
-GdkPixmap*
-gdk_pixmap_foreign_new_for_display (GdkDisplay *display, GdkNativeWindow anid)
+GdkPixmap *
+gdk_pixmap_foreign_new_for_display (GdkDisplay      *display,
+                                    GdkNativeWindow  anid)
 {
   return gdk_pixmap_foreign_new(anid);
 }
@@ -322,19 +317,20 @@
                                    gint             height,
                                    gint             depth)
 {
-  /*Use the root drawable for now since only one screen */
-  return gdk_pixmap_new(NULL,width,height,depth);
+  /* Use the root drawable for now since only one screen */
+  return gdk_pixmap_new (NULL, width, height, depth);
 }
 
-
-GdkPixmap*
+GdkPixmap *
 gdk_pixmap_lookup (GdkNativeWindow anid)
 {
-  g_warning(" gdk_pixmap_lookup unsuporrted \n");
+  D_UNIMPLEMENTED();
+
   return NULL;
 }
 
-GdkPixmap* gdk_pixmap_lookup_for_display (GdkDisplay *display,GdkNativeWindow anid)
+GdkPixmap* gdk_pixmap_lookup_for_display (GdkDisplay      *display,
+                                          GdkNativeWindow  anid)
 {
   return gdk_pixmap_lookup (anid);
 }
--- gtk+-2.12.12.orig/gdk/directfb/gdkprivate-directfb.h
+++ gtk+-2.12.12/gdk/directfb/gdkprivate-directfb.h
@@ -33,14 +33,11 @@
 #ifndef __GDK_PRIVATE_DIRECTFB_H__
 #define __GDK_PRIVATE_DIRECTFB_H__
 
-//#include <gdk/gdk.h>
-#include <gdk/gdkprivate.h>
+#include <directfb_util.h>
 #include "gdkinternals.h"
 #include "gdkcursor.h"
 #include "gdkdisplay-directfb.h"
-#include <cairo.h>
-
-
+#include "gdkregion-generic.h"
 
 #define GDK_TYPE_DRAWABLE_IMPL_DIRECTFB       (gdk_drawable_impl_directfb_get_type ())
 #define GDK_DRAWABLE_IMPL_DIRECTFB(object)    (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_DRAWABLE_IMPL_DIRECTFB, GdkDrawableImplDirectFB))
@@ -54,65 +51,47 @@
 #define GDK_PIXMAP_IMPL_DIRECTFB(object)      (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_PIXMAP_IMPL_DIRECTFB, GdkPixmapImplDirectFB))
 #define GDK_IS_PIXMAP_IMPL_DIRECTFB(object)   (G_TYPE_CHECK_INSTANCE_TYPE ((object), GDK_TYPE_PIXMAP_IMPL_DIRECTFB))
 
-
-typedef struct _GdkDrawableImplDirectFB GdkDrawableImplDirectFB;
-typedef struct _GdkWindowImplDirectFB   GdkWindowImplDirectFB;
-typedef struct _GdkPixmapImplDirectFB   GdkPixmapImplDirectFB;
-
-
-struct _GdkDrawableImplDirectFB
+typedef struct
 {
-  GdkDrawable             parent_object;
-
-  GdkDrawable            *wrapper;
+  GdkDrawable            parent_object;
 
-  gboolean                buffered;
+  GdkDrawable           *wrapper;
 
-  GdkRegion              *paint_region;
-  gint                    paint_depth;
-  gint                    width;
-  gint                    height;
-  gint                    abs_x;
-  gint                    abs_y;
+  gboolean               buffered;
 
-  GdkColormap            *colormap;
+  GdkRegion              paint_region;
+  gint                   paint_depth;
+  gint                   width;
+  gint                   height;
+  gint                   abs_x;
+  gint                   abs_y;
 
-  IDirectFBSurface       *surface;
-  DFBSurfacePixelFormat   format;
-  cairo_surface_t *  cairo_surface;
+  GdkRegion              clip_region;
+  GdkColormap           *colormap;
 
-};
+  IDirectFBSurface      *surface;
+  DFBSurfacePixelFormat  format;
+  cairo_surface_t       *cairo_surface;
+} GdkDrawableImplDirectFB;
 
 typedef struct
 {
-  GdkDrawableClass  parent_class;
+  GdkDrawableClass parent_class;
 } GdkDrawableImplDirectFBClass;
 
-GType      gdk_drawable_impl_directfb_get_type (void);
-
-void       _gdk_directfb_draw_rectangle (GdkDrawable *drawable,
-                                         GdkGC       *gc,
-                                         gint         filled,
-                                         gint         x,
-                                         gint         y,
-                                         gint         width,
-                                         gint         height);
-
-void       _gdk_directfb_update         (GdkDrawableImplDirectFB *impl,
-                                         DFBRegion               *region);
-
-GdkEvent *  gdk_directfb_event_make     (GdkWindow               *window,
-                                         GdkEventType             type);
+GType     gdk_drawable_impl_directfb_get_type (void);
 
+GdkEvent *gdk_directfb_event_make             (GdkWindow    *window,
+                                               GdkEventType  type);
 
 /*
  * Pixmap
  */
 
-struct _GdkPixmapImplDirectFB
+typedef struct
 {
   GdkDrawableImplDirectFB parent_instance;
-};
+} GdkPixmapImplDirectFB;
 
 typedef struct
 {
@@ -121,59 +100,68 @@
 
 GType gdk_pixmap_impl_directfb_get_type (void);
 
-
-
 /*
  * Window
  */
 
 typedef struct
 {
-  gulong   length;
-  GdkAtom  type;
-  gint     format;
-  guchar   data[1];
+  gulong  length;
+  GdkAtom type;
+  gint    format;
+  guchar  data[1];
 } GdkWindowProperty;
 
-
-struct _GdkWindowImplDirectFB
+typedef struct
 {
-  GdkDrawableImplDirectFB drawable;
-  GdkWindow             *gdkWindow;
+  GdkDrawableImplDirectFB  drawable;
+
+  GdkWindow               *gdkWindow;
+
+  IDirectFBWindow         *window;
 
-  IDirectFBWindow        *window;
+  DFBWindowID              dfb_id;
 
-  DFBWindowID             dfb_id;
+  GdkCursor               *cursor;
+  GHashTable              *properties;
 
-  GdkCursor              *cursor;
-  GHashTable             *properties;
+  guint8                   opacity;
 
-  guint8                  opacity;
+  GdkWindowTypeHint        type_hint;
 
-  GdkWindowTypeHint       type_hint;
-};
+  DFBUpdates               flips;
+  DFBRegion                flip_regions[4];
+} GdkWindowImplDirectFB;
 
 typedef struct
 {
   GdkDrawableImplDirectFBClass parent_class;
 } GdkWindowImplDirectFBClass;
 
-GType gdk_window_impl_directfb_get_type        (void);
+GType      gdk_window_impl_directfb_get_type   (void);
 
-void  gdk_directfb_window_send_crossing_events (GdkWindow       *src,
-                                                GdkWindow       *dest,
-                                                GdkCrossingMode  mode);
+#define    GDK_IS_CORE(d) (((GdkDevice *) (d)) == _gdk_core_pointer)
 
-void  _gdk_directfb_calc_abs                   (GdkWindow       *window);
+void       gdk_directfb_calc_abs               (GdkWindow   *window);
 
-GdkWindow * gdk_directfb_window_find_toplevel  (GdkWindow       *window);
+GdkWindow *gdk_directfb_window_find_toplevel   (GdkWindow   *window);
 
 
-void        gdk_directfb_window_id_table_insert (DFBWindowID  dfb_id,
-                                                 GdkWindow   *window);
-void        gdk_directfb_window_id_table_remove (DFBWindowID  dfb_id);
-GdkWindow * gdk_directfb_window_id_table_lookup (DFBWindowID  dfb_id);
+void       gdk_directfb_window_id_table_insert (DFBWindowID  dfb_id,
+                                                GdkWindow   *window);
+void       gdk_directfb_window_id_table_remove (DFBWindowID  dfb_id);
+GdkWindow *gdk_directfb_window_id_table_lookup (DFBWindowID  dfb_id);
 
+#define GDKDFB_RECTANGLE_VALS_FROM_BOX(s)  (s)->x1, (s)->y1, (s)->x2-(s)->x1, (s)->y2-(s)->y1
+
+#define GDKDFB_WIMPL_FORM   "%4d,%4d-%4dx%4d %d"
+#define GDKDFB_WIMPL_V(w)   GDK_WINDOW_OBJECT ((w)->gdkWindow)->x,     \
+                            GDK_WINDOW_OBJECT ((w)->gdkWindow)->y,     \
+                            (w)->drawable.width, (w)->drawable.height, \
+                            (w)->dfb_id
+
+#define GDKDFB_REGION_FORM  "%4d,%4d-%4dx%4d (%ld boxes)"
+#define GDKDFB_REGION_V(r)  GDKDFB_RECTANGLE_VALS_FROM_BOX(&((r)->extents)), (r)->numRects
 
 typedef struct
 {
@@ -186,8 +174,8 @@
 
 typedef struct
 {
-  GdkVisual              visual;
-  DFBSurfacePixelFormat  format;
+  GdkVisual             visual;
+  DFBSurfacePixelFormat format;
 } GdkVisualDirectFB;
 
 typedef struct
@@ -195,127 +183,229 @@
   IDirectFBSurface *surface;
 } GdkImageDirectFB;
 
-
 #define GDK_TYPE_GC_DIRECTFB       (gdk_gc_directfb_get_type ())
 #define GDK_GC_DIRECTFB(object)    (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_GC_DIRECTFB, GdkGCDirectFB))
 #define GDK_IS_GC_DIRECTFB(object) (G_TYPE_CHECK_INSTANCE_TYPE ((object), GDK_TYPE_GC_DIRECTFB))
 
 typedef struct
 {
-  GdkGC             parent_instance;
+  GdkGC           parent_instance;
 
-  GdkRegion        *clip_region;
+  GdkRegion       clip_region;
 
-  GdkGCValuesMask   values_mask;
-  GdkGCValues       values;
+  GdkGCValuesMask values_mask;
+  GdkGCValues     values;
 } GdkGCDirectFB;
 
 typedef struct
 {
-  GdkGCClass        parent_class;
+  GdkGCClass parent_class;
 } GdkGCDirectFBClass;
 
-GType     gdk_gc_directfb_get_type (void);
+GType          gdk_gc_directfb_get_type          (void);
 
-GdkGC *  _gdk_directfb_gc_new      (GdkDrawable     *drawable,
-                                    GdkGCValues     *values,
-                                    GdkGCValuesMask  values_mask);
-
-GdkImage* _gdk_directfb_copy_to_image (GdkDrawable  *drawable,
-                                       GdkImage     *image,
-                                       gint          src_x,
-                                       gint          src_y,
-                                       gint          dest_x,
-                                       gint          dest_y,
-                                       gint          width,
-                                       gint          height);
-
-void       gdk_directfb_event_windows_add (GdkWindow *window);
-#if (DIRECTFB_MAJOR_VERSION >= 1)
-void       gdk_directfb_event_windows_remove (GdkWindow *window);
-#endif
-
-GdkGrabStatus gdk_directfb_pointer_grab   (GdkWindow           *window,
-                                           gint                 owner_events,
-                                           GdkEventMask         event_mask,
-                                           GdkWindow           *confine_to,
-                                           GdkCursor           *cursor,
-                                           guint32              time,
-                                           gboolean             implicit_grab);
-void          gdk_directfb_pointer_ungrab (guint32              time,
-                                           gboolean             implicit_grab);
-
-guint32       gdk_directfb_get_time       (void);
-
-GdkWindow * gdk_directfb_pointer_event_window  (GdkWindow    *window,
-                                                GdkEventType  type);
-GdkWindow * gdk_directfb_keyboard_event_window (GdkWindow    *window,
-                                                GdkEventType  type);
-GdkWindow * gdk_directfb_other_event_window    (GdkWindow    *window,
-                                                GdkEventType  type);
-void       _gdk_selection_window_destroyed    (GdkWindow       *window);
-
-void       _gdk_directfb_move_resize_child (GdkWindow *window,
-                                            gint       x,
-                                            gint       y,
-                                            gint       width,
-                                            gint       height);
-
-GdkWindow * gdk_directfb_child_at          (GdkWindow *window,
-                                            gint      *x,
-                                            gint      *y);
-
-GdkWindow * gdk_directfb_window_find_focus (void);
-
-void        gdk_directfb_change_focus      (GdkWindow *new_focus_window);
-
-void        gdk_directfb_mouse_get_info    (gint            *x,
-                                            gint            *y,
-                                            GdkModifierType *mask);
+GdkGC         *gdk_directfb_gc_new               (GdkDrawable     *drawable,
+                                                  GdkGCValues     *values,
+                                                  GdkGCValuesMask  values_mask);
+
+void           gdk_directfb_clip_region          (GdkDrawable     *drawable,
+                                                  GdkGC           *gc,
+                                                  GdkRectangle    *draw_rect,
+                                                  GdkRegion       *ret_clip);
+GdkImage      *gdk_directfb_copy_to_image        (GdkDrawable     *drawable,
+                                                  GdkImage        *image,
+                                                  gint             src_x,
+                                                  gint             src_y,
+                                                  gint             dest_x,
+                                                  gint             dest_y,
+                                                  gint             width,
+                                                  gint             height);
+
+void           gdk_directfb_event_windows_add    (GdkWindow       *window);
+void           gdk_directfb_event_windows_remove (GdkWindow       *window);
+
+GdkGrabStatus  gdk_directfb_pointer_grab         (GdkWindow       *window,
+                                                  gint             owner_events,
+                                                  GdkEventMask     event_mask,
+                                                  GdkWindow       *confine_to,
+                                                  GdkCursor       *cursor,
+                                                  guint32          time,
+                                                  gboolean         implicit);
+void           gdk_directfb_pointer_ungrab       (guint32          time,
+                                                  gboolean         implicit);
+
+guint32        gdk_directfb_get_time             (void);
+
+GdkGrabStatus  gdk_directfb_keyboard_grab        (GdkDisplay      *display,
+                                                  GdkWindow       *window,
+                                                  gint             owner_events,
+                                                  guint32          time);
+void           gdk_directfb_keyboard_ungrab      (GdkDisplay      *display,
+                                                   guint32          time);
+GdkWindow     *gdk_directfb_other_event_window   (GdkWindow       *window,
+                                                  GdkEventType     type);
+void           gdk_selection_window_destroyed    (GdkWindow       *window);
+
+void           gdk_directfb_move_resize_child    (GdkWindow       *window,
+                                                  gint             x,
+                                                  gint             y,
+                                                  gint             width,
+                                                  gint             height);
+
+GdkWindow     *gdk_directfb_child_at             (GdkWindow       *window,
+                                                  gint            *x,
+                                                  gint            *y);
+
+void           gdk_directfb_events_update_cursor (GdkWindow       *window);
+
+void           gdk_directfb_change_focus         (GdkWindow       *window);
+
+void           gdk_directfb_mouse_get_info       (gint            *x,
+                                                  gint            *y,
+                                                  GdkModifierType *mask);
 
 /**********************/
 /*  Global variables  */
 /**********************/
 
-extern GdkDisplayDFB *_gdk_display;
+/* Display object */
+extern GdkDisplay           *_gdk_display;
+extern GdkDisplayDFB        *_gdk_display_dfb;
+
+/* Root window */
+extern GdkWindow            *_gdk_root;
+
+/* Entered window */
+extern GdkWindow            *_gdk_directfb_mouse_window;
+
+/* Focused window */
+extern GdkWindow            *_gdk_directfb_keyboard_window;
 
 /* Pointer grab info */
-extern GdkWindow           * _gdk_directfb_pointer_grab_window;
+extern gboolean              _gdk_directfb_pointer_implicit_grab;
+extern GdkWindow            *_gdk_directfb_pointer_grab_window;
 extern gboolean              _gdk_directfb_pointer_grab_owner_events;
-extern GdkWindow           * _gdk_directfb_pointer_grab_confine;
+extern GdkWindow            *_gdk_directfb_pointer_grab_confine;
 extern GdkEventMask          _gdk_directfb_pointer_grab_events;
-extern GdkCursor           * _gdk_directfb_pointer_grab_cursor;
+extern GdkCursor            *_gdk_directfb_pointer_grab_cursor;
 
 /* Keyboard grab info */
-extern GdkWindow           * _gdk_directfb_keyboard_grab_window;
+extern GdkWindow            *_gdk_directfb_keyboard_grab_window;
 extern GdkEventMask          _gdk_directfb_keyboard_grab_events;
 extern gboolean              _gdk_directfb_keyboard_grab_owner_events;
 
-extern GdkScreen  *  _gdk_screen;
+/* Screen object */
+extern GdkScreen            *_gdk_screen;
+
+/* Input Device List */
+extern GdkDevice            *_gdk_core_pointer;
+extern GList                *_gdk_input_devices;
+
+/* Input Device State */
+extern GdkModifierType       _gdk_directfb_modifiers;
+extern int                   _gdk_directfb_mouse_x;
+extern int                   _gdk_directfb_mouse_y;
+
+/* Input Windows */
+extern GList                *_gdk_input_windows;
 
+/* Properties */
 extern GdkAtom               _gdk_selection_property;
 
 
-IDirectFBPalette * gdk_directfb_colormap_get_palette (GdkColormap *colormap);
+IDirectFBPalette *gdk_directfb_colormap_get_palette (GdkColormap *colormap);
 
 
-/* these are Linux-FB specific functions used for window decorations */
+/* these are specific functions used for window decorations */
 
-typedef gboolean (* GdkWindowChildChanged) (GdkWindow *window,
-                                            gint       x,
-                                            gint       y,
-                                            gint       width,
-                                            gint       height,
-                                            gpointer   user_data);
-typedef void     (* GdkWindowChildGetPos)  (GdkWindow *window,
-                                            gint      *x,
-                                            gint      *y,
-                                            gpointer   user_data);
-
-void gdk_fb_window_set_child_handler (GdkWindow              *window,
-                                      GdkWindowChildChanged  changed,
-                                      GdkWindowChildGetPos   get_pos,
-                                      gpointer               user_data);
+typedef gboolean (*GdkWindowChildChanged) (GdkWindow *window,
+                                           gint       x,
+                                           gint       y,
+                                           gint       width,
+                                           gint       height,
+                                           gpointer   user_data);
+typedef void     (*GdkWindowChildGetPos)  (GdkWindow *window,
+                                           gint      *x,
+                                           gint      *y,
+                                           gpointer   user_data);
+
+/* Utilities for avoiding mallocs */
+
+static inline void
+temp_region_init_copy (GdkRegion       *region,
+                       const GdkRegion *source)
+{
+  if (region != source) /*  don't want to copy to itself */
+    {
+      if (region->size < source->numRects)
+        {
+          if (region->rects && region->rects != &region->extents)
+            g_free (region->rects);
+
+          region->rects = g_new (GdkRegionBox, source->numRects);
+          region->size  = source->numRects;
+        }
+
+      region->numRects = source->numRects;
+      region->extents  = source->extents;
+
+      memcpy (region->rects,
+              source->rects, source->numRects * sizeof (GdkRegionBox));
+    }
+}
+
+static inline void
+temp_region_init_rectangle (GdkRegion          *region,
+                            const GdkRectangle *rect)
+{
+     region->numRects   = 1;
+     region->rects      = &region->extents;
+     region->extents.x1 = rect->x;
+     region->extents.y1 = rect->y;
+     region->extents.x2 = rect->x + rect->width;
+     region->extents.y2 = rect->y + rect->height;
+     region->size       = 1;
+}
+
+static inline void
+temp_region_init_rectangle_vals (GdkRegion *region,
+                                 int        x,
+                                 int        y,
+                                 int        w,
+                                 int        h)
+{
+     region->numRects   = 1;
+     region->rects      = &region->extents;
+     region->extents.x1 = x;
+     region->extents.y1 = y;
+     region->extents.x2 = x + w;
+     region->extents.y2 = y + h;
+     region->size       = 1;
+}
+
+static inline void
+temp_region_reset (GdkRegion *region)
+{
+     if (region->size > 32 &&
+         region->rects && region->rects != &region->extents) {
+          g_free (region->rects);
+
+          region->size  = 1;
+          region->rects = &region->extents;
+     }
+
+     region->numRects = 0;
+}
+
+static inline void
+temp_region_deinit (GdkRegion *region)
+{
+     if (region->rects && region->rects != &region->extents) {
+          g_free (region->rects);
+          region->rects = NULL;
+     }
 
+     region->numRects = 0;
+}
 
 #endif /* __GDK_PRIVATE_DIRECTFB_H__ */
--- gtk+-2.12.12.orig/gdk/directfb/gdkproperty-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkproperty-directfb.c
@@ -30,24 +30,16 @@
  *            Sven Neumann <sven@convergence.de>
  */
 
-#include <config.h>
-#include "gdk.h"
-
-#include <string.h>
+#include "config.h"
 
 #include "gdkproperty.h"
-
-#include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
-
-#include "gdkinternals.h"
-
 #include "gdkalias.h"
 
 static GHashTable *names_to_atoms;
-static GPtrArray *atoms_to_names;
+static GPtrArray  *atoms_to_names;
 
-static const gchar xatoms_string[] = 
+static const gchar xatoms_string[] =
   /* These are all the standard predefined X atoms */
   "NONE\0"
   "PRIMARY\0"
@@ -121,11 +113,11 @@
 ;
 
 static const gint xatoms_offset[] = {
-    0,   5,  13,  23,  27,  32,  39,  48,  57,  64,  76,  88, 
-  100, 112, 124, 136, 148, 160, 169, 174, 182, 189, 195, 205, 
-  222, 236, 249, 262, 278, 291, 305, 317, 324, 333, 340, 351, 
-  360, 378, 391, 404, 412, 428, 442, 456, 466, 477, 487, 497, 
-  511, 525, 537, 549, 568, 588, 605, 623, 636, 645, 656, 663, 
+    0,   5,  13,  23,  27,  32,  39,  48,  57,  64,  76,  88,
+  100, 112, 124, 136, 148, 160, 169, 174, 182, 189, 195, 205,
+  222, 236, 249, 262, 278, 291, 305, 317, 324, 333, 340, 351,
+  360, 378, 391, 404, 412, 428, 442, 456, 466, 477, 487, 497,
+  511, 525, 537, 549, 568, 588, 605, 623, 636, 645, 656, 663,
   674, 685, 695, 702, 712, 724, 734, 745, 754
 };
 
@@ -135,7 +127,7 @@
 ensure_atom_tables (void)
 {
   int i;
-  
+
   if (names_to_atoms)
     return;
 
@@ -144,34 +136,43 @@
 
   for (i = 0; i < G_N_ELEMENTS (xatoms_offset); i++)
     {
-      g_hash_table_insert(names_to_atoms, (gchar *)xatoms_string + xatoms_offset[i], GINT_TO_POINTER (i));
-      g_ptr_array_add(atoms_to_names, (gchar *)xatoms_string + xatoms_offset[i]);
+      g_hash_table_insert (names_to_atoms,
+                           (gchar *) xatoms_string + xatoms_offset[i],
+                           GINT_TO_POINTER (i));
+
+      g_ptr_array_add (atoms_to_names,
+                       (gchar *) xatoms_string + xatoms_offset[i]);
     }
 }
 
 static GdkAtom
-intern_atom_internal (const gchar *atom_name, gboolean allocate)
+intern_atom_internal (const gchar *atom_name,
+                      gboolean     allocate)
 {
-  gpointer result;
-  gchar *name;
+  gpointer  result;
+  gchar    *name;
+
   g_return_val_if_fail (atom_name != NULL, GDK_NONE);
 
   ensure_atom_tables ();
-  
+
   if (g_hash_table_lookup_extended (names_to_atoms, atom_name, NULL, &result))
     return result;
-  
+
   result = GINT_TO_POINTER (atoms_to_names->len);
-  name = allocate ? g_strdup (atom_name) : (gchar *)atom_name;
-  g_hash_table_insert(names_to_atoms, name, result);
-  g_ptr_array_add(atoms_to_names, name);
-  
-  return result;  
+
+  name = allocate ? g_strdup (atom_name) : (gchar *) atom_name;
+
+  g_hash_table_insert (names_to_atoms, name, result);
+
+  g_ptr_array_add (atoms_to_names, name);
+
+  return result;
 }
 
 GdkAtom
 gdk_atom_intern (const gchar *atom_name,
-		 gboolean     only_if_exists)
+                 gboolean     only_if_exists)
 {
   return intern_atom_internal (atom_name, TRUE);
 }
@@ -182,19 +183,18 @@
   return intern_atom_internal (atom_name, FALSE);
 }
 
-
 gchar *
 gdk_atom_name (GdkAtom atom)
 {
   if (!atoms_to_names)
     return NULL;
-    
+
   if (GPOINTER_TO_INT (atom) >= atoms_to_names->len)
     return NULL;
+
   return g_strdup(g_ptr_array_index (atoms_to_names, GPOINTER_TO_INT (atom)));
 }
 
-
 static void
 gdk_property_delete_2 (GdkWindow         *window,
                        GdkAtom            property,
@@ -241,16 +241,16 @@
 }
 
 gboolean
-gdk_property_get (GdkWindow   *window,
-                  GdkAtom      property,
-                  GdkAtom      type,
-                  gulong       offset,
-                  gulong       length,
-                  gint         pdelete,
-                  GdkAtom     *actual_property_type,
-                  gint        *actual_format_type,
-                  gint        *actual_length,
-                  guchar     **data)
+gdk_property_get (GdkWindow  *window,
+                  GdkAtom     property,
+                  GdkAtom     type,
+                  gulong      offset,
+                  gulong      length,
+                  gint        pdelete,
+                  GdkAtom    *actual_property_type,
+                  gint       *actual_format_type,
+                  gint       *actual_length,
+                  guchar    **data)
 {
   GdkWindowImplDirectFB *impl;
   GdkWindowProperty     *prop;
@@ -383,8 +383,8 @@
       break;
     }
 
-  g_hash_table_insert (impl->properties,
-                       GUINT_TO_POINTER (property), new_prop);
+  g_hash_table_insert (impl->properties, GUINT_TO_POINTER (property), new_prop);
+
   g_free (prop);
 
   event_window = gdk_directfb_other_event_window (window, GDK_PROPERTY_NOTIFY);
@@ -396,5 +396,6 @@
       event->property.state = GDK_PROPERTY_NEW_VALUE;
     }
 }
+
 #define __GDK_PROPERTY_X11_C__
 #include "gdkaliasdef.c"
--- gtk+-2.12.12.orig/gdk/directfb/gdkscreen-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkscreen-directfb.c
@@ -32,21 +32,18 @@
  */
 
 #include "config.h"
+
 #include "gdk.h"
-#include "gdkscreen.h"
 #include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
-
-#include "gdkinternals.h"
 #include "gdkalias.h"
 
-
 static GdkColormap *default_colormap = NULL;
 
 GdkDisplay *
 gdk_screen_get_display (GdkScreen *screen)
 {
-  return GDK_DISPLAY_OBJECT(_gdk_display);
+  return GDK_DISPLAY_OBJECT (_gdk_display_dfb);
 }
 
 GdkWindow *
@@ -63,7 +60,7 @@
 
 void
 gdk_screen_set_default_colormap (GdkScreen   *screen,
-				 GdkColormap *colormap)
+                                 GdkColormap *colormap)
 {
   GdkColormap *old_colormap;
 
@@ -88,8 +85,8 @@
 
 void
 gdk_screen_get_monitor_geometry (GdkScreen    *screen,
-				 gint          num_monitor,
-				 GdkRectangle *dest)
+                                 gint          num_monitor,
+                                 GdkRectangle *dest)
 {
   g_return_if_fail (GDK_IS_SCREEN (screen));
   g_return_if_fail (dest != NULL);
@@ -108,10 +105,9 @@
   return 0;
 }
 
-
 gchar *
 _gdk_windowing_substitute_screen_number (const gchar *display_name,
-					 int          screen_number)
+                                         int          screen_number)
 {
   return g_strdup (display_name);
 }
@@ -127,7 +123,7 @@
 {
   DFBDisplayLayerConfig dlc;
 
-  _gdk_display->layer->GetConfiguration (_gdk_display->layer, &dlc);
+  _gdk_display_dfb->layer->GetConfiguration (_gdk_display_dfb->layer, &dlc);
 
   return dlc.width;
 }
@@ -137,7 +133,7 @@
 {
   DFBDisplayLayerConfig dlc;
 
-  _gdk_display->layer->GetConfiguration (_gdk_display->layer, &dlc);
+  _gdk_display_dfb->layer->GetConfiguration (_gdk_display_dfb->layer, &dlc);
 
   return dlc.height;
 }
@@ -145,45 +141,31 @@
 gint
 gdk_screen_get_width_mm (GdkScreen *screen)
 {
-  static gboolean first_call = TRUE;
   DFBDisplayLayerConfig dlc;
 
-  if (first_call)
-    {
-      g_message
-        ("gdk_screen_width_mm() assumes a screen resolution of 72 dpi");
-      first_call = FALSE;
-    }
-
-  _gdk_display->layer->GetConfiguration (_gdk_display->layer, &dlc);
+  _gdk_display_dfb->layer->GetConfiguration (_gdk_display_dfb->layer, &dlc);
 
-  return (dlc.width * 254) / 720;
+  return (dlc.width * 25.4) / GDK_DIRECTFB_SCREEN_RESOLUTION;
 }
 
 gint
 gdk_screen_get_height_mm (GdkScreen *screen)
 {
-  static gboolean first_call = TRUE;
   DFBDisplayLayerConfig dlc;
 
-  if (first_call)
-    {
-      g_message
-        ("gdk_screen_height_mm() assumes a screen resolution of 72 dpi");
-      first_call = FALSE;
-    }
-
-  _gdk_display->layer->GetConfiguration (_gdk_display->layer, &dlc);
+  _gdk_display_dfb->layer->GetConfiguration (_gdk_display_dfb->layer, &dlc);
 
-  return (dlc.height * 254) / 720;
+  return (dlc.height * 25.4) / GDK_DIRECTFB_SCREEN_RESOLUTION;
 }
 
 GdkVisual *
 gdk_screen_get_rgba_visual (GdkScreen *screen)
 {
   static GdkVisual *rgba_visual;
-  if( !rgba_visual )
+
+  if (!rgba_visual)
     rgba_visual = gdk_directfb_visual_by_format(DSPF_ARGB);
+
   return rgba_visual;
 }
 
@@ -191,8 +173,11 @@
 gdk_screen_get_rgba_colormap (GdkScreen *screen)
 {
   static GdkColormap *rgba_colormap;
-  if( !rgba_colormap && gdk_screen_get_rgba_visual(screen) )
-    rgba_colormap = gdk_colormap_new (gdk_screen_get_rgba_visual(screen),FALSE);
+
+  if (!rgba_colormap && gdk_screen_get_rgba_visual (screen))
+    rgba_colormap = gdk_colormap_new (gdk_screen_get_rgba_visual (screen),
+                                      FALSE);
+
   return rgba_colormap;
 }
 
@@ -215,9 +200,10 @@
 gboolean
 gdk_screen_is_composited (GdkScreen *screen)
 {
-   g_return_val_if_fail (GDK_IS_SCREEN (screen), FALSE);
-   return FALSE;
-} 
+  g_return_val_if_fail (GDK_IS_SCREEN (screen), FALSE);
+
+  return TRUE;
+}
 
 #define __GDK_SCREEN_X11_C__
 #include "gdkaliasdef.c"
--- gtk+-2.12.12.orig/gdk/directfb/gdkselection-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkselection-directfb.c
@@ -32,24 +32,17 @@
 
 #include "config.h"
 
-#include <string.h>
-
 #include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
-
 #include "gdkproperty.h"
 #include "gdkselection.h"
-#include "gdkprivate.h"
 #include "gdkalias.h"
 
-
-typedef struct _OwnerInfo OwnerInfo;
-
-struct _OwnerInfo
+typedef struct _OwnerInfo
 {
   GdkAtom    selection;
   GdkWindow *owner;
-};
+} OwnerInfo;
 
 GSList *owner_list = NULL;
 
@@ -59,7 +52,7 @@
  * low code solution
  */
 void
-_gdk_selection_window_destroyed (GdkWindow *window)
+gdk_selection_window_destroyed (GdkWindow *window)
 {
   GSList *tmp_list = owner_list;
 
@@ -70,10 +63,10 @@
       tmp_list = tmp_list->next;
 
       if (info->owner == window)
-	{
-	  owner_list = g_slist_remove (owner_list, info);
-	  g_free (info);
-	}
+        {
+          owner_list = g_slist_remove (owner_list, info);
+          g_free (info);
+        }
     }
 }
 
@@ -92,11 +85,11 @@
     {
       info = tmp_list->data;
       if (info->selection == selection)
-	{
-	  owner_list = g_slist_remove (owner_list, info);
-	  g_free (info);
-	  break;
-	}
+        {
+          owner_list = g_slist_remove (owner_list, info);
+          g_free (info);
+          break;
+        }
       tmp_list = tmp_list->next;
     }
 
@@ -124,19 +117,20 @@
     {
       info = tmp_list->data;
       if (info->selection == selection)
-	{
-	  return info->owner;
-	}
+        {
+          return info->owner;
+        }
       tmp_list = tmp_list->next;
     }
+
   return NULL;
 }
 
 void
 gdk_selection_convert (GdkWindow *requestor,
-		       GdkAtom    selection,
-		       GdkAtom    target,
-		       guint32    time)
+                       GdkAtom    selection,
+                       GdkAtom    target,
+                       guint32    time)
 {
   GdkEvent  *event;
   GdkWindow *owner;
@@ -149,14 +143,13 @@
       event_window = gdk_directfb_other_event_window (owner,
                                                       GDK_SELECTION_REQUEST);
       if (event_window)
-	{
-	  event = gdk_directfb_event_make (event_window,
-                                           GDK_SELECTION_REQUEST);
-	  event->selection.requestor = GDK_WINDOW_DFB_ID (requestor);
-	  event->selection.selection = selection;
-	  event->selection.target    = target;
-	  event->selection.property  = _gdk_selection_property;
-	}
+        {
+          event = gdk_directfb_event_make (event_window, GDK_SELECTION_REQUEST);
+          event->selection.requestor = GDK_WINDOW_DFB_ID (requestor);
+          event->selection.selection = selection;
+          event->selection.target    = target;
+          event->selection.property  = _gdk_selection_property;
+        }
     }
   else
     {
@@ -164,34 +157,30 @@
        * generates a SelectionNotify event to the requestor with property None.
        */
       gdk_selection_send_notify (GDK_WINDOW_DFB_ID (requestor),
-				 selection,
-				 target,
-				 GDK_NONE,
-				 0);
+                                 selection,
+                                 target,
+                                 GDK_NONE,
+                                 0);
     }
 }
 
 gint
 gdk_selection_property_get (GdkWindow  *requestor,
-			    guchar    **data,
-			    GdkAtom    *ret_type,
-			    gint       *ret_format)
-{
-  guchar *t = NULL;
-  GdkAtom prop_type;
-  gint prop_format;
-  gint prop_len;
+                            guchar    **data,
+                            GdkAtom    *ret_type,
+                            gint       *ret_format)
+{
+  guchar  *t = NULL;
+  GdkAtom  prop_type;
+  gint     prop_format;
+  gint     prop_len;
 
   g_return_val_if_fail (requestor != NULL, 0);
   g_return_val_if_fail (GDK_IS_WINDOW (requestor), 0);
 
   if (!gdk_property_get (requestor,
-			 _gdk_selection_property,
-			 0/*AnyPropertyType?*/,
-			 0, 0,
-			 FALSE,
-			 &prop_type, &prop_format, &prop_len,
-			 &t))
+                         _gdk_selection_property, GDK_NONE, 0, 0,
+                         FALSE, &prop_type, &prop_format, &prop_len, &t))
     {
       *data = NULL;
       return 0;
@@ -203,12 +192,8 @@
     *ret_format = prop_format;
 
   if (!gdk_property_get (requestor,
-			 _gdk_selection_property,
-			 0/*AnyPropertyType?*/,
-			 0, prop_len + 1,
-			 FALSE,
-			 &prop_type, &prop_format, &prop_len,
-			 &t))
+                         _gdk_selection_property, GDK_NONE, 0, prop_len + 1,
+                         FALSE, &prop_type, &prop_format, &prop_len, &t))
     {
       *data = NULL;
       return 0;
@@ -219,7 +204,6 @@
   return prop_len;
 }
 
-
 void
 gdk_selection_send_notify_for_display (GdkDisplay *display,
                                        guint32     requestor,
@@ -231,7 +215,7 @@
   GdkEvent  *event;
   GdkWindow *event_window;
 
-  event_window = gdk_window_lookup ((GdkNativeWindow) requestor);
+  event_window = gdk_window_lookup (requestor);
 
   if (!event_window)
     return;
@@ -243,21 +227,22 @@
     {
       event = gdk_directfb_event_make (event_window, GDK_SELECTION_NOTIFY);
       event->selection.selection = selection;
-      event->selection.target = target;
-      event->selection.property = property;
-      event->selection.requestor = (GdkNativeWindow) requestor;
+      event->selection.target    = target;
+      event->selection.property  = property;
+      event->selection.requestor = requestor;
     }
 }
 
 gint
-gdk_text_property_to_text_list_for_display (GdkDisplay      *display,
-                                            GdkAtom          encoding,
-                                            gint             format,
-                                            const guchar    *text,
-                                            gint             length,
-                                            gchar         ***list)
+gdk_text_property_to_text_list_for_display (GdkDisplay     *display,
+                                            GdkAtom         encoding,
+                                            gint            format,
+                                            const guchar   *text,
+                                            gint            length,
+                                            gchar        ***list)
 {
-  g_warning ("gdk_text_property_to_text_list() not implemented\n");
+  D_UNIMPLEMENTED();
+
   return 0;
 }
 
@@ -265,7 +250,8 @@
 gdk_free_text_list (gchar **list)
 {
   g_return_if_fail (list != NULL);
-  g_warning ("gdk_free_text_list() not implemented\n");
+
+  D_UNIMPLEMENTED();
 }
 
 gint
@@ -276,50 +262,25 @@
                                          guchar      **ctext,
                                          gint         *length)
 {
-  g_warning ("gdk_string_to_compound_text() not implemented\n");
+  D_UNIMPLEMENTED();
+
   return 0;
 }
 
 void
 gdk_free_compound_text (guchar *ctext)
 {
-  g_warning ("gdk_free_compound_text() not implemented\n");
+  D_UNIMPLEMENTED();
 }
 
-/**
- * gdk_utf8_to_string_target:
- * @str: a UTF-8 string
- *
- * Convert an UTF-8 string into the best possible representation
- * as a STRING. The representation of characters not in STRING
- * is not specified; it may be as pseudo-escape sequences
- * \x{ABCD}, or it may be in some other form of approximation.
- *
- * Return value: the newly allocated string, or %NULL if the
- *               conversion failed. (It should not fail for
- *               any properly formed UTF-8 string.)
- **/
 gchar *
 gdk_utf8_to_string_target (const gchar *str)
 {
-  g_warning ("gdk_utf8_to_string_target() not implemented\n");
+  D_UNIMPLEMENTED();
+
   return 0;
 }
 
-/**
- * gdk_utf8_to_compound_text:
- * @str:      a UTF-8 string
- * @encoding: location to store resulting encoding
- * @format:   location to store format of the result
- * @ctext:    location to store the data of the result
- * @length:   location to store the length of the data
- *            stored in @ctext
- *
- * Convert from UTF-8 to compound text.
- *
- * Return value: %TRUE if the conversion succeeded, otherwise
- *               false.
- **/
 gboolean
 gdk_utf8_to_compound_text_for_display (GdkDisplay   *display,
                                        const gchar  *str,
@@ -328,23 +289,24 @@
                                        guchar      **ctext,
                                        gint         *length)
 {
-  g_warning ("gdk_utf8_to_compound_text() not implemented\n");
-  return 0;
+  D_UNIMPLEMENTED();
+
+  return FALSE;
 }
 
 static gint
-make_list (const gchar  *text,
-	   gint          length,
-	   gboolean      latin1,
-	   gchar      ***list)
-{
-  GSList *strings = NULL;
-  gint n_strings = 0;
-  gint i;
+make_list (const gchar   *text,
+           gint           length,
+           gboolean       latin1,
+           gchar       ***list)
+{
+  GSList      *strings   = NULL;
+  gint         n_strings = 0;
+  gint         i;
   const gchar *p = text;
   const gchar *q;
-  GSList *tmp_list;
-  GError *error = NULL;
+  GSList      *tmp_list;
+  GError      *error = NULL;
 
   while (p < text + length)
     {
@@ -352,29 +314,28 @@
 
       q = p;
       while (*q && q < text + length)
-	q++;
+        q++;
 
       if (latin1)
-	{
-	  str = g_convert (p, q - p,
-			   "UTF-8", "ISO-8859-1",
-			   NULL, NULL, &error);
-
-	  if (!str)
-	    {
-	      g_warning ("Error converting selection from STRING: %s",
-			 error->message);
-	      g_error_free (error);
-	    }
-	}
+        {
+          str = g_convert (p, q - p, "UTF-8", "ISO-8859-1",
+                           NULL, NULL, &error);
+
+          if (!str)
+            {
+              g_warning ("Error converting selection from STRING: %s",
+                         error->message);
+              g_error_free (error);
+            }
+        }
       else
-	str = g_strndup (p, q - p);
+        str = g_strndup (p, q - p);
 
       if (str)
-	{
-	  strings = g_slist_prepend (strings, str);
-	  n_strings++;
-	}
+        {
+          strings = g_slist_prepend (strings, str);
+          n_strings++;
+        }
 
       p = q + 1;
     }
@@ -389,9 +350,9 @@
   while (tmp_list)
     {
       if (list)
-	(*list)[--i] = tmp_list->data;
+        (*list)[--i] = tmp_list->data;
       else
-	g_free (tmp_list->data);
+        g_free (tmp_list->data);
 
       tmp_list = tmp_list->next;
     }
@@ -401,22 +362,6 @@
   return n_strings;
 }
 
-
-/**
- * gdk_text_property_to_utf8_list:
- * @encoding: an atom representing the encoding of the text
- * @format:   the format of the property
- * @text:     the text to convert
- * @length:   the length of @text, in bytes
- * @list:     location to store the list of strings or %NULL. The
- *            list should be freed with g_strfreev().
- *
- * Convert a text property in the giving encoding to
- * a list of UTF-8 strings.
- *
- * Return value: the number of strings in the resulting
- *               list.
- **/
 gint
 gdk_text_property_to_utf8_list_for_display (GdkDisplay     *display,
                                             GdkAtom         encoding,
@@ -430,62 +375,60 @@
 
   if (encoding == GDK_TARGET_STRING)
     {
-      return make_list ((gchar *)text, length, TRUE, list);
+      return make_list ((gchar *) text, length, TRUE, list);
     }
   else if (encoding == gdk_atom_intern ("UTF8_STRING", FALSE))
     {
-      return make_list ((gchar *)text, length, FALSE, list);
+      return make_list ((gchar *) text, length, FALSE, list);
     }
   else
     {
-      gchar **local_list;
-      gint local_count;
-      gint i;
-      const gchar *charset = NULL;
-      gboolean need_conversion = !g_get_charset (&charset);
-      gint count = 0;
-      GError *error = NULL;
+      gchar       **local_list;
+      gint          local_count;
+      gint          i;
+      const gchar  *charset = NULL;
+      gboolean      need_conversion = !g_get_charset (&charset);
+      gint          count = 0;
+      GError       *error = NULL;
 
-      /* Probably COMPOUND text, we fall back to Xlib routines
+      /* Probably COMPOUND text
        */
       local_count = gdk_text_property_to_text_list (encoding,
-						    format,
-						    text,
-						    length,
-						    &local_list);
+                                                    format,
+                                                    text,
+                                                    length,
+                                                    &local_list);
       if (list)
-	*list = g_new (gchar *, local_count + 1);
+        *list = g_new (gchar *, local_count + 1);
 
       for (i = 0; i < local_count; i++)
-	{
-	  /* list contains stuff in our default encoding
-	   */
-	  if (need_conversion)
-	    {
-	      gchar *utf = g_convert (local_list[i], -1,
-				      "UTF-8", charset,
-				      NULL, NULL, &error);
-	      if (utf)
-		{
-		  if (list)
-		    (*list)[count++] = utf;
-		  else
-		    g_free (utf);
-		}
-	      else
-		{
-		  g_warning ("Error converting to UTF-8 from '%s': %s",
-			     charset, error->message);
-		  g_error_free (error);
-		  error = NULL;
-		}
-	    }
-	  else
-	    {
-	      if (list)
-		(*list)[count++] = g_strdup (local_list[i]);
-	    }
-	}
+        {
+          /* list contains stuff in our default encoding
+           */
+          if (need_conversion)
+            {
+              gchar *utf = g_convert (local_list[i], -1, "UTF-8", charset,
+                                      NULL, NULL, &error);
+              if (utf)
+                {
+                  if (list)
+                    (*list)[count++] = utf;
+                  else
+                    g_free (utf);
+                }
+              else
+                {
+                  g_warning ("Error converting to UTF-8 from '%s': %s",
+                             charset, error->message);
+                  g_error_free (error);
+                }
+            }
+          else
+            {
+              if (list)
+                (*list)[count++] = g_strdup (local_list[i]);
+            }
+        }
 
       gdk_free_text_list (local_list);
       (*list)[count] = NULL;
--- gtk+-2.12.12.orig/gdk/directfb/gdkspawn-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkspawn-directfb.c
@@ -19,86 +19,81 @@
  * Authors: Mark McLoughlin <mark@skynet.ie>
  */
 
-#include <config.h>
-#include <glib.h>
-#include "gdk.h"
+#include "config.h"
+
 #include "gdkspawn.h"
-#include "gdkprivate.h"
 #include "gdkalias.h"
 
-
 gboolean
 gdk_spawn_on_screen (GdkScreen             *screen,
-		     const gchar           *working_directory,
-		     gchar                **argv,
-		     gchar                **envp,
-		     GSpawnFlags            flags,
-		     GSpawnChildSetupFunc   child_setup,
-		     gpointer               user_data,
-		     gint                  *child_pid,
-		     GError               **error)
+                     const gchar           *working_directory,
+                     gchar                **argv,
+                     gchar                **envp,
+                     GSpawnFlags            flags,
+                     GSpawnChildSetupFunc   child_setup,
+                     gpointer               user_data,
+                     gint                  *child_pid,
+                     GError               **error)
 {
   g_return_val_if_fail (GDK_IS_SCREEN (screen), FALSE);
 
   return g_spawn_async (working_directory,
-			argv,
-			envp,
-			flags,
-			child_setup,
-			user_data,
-			child_pid,
-			error);
+                        argv,
+                        envp,
+                        flags,
+                        child_setup,
+                        user_data,
+                        child_pid,
+                        error);
 }
 
 gboolean
-gdk_spawn_on_screen_with_pipes (GdkScreen            *screen,
-				const gchar          *working_directory,
-				gchar               **argv,
-				gchar               **envp,
-				GSpawnFlags           flags,
-				GSpawnChildSetupFunc  child_setup,
-				gpointer              user_data,
-				gint                 *child_pid,
-				gint                 *standard_input,
-				gint                 *standard_output,
-				gint                 *standard_error,
-				GError              **error)
+gdk_spawn_on_screen_with_pipes (GdkScreen             *screen,
+                                const gchar           *working_directory,
+                                gchar                **argv,
+                                gchar                **envp,
+                                GSpawnFlags            flags,
+                                GSpawnChildSetupFunc   child_setup,
+                                gpointer               user_data,
+                                gint                  *child_pid,
+                                gint                  *standard_input,
+                                gint                  *standard_output,
+                                gint                  *standard_error,
+                                GError               **error)
 {
   g_return_val_if_fail (GDK_IS_SCREEN (screen), FALSE);
 
   return g_spawn_async_with_pipes (working_directory,
-				   argv,
-				   envp,
-				   flags,
-				   child_setup,
-				   user_data,
-				   child_pid,
-				   standard_input,
-				   standard_output,
-				   standard_error,
-				   error);
+                                   argv,
+                                   envp,
+                                   flags,
+                                   child_setup,
+                                   user_data,
+                                   child_pid,
+                                   standard_input,
+                                   standard_output,
+                                   standard_error,
+                                   error);
 }
 
 gboolean
 gdk_spawn_command_line_on_screen (GdkScreen    *screen,
-				  const gchar  *command_line,
-				  GError      **error)
+                                  const gchar  *command_line,
+                                  GError      **error)
 {
   gchar    **argv = NULL;
   gboolean   retval;
 
   g_return_val_if_fail (command_line != NULL, FALSE);
 
-  if (!g_shell_parse_argv (command_line,
-			   NULL, &argv,
-			   error))
+  if (!g_shell_parse_argv (command_line, NULL, &argv, error))
     return FALSE;
 
   retval = gdk_spawn_on_screen (screen,
-				NULL, argv, NULL,
-				G_SPAWN_SEARCH_PATH,
-				NULL, NULL, NULL,
-				error);
+                                NULL, argv, NULL,
+                                G_SPAWN_SEARCH_PATH,
+                                NULL, NULL, NULL,
+                                error);
   g_strfreev (argv);
 
   return retval;
--- gtk+-2.12.12.orig/gdk/directfb/gdkvisual-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkvisual-directfb.c
@@ -34,40 +34,33 @@
 
 #include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
-
 #include "gdkscreen.h"
-#include "gdkvisual.h"
 #include "gdkalias.h"
 
+D_DEBUG_DOMAIN( GDKDFB_Visual, "GDKDFB/Visual", "GDK DirectFB Visual" );
 
 struct _GdkVisualClass
 {
   GObjectClass parent_class;
 };
 
-
-static void                gdk_visual_decompose_mask  (gulong   mask,
-                                                       gint    *shift,
-                                                       gint    *prec);
-static GdkVisualDirectFB * gdk_directfb_visual_create (DFBSurfacePixelFormat  pixelformat);
-
+static GdkVisualDirectFB *
+gdk_directfb_visual_create (DFBSurfacePixelFormat  pixelformat);
 
 static DFBSurfacePixelFormat formats[] =
 {
-  DSPF_ARGB,
-  DSPF_LUT8,
   DSPF_RGB32,
-  DSPF_RGB24,
+  DSPF_ARGB,
   DSPF_RGB16,
   DSPF_ARGB1555,
-  DSPF_RGB332
+  DSPF_LUT8,
+  DSPF_RGB332,
 };
 
-GdkVisual         * system_visual = NULL;
-static GdkVisualDirectFB * visuals[G_N_ELEMENTS (formats) + 1] = { NULL };
-static gint                available_depths[G_N_ELEMENTS (formats) + 1] = {0};
-static GdkVisualType       available_types[G_N_ELEMENTS (formats) + 1]  = {0};
-
+static GdkVisualDirectFB *system_visual;
+static GdkVisualDirectFB *visuals[G_N_ELEMENTS (formats) + 1] = { NULL };
+static gint               available_depths[G_N_ELEMENTS (formats) + 1] = {0};
+static GdkVisualType      available_types[G_N_ELEMENTS (formats) + 1]  = {0};
 
 static void
 gdk_visual_finalize (GObject *object)
@@ -112,17 +105,17 @@
 void
 _gdk_visual_init ()
 {
-  DFBResult              ret;
   DFBDisplayLayerConfig  dlc;
   DFBSurfaceDescription  desc;
   IDirectFBSurface      *dest;
   gint                   i, c;
 
+  D_DEBUG_AT( GDKDFB_Visual, "%s()\n", __FUNCTION__ );
 
-  _gdk_display->layer->GetConfiguration (_gdk_display->layer, &dlc);
-  g_assert( dlc.pixelformat != DSPF_UNKNOWN);
+  _gdk_display_dfb->layer->GetConfiguration (_gdk_display_dfb->layer, &dlc);
+  g_assert (dlc.pixelformat != DSPF_UNKNOWN);
 
-  dest = gdk_display_dfb_create_surface(_gdk_display,dlc.pixelformat,8,8);
+  dest = gdk_display_dfb_create_surface (_gdk_display_dfb,dlc.pixelformat, 8, 8);
   g_assert (dest != NULL);
 
   /* We could provide all visuals since DirectFB allows us to mix
@@ -143,118 +136,160 @@
       IDirectFBSurface    *src;
       DFBAccelerationMask  acc;
 
-      desc.flags = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
+      desc.flags       = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
       desc.width       = 8;
       desc.height      = 8;
       desc.pixelformat = formats[i];
-      //call direct so fail silently  is ok
-      if (_gdk_display->directfb->CreateSurface (_gdk_display->directfb,
-	 &desc, &src) != DFB_OK) 
+
+      /* call direct so fail silently is ok */
+      if (_gdk_display_dfb->directfb->CreateSurface (_gdk_display_dfb->directfb,
+                                                     &desc, &src) != DFB_OK)
         continue;
 
-      visuals[i] = gdk_directfb_visual_create (formats[i]);
+      visuals[c] = gdk_directfb_visual_create (formats[i]);
 
       dest->GetAccelerationMask (dest, src, &acc);
 
-      if (acc & DFXL_BLIT || formats[i] == dlc.pixelformat)
-        {
-            system_visual = GDK_VISUAL (visuals[c]);
-          c++;
-        }
+      if (formats[i] == dlc.pixelformat || (acc & DFXL_BLIT && !system_visual))
+        system_visual = visuals[c];
+
+      c++;
 
       src->Release (src);
     }
 
   dest->Release (dest);
 
-  //fallback to ARGB must be supported
   if (!system_visual)
     {
-       g_assert (visuals[DSPF_ARGB] != NULL);
-       system_visual = GDK_VISUAL(visuals[DSPF_ARGB]);
+      g_assert (GDK_IS_VISUAL (visuals[0]));
+
+      system_visual = visuals[0];
     }
 
   g_assert (system_visual != NULL);
+
+  D_INFO( "GDK/DirectFB: System visual %s\n", dfb_pixelformat_name (system_visual->format) );
 }
 
 gint
 gdk_visual_get_best_depth (void)
 {
-  return system_visual->depth;
+  D_DEBUG_AT( GDKDFB_Visual, "%s() -> %d\n", __FUNCTION__, system_visual->visual.depth );
+
+  return system_visual->visual.depth;
 }
 
 GdkVisualType
 gdk_visual_get_best_type (void)
 {
-  return system_visual->type;
+  D_DEBUG_AT( GDKDFB_Visual, "%s() -> %d\n", __FUNCTION__, system_visual->visual.type );
+
+  return system_visual->visual.type;
 }
 
-GdkVisual*
+GdkVisual *
 gdk_screen_get_system_visual (GdkScreen *screen)
 {
-  g_assert( system_visual);
-  return system_visual;
+  D_DEBUG_AT( GDKDFB_Visual, "%s( %p ) -> %p (%s)\n", __FUNCTION__,
+              screen, system_visual, dfb_pixelformat_name (system_visual->format) );
+
+  return GDK_VISUAL (system_visual);
 }
 
-GdkVisual*
+GdkVisual *
 gdk_visual_get_best (void)
 {
-  return system_visual;
+  D_DEBUG_AT( GDKDFB_Visual, "%s() -> %p (%s)\n", __FUNCTION__,
+              system_visual, dfb_pixelformat_name (system_visual->format) );
+
+  return GDK_VISUAL (system_visual);
 }
 
-GdkVisual*
+GdkVisual *
 gdk_visual_get_best_with_depth (gint depth)
 {
   gint i;
 
+  D_DEBUG_AT( GDKDFB_Visual, "%s( %d )\n", __FUNCTION__, depth );
+
   for (i = 0; visuals[i]; i++)
     {
-      if( visuals[i] ) {
-        GdkVisual *visual = GDK_VISUAL (visuals[i]);
+      if (visuals[i])
+        {
+          GdkVisual *visual = GDK_VISUAL (visuals[i]);
 
-        if (depth == visual->depth)
-            return visual;
-      }
+          if (depth == visual->depth)
+            {
+              D_DEBUG_AT( GDKDFB_Visual, "  -> returning %p (%s)\n",
+                          visuals[i], dfb_pixelformat_name (visuals[i]->format) );
+
+              return visual;
+            }
+        }
     }
 
+  D_DEBUG_AT( GDKDFB_Visual, "  -> returning NULL!\n" );
+
   return NULL;
 }
 
-GdkVisual*
+GdkVisual *
 gdk_visual_get_best_with_type (GdkVisualType visual_type)
 {
   gint i;
 
+  D_DEBUG_AT( GDKDFB_Visual, "%s( %d )\n", __FUNCTION__, visual_type );
+
   for (i = 0; visuals[i]; i++)
     {
-      if( visuals[i] ) {
-        GdkVisual *visual = GDK_VISUAL (visuals[i]);
+      if (visuals[i])
+        {
+          GdkVisual *visual = GDK_VISUAL (visuals[i]);
 
-        if (visual_type == visual->type)
-            return visual;
-      }
+          if (visual_type == visual->type)
+            {
+              D_DEBUG_AT( GDKDFB_Visual, "  -> returning %p (%s)\n",
+                          visuals[i], dfb_pixelformat_name (visuals[i]->format) );
+
+              return visual;
+            }
+        }
     }
 
+  D_DEBUG_AT( GDKDFB_Visual, "  -> returning NULL!\n" );
+
   return NULL;
 }
 
-GdkVisual*
+GdkVisual *
 gdk_visual_get_best_with_both (gint          depth,
                                GdkVisualType visual_type)
 {
   gint i;
 
+  D_DEBUG_AT( GDKDFB_Visual, "%s( %d, %d )\n", __FUNCTION__, depth, visual_type );
+
   for (i = 0; visuals[i]; i++)
     {
-      if( visuals[i] ) {
-        GdkVisual *visual = GDK_VISUAL (visuals[i]);
+      if (visuals[i])
+        {
+          GdkVisual *visual = GDK_VISUAL (visuals[i]);
 
-        if (depth == visual->depth && visual_type == visual->type)
-            return visual;
-      }
+          if (depth == visual->depth && visual_type == visual->type)
+            {
+              D_DEBUG_AT( GDKDFB_Visual, "  -> returning %p (%s)\n",
+                          visuals[i], dfb_pixelformat_name (visuals[i]->format) );
+
+              return visual;
+            }
+        }
     }
 
-  return system_visual;
+  D_DEBUG_AT( GDKDFB_Visual, "  -> not found! Returning %p (%s)\n",
+              system_visual, dfb_pixelformat_name (system_visual->format) );
+
+  return GDK_VISUAL (system_visual);
 }
 
 void
@@ -263,6 +298,8 @@
 {
   gint i;
 
+  D_DEBUG_AT( GDKDFB_Visual, "%s()\n", __FUNCTION__ );
+
   for (i = 0; available_depths[i]; i++)
     ;
 
@@ -276,6 +313,8 @@
 {
   gint i;
 
+  D_DEBUG_AT( GDKDFB_Visual, "%s()\n", __FUNCTION__ );
+
   for (i = 0; available_types[i]; i++)
     ;
 
@@ -289,11 +328,14 @@
   GList *list = NULL;
   gint   i;
 
+  D_DEBUG_AT( GDKDFB_Visual, "%s()\n", __FUNCTION__ );
+
   for (i = 0; visuals[i]; i++)
-   if( visuals[i] ) {
-        GdkVisual * vis = GDK_VISUAL(visuals[i]);
-        list = g_list_append (list,vis);
-   }
+    if (visuals[i])
+      {
+        GdkVisual *visual = GDK_VISUAL (visuals[i]);
+        list = g_list_append (list, visual);
+      }
 
   return list;
 }
@@ -319,28 +361,38 @@
 {
   gint i;
 
+  D_DEBUG_AT( GDKDFB_Visual, "%s( %s )\n", __FUNCTION__, dfb_pixelformat_name (pixel_format) );
+
   /* first check if one the registered visuals matches */
   for (i = 0; visuals[i]; i++)
-    if ( visuals[i] && visuals[i]->format == pixel_format)
-      return GDK_VISUAL (visuals[i]);
+    if (visuals[i] && visuals[i]->format == pixel_format)
+      {
+        D_DEBUG_AT( GDKDFB_Visual, "  -> returning %p (%s)\n",
+                    visuals[i], dfb_pixelformat_name (visuals[i]->format) );
+
+        return GDK_VISUAL (visuals[i]);
+      }
 
   /* none matched, try to create a new one for this pixel_format */
   {
     DFBSurfaceDescription  desc;
     IDirectFBSurface      *test;
 
-    desc.flags = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
+    desc.flags       = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
     desc.width       = 8;
     desc.height      = 8;
     desc.pixelformat = pixel_format;
 
-    if ( _gdk_display->directfb->CreateSurface ( _gdk_display->directfb, &desc, &test) != DFB_OK)
+    if ( _gdk_display_dfb->directfb->CreateSurface (_gdk_display_dfb->directfb,
+                                                    &desc, &test) != DFB_OK)
       return NULL;
 
     test->Release (test);
   }
 
-  return GDK_VISUAL(gdk_directfb_visual_create (pixel_format));
+  D_DEBUG_AT( GDKDFB_Visual, "  -> creating new visual for %s!\n", dfb_pixelformat_name( pixel_format ) );
+
+  return GDK_VISUAL (gdk_directfb_visual_create (pixel_format));
 }
 
 GdkScreen *
@@ -373,7 +425,7 @@
 }
 
 static GdkVisualDirectFB *
-gdk_directfb_visual_create (DFBSurfacePixelFormat  pixelformat)
+gdk_directfb_visual_create (DFBSurfacePixelFormat pixelformat)
 {
   GdkVisual *visual;
   gint       i;
@@ -398,7 +450,10 @@
       break;
 
     case DSPF_RGB332:
-      visual->type         = GDK_VISUAL_STATIC_COLOR;
+      visual->type         = GDK_VISUAL_TRUE_COLOR;
+      visual->red_mask     = 0x000000E0;
+      visual->green_mask   = 0x0000001C;
+      visual->blue_mask    = 0x00000003;
       visual->bits_per_rgb = 3;
       break;
 
@@ -418,7 +473,6 @@
       visual->bits_per_rgb = 6;
       break;
 
-    case DSPF_RGB24:
     case DSPF_RGB32:
     case DSPF_ARGB:
       visual->type         = GDK_VISUAL_TRUE_COLOR;
@@ -438,7 +492,7 @@
   visual->byte_order = GDK_LSB_FIRST;
 #endif
 
-  visual->depth      = DFB_BITS_PER_PIXEL (pixelformat);
+  visual->depth      = GDK_DFB_BITS_PER_PIXEL (pixelformat);
 
   switch (visual->type)
     {
@@ -478,7 +532,7 @@
       g_assert_not_reached ();
     }
 
-  ((GdkVisualDirectFB *)visual)->format = pixelformat;
+  ((GdkVisualDirectFB *) visual)->format = pixelformat;
 
   for (i = 0; available_depths[i]; i++)
     if (available_depths[i] == visual->depth)
--- gtk+-2.12.12.orig/gdk/directfb/gdkwindow-directfb.c
+++ gtk+-2.12.12/gdk/directfb/gdkwindow-directfb.c
@@ -31,105 +31,160 @@
  *            Sven Neumann <sven@convergence.de>
  */
 
-#include <config.h>
-#include "gdk.h"
-#include "gdkwindow.h"
+#include "config.h"
 
+#include "gdk.h"
 #include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
-#include "gdkdisplay-directfb.h"
+#include "gdkalias.h"
 
-#include "gdkregion-generic.h"
+D_DEBUG_DOMAIN( GDKDFB_Updates,   "GDKDFB/Updates",   "GDK DirectFB Updates" );
+D_DEBUG_DOMAIN( GDKDFB_Paintable, "GDKDFB/Paintable", "GDK DirectFB Paintable" );
+D_DEBUG_DOMAIN( GDKDFB_Window,    "GDKDFB/Window",    "GDK DirectFB Window" );
 
-#include "gdkinternals.h"
-#include "gdkalias.h"
-#include "cairo.h"
-#include <assert.h>
+static gpointer parent_class = NULL;
+
+static GdkRegion *
+gdk_window_impl_directfb_get_visible_region (GdkDrawable *drawable);
+static void
+gdk_window_impl_directfb_set_colormap       (GdkDrawable *drawable,
+                                             GdkColormap *colormap);
 
-static GdkRegion * gdk_window_impl_directfb_get_visible_region (GdkDrawable *drawable);
-static void        gdk_window_impl_directfb_set_colormap       (GdkDrawable *drawable,
-                                                                GdkColormap *colormap);
-static void gdk_window_impl_directfb_init       (GdkWindowImplDirectFB      *window);
-static void gdk_window_impl_directfb_class_init (GdkWindowImplDirectFBClass *klass);
-static void gdk_window_impl_directfb_finalize   (GObject                    *object);
+static void
+gdk_window_impl_directfb_init           (GdkWindowImplDirectFB      *window);
+static void
+gdk_window_impl_directfb_class_init     (GdkWindowImplDirectFBClass *klass);
+static void
+gdk_window_impl_directfb_finalize       (GObject                    *object);
+static void
+gdk_window_impl_directfb_paintable_init (GdkPaintableIface          *iface);
 
 typedef struct
 {
-  GdkWindowChildChanged  changed;
-  GdkWindowChildGetPos   get_pos;
-  gpointer               user_data;
+  GdkWindowChildChanged changed;
+  GdkWindowChildGetPos  get_pos;
+  gpointer              user_data;
 } GdkWindowChildHandlerData;
 
-
-/* Code for dirty-region queueing
- */
 static GSList *update_windows = NULL;
-static guint update_idle = 0;
+static guint   update_idle    = 0;
 
 static void
 gdk_window_directfb_process_all_updates (void)
 {
   GSList *old_update_windows = update_windows;
-  GSList *tmp_list = update_windows;
+  GSList *tmp_list;
 
   if (update_idle)
     g_source_remove (update_idle);
-  
+
   update_windows = NULL;
-  update_idle = 0;
+  update_idle    = 0;
+
+  D_DEBUG_AT( GDKDFB_Updates, "%s()\n", __FUNCTION__ );
+
+  g_slist_foreach (old_update_windows, (GFunc) g_object_ref, NULL);
+
+  tmp_list = old_update_windows;
 
-  g_slist_foreach (old_update_windows, (GFunc)g_object_ref, NULL);
-  
   while (tmp_list)
     {
-      GdkWindowObject *private = (GdkWindowObject *)tmp_list->data;
-      
+      GdkWindowObject       *private = GDK_WINDOW_OBJECT (tmp_list->data);
+      GdkWindowImplDirectFB *wimpl   = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
+      GDK_DFB_UNUSED_P (wimpl);
+
       if (private->update_freeze_count)
-	update_windows = g_slist_prepend (update_windows, private);
+        {
+          D_DEBUG_AT( GDKDFB_Updates, "  -> %p fRoZeN [%4d,%4d-%4dx%4d] (%d boxes)\n",
+                      private, DFB_RECTANGLE_VALS_FROM_REGION (&wimpl->flips.bounding),
+                      wimpl->flips.num_regions );
+
+          update_windows = g_slist_prepend (update_windows, private);
+        }
       else
-	gdk_window_process_updates(tmp_list->data,TRUE);
-      
+        {
+          D_DEBUG_AT( GDKDFB_Updates, "  -> %p update [%4d,%4d-%4dx%4d] (%d boxes)\n",
+                      private, DFB_RECTANGLE_VALS_FROM_REGION (&wimpl->flips.bounding),
+                      wimpl->flips.num_regions );
+
+          gdk_window_process_updates (tmp_list->data, TRUE);
+        }
+
       g_object_unref (tmp_list->data);
       tmp_list = tmp_list->next;
     }
 
-  g_slist_free (old_update_windows);
+#if GDK_DIRECTFB_GROUPED_FLIPS
+  g_slist_foreach (old_update_windows, (GFunc) g_object_ref, NULL);
+
+  tmp_list = old_update_windows;
 
+  while (tmp_list)
+    {
+      GdkWindow *win = tmp_list->data;
+
+      if (!GDK_WINDOW_DESTROYED (win))
+        {
+          GdkWindowObject *top = GDK_WINDOW_OBJECT (gdk_window_get_toplevel(win));
+
+          if (top)
+            {
+              GdkWindowImplDirectFB *wimpl = GDK_WINDOW_IMPL_DIRECTFB (top->impl);
+
+              if (wimpl->flips.num_regions)
+                {
+                  D_DEBUG_AT( GDKDFB_Updates, "  -> %p flip   [%4d,%4d-%4dx%4d] (%d boxes)\n",
+                              top, DFB_RECTANGLE_VALS_FROM_REGION (&wimpl->flips.bounding),
+                              wimpl->flips.num_regions );
+
+                  wimpl->drawable.surface->Flip (wimpl->drawable.surface,
+                                                 &wimpl->flips.bounding,
+                                                 DSFLIP_NONE);
+
+                  dfb_updates_reset (&wimpl->flips);
+                }
+              else
+                D_DEBUG_AT( GDKDFB_Updates, "  -> %p has no flips!\n", top );
+            }
+          else
+            D_DEBUG_AT( GDKDFB_Updates, "  -> %p has no top level window!\n", tmp_list->data );
+        }
+
+      g_object_unref (tmp_list->data);
+      tmp_list = tmp_list->next;
+    }
+#endif
+
+  g_slist_free (old_update_windows);
 }
 
 static gboolean
 gdk_window_update_idle (gpointer data)
 {
   gdk_window_directfb_process_all_updates ();
-  
+
   return FALSE;
 }
 
 static void
 gdk_window_schedule_update (GdkWindow *window)
 {
+  D_DEBUG_AT( GDKDFB_Updates, "%s( %p ) <- freeze count %d\n", __FUNCTION__, window,
+              window ? GDK_WINDOW_OBJECT (window)->update_freeze_count : -1 );
+
   if (window && GDK_WINDOW_OBJECT (window)->update_freeze_count)
     return;
 
   if (!update_idle)
     {
+      D_DEBUG_AT( GDKDFB_Updates, "  -> adding idle callback\n" );
+
       update_idle = gdk_threads_add_idle_full (GDK_PRIORITY_REDRAW,
-				     gdk_window_update_idle, NULL, NULL);
+                                               gdk_window_update_idle, NULL, NULL);
     }
 }
 
-
-static GdkWindow *gdk_directfb_window_containing_pointer = NULL;
-static GdkWindow *gdk_directfb_focused_window            = NULL;
-static gpointer   parent_class                           = NULL;
-GdkWindow * _gdk_parent_root = NULL;
-static void
-gdk_window_impl_directfb_paintable_init (GdkPaintableIface *iface);
-
-
-
-
-
 GType
 gdk_window_impl_directfb_get_type (void)
 {
@@ -150,20 +205,19 @@
           (GInstanceInitFunc) gdk_window_impl_directfb_init,
         };
 
-    static const GInterfaceInfo paintable_info =
-      {
-    (GInterfaceInitFunc) gdk_window_impl_directfb_paintable_init,
-    NULL,
-    NULL
-      };
+      static const GInterfaceInfo paintable_info =
+        {
+          (GInterfaceInitFunc) gdk_window_impl_directfb_paintable_init,
+          NULL,
+          NULL
+        };
 
       object_type = g_type_register_static (GDK_TYPE_DRAWABLE_IMPL_DIRECTFB,
                                             "GdkWindowImplDirectFB",
                                             &object_info, 0);
-       g_type_add_interface_static (object_type,
-                   GDK_TYPE_PAINTABLE,
-                   &paintable_info);
-
+      g_type_add_interface_static (object_type,
+                                   GDK_TYPE_PAINTABLE,
+                                   &paintable_info);
     }
 
   return object_type;
@@ -178,11 +232,11 @@
 static void
 gdk_window_impl_directfb_init (GdkWindowImplDirectFB *impl)
 {
+  GdkDisplay *display = GDK_DISPLAY_OBJECT (_gdk_display_dfb);
+
   impl->drawable.width  = 1;
   impl->drawable.height = 1;
-  //cannot use gdk_cursor_new here since gdk_display_get_default
-  //does not work yet.
-  impl->cursor          = gdk_cursor_new_for_display (GDK_DISPLAY_OBJECT(_gdk_display),GDK_LEFT_PTR);
+  impl->cursor          = gdk_cursor_new_for_display (display, GDK_LEFT_PTR);
   impl->opacity         = 255;
 }
 
@@ -220,6 +274,8 @@
 {
   GdkWindowImplDirectFB *impl = GDK_WINDOW_IMPL_DIRECTFB (object);
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p ) <- %dx%d\n", __FUNCTION__, impl, impl->drawable.width, impl->drawable.height );
+
   if (GDK_WINDOW_IS_MAPPED (impl->drawable.wrapper))
     gdk_window_hide (impl->drawable.wrapper);
 
@@ -234,7 +290,6 @@
   if (impl->window)
     {
       gdk_directfb_window_id_table_remove (impl->dfb_id);
-	  /* native window resource must be release before we can finalize !*/
       impl->window = NULL;
     }
 
@@ -245,16 +300,22 @@
 static GdkRegion*
 gdk_window_impl_directfb_get_visible_region (GdkDrawable *drawable)
 {
-  GdkDrawableImplDirectFB *priv = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
-  GdkRectangle             rect = { 0, 0, 0, 0 };
+  GdkDrawableImplDirectFB *impl  = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+  GdkRectangle             rect  = { 0, 0, 0, 0 };
   DFBRectangle             drect = { 0, 0, 0, 0 };
 
-  if (priv->surface)
-  priv->surface->GetVisibleRectangle (priv->surface, &drect);
-  rect.x= drect.x;
-  rect.y= drect.y;
-  rect.width=drect.w;
-  rect.height=drect.h;
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p )\n", __FUNCTION__, drawable );
+
+  if (impl->surface)
+    impl->surface->GetVisibleRectangle (impl->surface, &drect);
+
+  rect.x      = drect.x;
+  rect.y      = drect.y;
+  rect.width  = drect.w;
+  rect.height = drect.h;
+
+  D_DEBUG_AT( GDKDFB_Window, "  -> returning %4d,%4d-%4dx%4d\n", drect.x, drect.y, drect.w, drect.h );
+
   return gdk_region_rectangle (&rect);
 }
 
@@ -266,19 +327,18 @@
 
   if (colormap)
     {
-       GdkDrawableImplDirectFB *priv = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+       GdkDrawableImplDirectFB *impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
 
-       if (priv->surface)
-	 {
-	   IDirectFBPalette *palette = gdk_directfb_colormap_get_palette (colormap);
+       if (impl->surface)
+         {
+           IDirectFBPalette *palette = gdk_directfb_colormap_get_palette (colormap);
 
            if (palette)
-             priv->surface->SetPalette (priv->surface, palette);
+             impl->surface->SetPalette (impl->surface, palette);
          }
     }
 }
 
-
 static gboolean
 create_directfb_window (GdkWindowImplDirectFB *impl,
                         DFBWindowDescription  *desc,
@@ -287,19 +347,20 @@
   DFBResult        ret;
   IDirectFBWindow *window;
 
-  ret = _gdk_display->layer->CreateWindow (_gdk_display->layer, desc, &window);
+  D_DEBUG_AT( GDKDFB_Window, "%s( %4dx%4d, caps 0x%08x )\n", __FUNCTION__, desc->width, desc->height, desc->caps );
 
+  ret = _gdk_display_dfb->layer->CreateWindow (_gdk_display_dfb->layer, desc, &window);
   if (ret != DFB_OK)
     {
-      DirectFBError ("gdk_window_new: Layer->CreateWindow failed", ret);
-      g_assert (0);
+      DirectFBError ("gdk_directfb_window_new: CreateWindow() failed", ret);
       return FALSE;
     }
 
   if ((desc->flags & DWDESC_CAPS) && (desc->caps & DWCAPS_INPUTONLY))
-  {
-    impl->drawable.surface = NULL;
-  } else 
+    {
+      impl->drawable.surface = NULL;
+    }
+  else
     window->GetSurface (window, &impl->drawable.surface);
 
   if (window_options)
@@ -311,6 +372,11 @@
 
   impl->window = window;
 
+#if GDK_DIRECTFB_GROUPED_FLIPS
+  dfb_updates_init (&impl->flips,
+                    impl->flip_regions, G_N_ELEMENTS (impl->flip_regions));
+#endif
+
   return TRUE;
 }
 
@@ -319,57 +385,48 @@
 {
   GdkWindowObject       *private;
   GdkWindowImplDirectFB *impl;
+  DFBWindowDescription   desc;
   DFBDisplayLayerConfig  dlc;
 
   g_assert (_gdk_parent_root == NULL);
 
-  _gdk_display->layer->GetConfiguration( 
-	_gdk_display->layer, &dlc );
+  _gdk_display_dfb->layer->GetConfiguration (_gdk_display_dfb->layer, &dlc);
 
   _gdk_parent_root = g_object_new (GDK_TYPE_WINDOW, NULL);
   private = GDK_WINDOW_OBJECT (_gdk_parent_root);
   impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
 
-  private->window_type = GDK_WINDOW_ROOT;
-  private->state       = 0;
-  private->children    = NULL;
-  impl->drawable.paint_region   = NULL;
-  impl->gdkWindow      = _gdk_parent_root;
+  private->window_type   = GDK_WINDOW_ROOT;
+  private->state         = 0;
+  private->children      = NULL;
+  impl->gdkWindow        = _gdk_parent_root;
   impl->window           = NULL;
   impl->drawable.abs_x   = 0;
   impl->drawable.abs_y   = 0;
   impl->drawable.width   = dlc.width;
   impl->drawable.height  = dlc.height;
   impl->drawable.wrapper = GDK_DRAWABLE (private);
-  /* custom root window init */
-  {
-    DFBWindowDescription   desc;
-    desc.flags = 0;
-	/*XXX I must do this now its a bug  ALPHA ROOT*/
-
-    desc.flags = DWDESC_CAPS;
-    desc.caps = 0;
-    desc.caps  |= DWCAPS_NODECORATION;
-    desc.caps  |= DWCAPS_ALPHACHANNEL;
-    desc.flags |= ( DWDESC_WIDTH | DWDESC_HEIGHT |
-                      DWDESC_POSX  | DWDESC_POSY );
-    desc.posx   = 0;
-    desc.posy   = 0;
-    desc.width  = dlc.width;
-    desc.height = dlc.height;
-    create_directfb_window (impl,&desc,0);
-	g_assert(impl->window != NULL);
-    g_assert(impl->drawable.surface != NULL );
-  }
-  impl->drawable.surface->GetPixelFormat(impl->drawable.surface,&impl->drawable.format); 
-  private->depth = DFB_BITS_PER_PIXEL(impl->drawable.format);
-  /*
-	Now we can set up the system colormap
-  */
-  gdk_drawable_set_colormap (GDK_DRAWABLE (_gdk_parent_root),gdk_colormap_get_system());
-}
 
+  /* custom root window init */
+  desc.flags  = DWDESC_CAPS;
+  desc.caps   = DWCAPS_NONE;
 
+  desc.caps  |= DWCAPS_NODECORATION;
+  desc.caps  |= DWCAPS_ALPHACHANNEL;
+  desc.flags |= (DWDESC_WIDTH | DWDESC_HEIGHT |
+                 DWDESC_POSX  | DWDESC_POSY);
+  desc.posx   = 0;
+  desc.posy   = 0;
+  desc.width  = dlc.width;
+  desc.height = dlc.height;
+  create_directfb_window (impl, &desc, DWOP_NONE);
+  g_assert (impl->window != NULL);
+  g_assert (impl->drawable.surface != NULL);
+
+  impl->drawable.surface->GetPixelFormat (impl->drawable.surface,
+                                          &impl->drawable.format);
+  private->depth = GDK_DFB_BITS_PER_PIXEL (impl->drawable.format);
+}
 
 GdkWindow *
 gdk_directfb_window_new (GdkWindow              *parent,
@@ -386,10 +443,12 @@
   GdkWindowImplDirectFB *parent_impl;
   GdkVisual             *visual;
   DFBWindowDescription   desc;
-  gint x, y;
+  gint                   x, y;
 
   g_return_val_if_fail (attributes != NULL, NULL);
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p )\n", __FUNCTION__, parent );
+
   if (!parent || attributes->window_type != GDK_WINDOW_CHILD)
     parent = _gdk_parent_root;
 
@@ -400,6 +459,9 @@
   parent_impl = GDK_WINDOW_IMPL_DIRECTFB (parent_private->impl);
   private->parent = parent_private;
 
+  private->accept_focus = TRUE;
+  private->focus_on_map = TRUE;
+
   x = (attributes_mask & GDK_WA_X) ? attributes->x : 0;
   y = (attributes_mask & GDK_WA_Y) ? attributes->y : 0;
 
@@ -407,22 +469,30 @@
 
   impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
   impl->drawable.wrapper = GDK_DRAWABLE (window);
-  impl->gdkWindow      = window;
+  impl->gdkWindow        = window;
 
   private->x = x;
   private->y = y;
 
-  _gdk_directfb_calc_abs (window);
+  D_DEBUG_AT( GDKDFB_Window, "  -> rel. x/y: %d,%d\n", x, y );
+
+  gdk_directfb_calc_abs (window);
 
   impl->drawable.width  = MAX (1, attributes->width);
   impl->drawable.height = MAX (1, attributes->height);
 
+  D_DEBUG_AT( GDKDFB_Window, "  -> size:     %dx%d\n", impl->drawable.width, impl->drawable.height );
+
   private->window_type = attributes->window_type;
 
   desc.flags = 0;
 
   if (attributes_mask & GDK_WA_VISUAL)
-    visual = attributes->visual;
+    {
+      visual = attributes->visual;
+
+      D_DEBUG_AT( GDKDFB_Window, "  -> visual:   %s\n", dfb_pixelformat_name (((GdkVisualDirectFB *) visual)->format) );
+    }
   else
     visual = gdk_drawable_get_visual (parent);
 
@@ -431,13 +501,24 @@
     case GDK_INPUT_OUTPUT:
       private->input_only = FALSE;
 
-      desc.flags |= DWDESC_PIXELFORMAT;
+      desc.flags |= DWDESC_PIXELFORMAT | DWDESC_CAPS | DWDESC_OPTIONS;
+
       desc.pixelformat = ((GdkVisualDirectFB *) visual)->format;
+      desc.caps        = DWCAPS_NONE;
+      desc.options     = window_options;
 
       if (DFB_PIXELFORMAT_HAS_ALPHA (desc.pixelformat))
         {
-          desc.flags |= DWDESC_CAPS;
-          desc.caps = DWCAPS_ALPHACHANNEL;
+          desc.caps |= DWCAPS_ALPHACHANNEL;
+
+          D_DEBUG_AT( GDKDFB_Window, "  -> ALPHA CHANNEL!!!\n" );
+        }
+
+      if (private->window_type == GDK_WINDOW_TEMP)
+        {
+          desc.options |= DWOP_GHOST;
+
+          D_DEBUG_AT( GDKDFB_Window, "  -> TEMP (GHOST)!!!\n" );
         }
       break;
 
@@ -448,7 +529,7 @@
       break;
 
     default:
-      g_warning ("gdk_window_new: unsupported window class\n");
+      g_warning ("unsupported window class");
       _gdk_window_destroy (window, FALSE);
       return NULL;
     }
@@ -458,13 +539,13 @@
     case GDK_WINDOW_TOPLEVEL:
     case GDK_WINDOW_DIALOG:
     case GDK_WINDOW_TEMP:
-      desc.flags |= ( DWDESC_WIDTH | DWDESC_HEIGHT |
-                      DWDESC_POSX  | DWDESC_POSY );
+      desc.flags |= (DWDESC_WIDTH | DWDESC_HEIGHT |
+                     DWDESC_POSX  | DWDESC_POSY);
       desc.posx   = x;
       desc.posy   = y;
       desc.width  = impl->drawable.width;
       desc.height = impl->drawable.height;
-#if 0
+
       if (window_caps)
         {
           if (! (desc.flags & DWDESC_CAPS))
@@ -481,34 +562,33 @@
           desc.flags |= DWDESC_SURFACE_CAPS;
           desc.surface_caps = surface_caps;
         }
-#endif
 
       if (!create_directfb_window (impl, &desc, window_options))
         {
-		  g_assert(0);
           _gdk_window_destroy (window, FALSE);
           return NULL;
         }
-      	if( desc.caps != DWCAPS_INPUTONLY )
-			impl->window->SetOpacity(impl->window, 0x00 );
+
+      if (desc.caps != DWCAPS_INPUTONLY )
+        {
+          impl->window->SetOpacity (impl->window, 0x00);
+        }
       break;
 
     case GDK_WINDOW_CHILD:
-	   impl->window=NULL;
+      impl->window = NULL;
       if (!private->input_only && parent_impl->drawable.surface)
         {
+          DFBRectangle rect = { x, y,
+                                impl->drawable.width, impl->drawable.height };
 
-          DFBRectangle rect =
-          { x, y, impl->drawable.width, impl->drawable.height };
-          parent_impl->drawable.surface->GetSubSurface (parent_impl->drawable.surface,
-                                                        &rect,
-                                                        &impl->drawable.surface);
+          parent_impl->drawable.surface->GetSubSurface (
+            parent_impl->drawable.surface, &rect, &impl->drawable.surface);
         }
       break;
 
     default:
-      g_warning ("gdk_window_new: unsupported window type: %d",
-                 private->window_type);
+      g_warning ("unsupported window type: %d", private->window_type);
       _gdk_window_destroy (window, FALSE);
       return NULL;
     }
@@ -518,32 +598,32 @@
       GdkColormap *colormap;
 
       impl->drawable.surface->GetPixelFormat (impl->drawable.surface,
-					      &impl->drawable.format);
+                                              &impl->drawable.format);
 
-  	  private->depth = DFB_BITS_PER_PIXEL(impl->drawable.format);
+      private->depth = GDK_DFB_BITS_PER_PIXEL (impl->drawable.format);
 
       if ((attributes_mask & GDK_WA_COLORMAP) && attributes->colormap)
-	{
-	  colormap = attributes->colormap;
-	}
+        {
+          colormap = attributes->colormap;
+        }
       else
-	{
-	  if (gdk_visual_get_system () == visual)
-	    colormap = gdk_colormap_get_system ();
-	  else
-	    colormap =gdk_drawable_get_colormap (parent);
-	}
+        {
+          if (gdk_visual_get_system () == visual)
+            colormap = gdk_colormap_get_system ();
+          else
+            colormap =gdk_drawable_get_colormap (parent);
+        }
 
       gdk_drawable_set_colormap (GDK_DRAWABLE (window), colormap);
     }
   else
     {
-      impl->drawable.format = ((GdkVisualDirectFB *)visual)->format;
-  	  private->depth = visual->depth;
+      impl->drawable.format = ((GdkVisualDirectFB *) visual)->format;
+      private->depth = visual->depth;
     }
 
-  gdk_window_set_cursor (window, ((attributes_mask & GDK_WA_CURSOR) ?
-                                  (attributes->cursor) : NULL));
+  gdk_window_set_cursor (window, attributes_mask & GDK_WA_CURSOR ?
+                                 attributes->cursor : NULL);
 
   if (parent_private)
     parent_private->children = g_list_prepend (parent_private->children,
@@ -572,9 +652,14 @@
 {
   g_return_val_if_fail (attributes != NULL, NULL);
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p )\n", __FUNCTION__, parent );
+
   return gdk_directfb_window_new (parent, attributes, attributes_mask,
-                                  DWCAPS_NONE, DWOP_NONE, DSCAPS_NONE);
+                                  DWCAPS_NONE, DWOP_NONE,
+                                  direct_config_get_value ("gles") ?
+                                  DSCAPS_GL : DSCAPS_NONE);
 }
+
 void
 _gdk_windowing_window_destroy_foreign (GdkWindow *window)
 {
@@ -582,10 +667,9 @@
    * so reparent it to the root window, and then send
    * it a delete event, as if we were a WM
    */
-	_gdk_windowing_window_destroy (window,TRUE,TRUE);
+  _gdk_windowing_window_destroy (window, TRUE, TRUE);
 }
 
-
 void
 _gdk_windowing_window_destroy (GdkWindow *window,
                                gboolean   recursing,
@@ -596,38 +680,44 @@
 
   g_return_if_fail (GDK_IS_WINDOW (window));
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p, %srecursing, %sforeign )\n", __FUNCTION__, window,
+              recursing ? "" : "not ", foreign_destroy ? "" : "no " );
+
   private = GDK_WINDOW_OBJECT (window);
   impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
 
-  _gdk_selection_window_destroyed (window);
-#if (DIRECTFB_MAJOR_VERSION >= 1)
+  gdk_selection_window_destroyed (window);
+
   gdk_directfb_event_windows_remove (window);
-#endif
+
   if (window == _gdk_directfb_pointer_grab_window)
     gdk_pointer_ungrab (GDK_CURRENT_TIME);
   if (window == _gdk_directfb_keyboard_grab_window)
     gdk_keyboard_ungrab (GDK_CURRENT_TIME);
 
-  if (window == gdk_directfb_focused_window)
+  if (window == _gdk_directfb_keyboard_window)
     gdk_directfb_change_focus (NULL);
 
 
-  if (impl->drawable.surface) {
-    GdkDrawableImplDirectFB *dimpl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
-    if(dimpl->cairo_surface) {
-      cairo_surface_destroy(dimpl->cairo_surface);
-      dimpl->cairo_surface= NULL;
-    }
-    impl->drawable.surface->Release (impl->drawable.surface);
-    impl->drawable.surface = NULL;
-  }
-
-  if (!recursing && !foreign_destroy && impl->window ) {
-    	impl->window->SetOpacity (impl->window,0);
-   		impl->window->Close(impl->window);
-      	impl->window->Release(impl->window);
-        impl->window = NULL;
-  }
+  if (impl->drawable.surface)
+    {
+      GdkDrawableImplDirectFB *dimpl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
+      if (dimpl->cairo_surface)
+        {
+          cairo_surface_destroy (dimpl->cairo_surface);
+          dimpl->cairo_surface= NULL;
+        }
+      impl->drawable.surface->Release (impl->drawable.surface);
+      impl->drawable.surface = NULL;
+    }
+
+  if (!recursing && !foreign_destroy && impl->window )
+    {
+      impl->window->SetOpacity (impl->window,0);
+      impl->window->Close (impl->window);
+      impl->window->Release (impl->window);
+      impl->window = NULL;
+    }
 }
 
 /* This function is called when the window is really gone.
@@ -637,10 +727,12 @@
 {
   g_return_if_fail (GDK_IS_WINDOW (window));
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p )\n", __FUNCTION__, window );
+
   if (!GDK_WINDOW_DESTROYED (window))
     {
       if (GDK_WINDOW_TYPE(window) != GDK_WINDOW_FOREIGN)
-	g_warning ("GdkWindow %p unexpectedly destroyed", window);
+        g_warning ("GdkWindow %p unexpectedly destroyed", window);
 
       _gdk_window_destroy (window, TRUE);
     }
@@ -653,7 +745,7 @@
 {
   while (window && window != _gdk_parent_root)
     {
-      GdkWindow *parent = (GdkWindow *) (GDK_WINDOW_OBJECT (window))->parent;
+      GdkWindow *parent = GDK_WINDOW ((GDK_WINDOW_OBJECT (window))->parent);
 
       if ((parent == _gdk_parent_root) && GDK_WINDOW_IS_MAPPED (window))
         return window;
@@ -664,75 +756,43 @@
   return _gdk_parent_root;
 }
 
-GdkWindow *
-gdk_directfb_window_find_focus (void)
-{
-  if (_gdk_directfb_keyboard_grab_window)
-    return _gdk_directfb_keyboard_grab_window;
-
-  if (!gdk_directfb_focused_window)
-    gdk_directfb_focused_window = g_object_ref (_gdk_parent_root);
-
-  return gdk_directfb_focused_window;
-}
-
 void
-gdk_directfb_change_focus (GdkWindow *new_focus_window)
+gdk_directfb_change_focus (GdkWindow *window)
 {
-  GdkEventFocus *event;
-  GdkWindow     *old_win;
-  GdkWindow     *new_win;
-  GdkWindow     *event_win;
+  GdkWindow *old_win;
+  GdkWindow *new_win;
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p )\n", __FUNCTION__, window );
 
   /* No focus changes while the pointer is grabbed */
   if (_gdk_directfb_pointer_grab_window)
     return;
 
-  old_win = gdk_directfb_focused_window;
-  new_win = gdk_directfb_window_find_toplevel (new_focus_window);
+  old_win = _gdk_directfb_keyboard_window;
+  new_win = gdk_directfb_window_find_toplevel (window);
 
   if (old_win == new_win)
     return;
 
-  if (old_win)
-    {
-      event_win = gdk_directfb_keyboard_event_window (old_win,
-                                                      GDK_FOCUS_CHANGE);
-      if (event_win)
-        {
-          event = (GdkEventFocus *) gdk_directfb_event_make (event_win,
-                                                             GDK_FOCUS_CHANGE);
-          event->in = FALSE;
-        }
-    }
+  if (_gdk_directfb_keyboard_window)
+    g_object_unref (_gdk_directfb_keyboard_window);
 
-  event_win = gdk_directfb_keyboard_event_window (new_win,
-                                                  GDK_FOCUS_CHANGE);
-  if (event_win)
-    {
-      event = (GdkEventFocus *) gdk_directfb_event_make (event_win,
-                                                         GDK_FOCUS_CHANGE);
-      event->in = TRUE;
-    }
-
-  if (gdk_directfb_focused_window)
-    g_object_unref (gdk_directfb_focused_window);
-  gdk_directfb_focused_window = g_object_ref (new_win);
+  _gdk_directfb_keyboard_window = g_object_ref (new_win);
 }
 
 void
 gdk_window_set_accept_focus (GdkWindow *window,
-                             gboolean accept_focus)
+                             gboolean   accept_focus)
 {
   GdkWindowObject *private;
+
   g_return_if_fail (window != NULL);
   g_return_if_fail (GDK_IS_WINDOW (window));
-                                                                                                                      
-  private = (GdkWindowObject *)window;
-                                                                                                                      
+
+  private = GDK_WINDOW_OBJECT (window);
+
   accept_focus = accept_focus != FALSE;
-                                                                                                                      
+
   if (private->accept_focus != accept_focus)
     private->accept_focus = accept_focus;
 
@@ -740,16 +800,17 @@
 
 void
 gdk_window_set_focus_on_map (GdkWindow *window,
-                             gboolean focus_on_map)
+                             gboolean   focus_on_map)
 {
   GdkWindowObject *private;
+
   g_return_if_fail (window != NULL);
   g_return_if_fail (GDK_IS_WINDOW (window));
-                                                                                                                      
-  private = (GdkWindowObject *)window;
-                                                                                                                      
+
+  private = GDK_WINDOW_OBJECT (window);
+
   focus_on_map = focus_on_map != FALSE;
-                                                                                                                      
+
   if (private->focus_on_map != focus_on_map)
     private->focus_on_map = focus_on_map;
 }
@@ -759,6 +820,8 @@
 {
   GdkWindowObject *parent;
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p )\n", __FUNCTION__, window );
+
   parent = GDK_WINDOW_OBJECT (window)->parent;
 
   if (parent->children->data == window)
@@ -775,6 +838,8 @@
 {
   GdkWindowObject *parent;
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p )\n", __FUNCTION__, window );
+
   parent = GDK_WINDOW_OBJECT (window)->parent;
 
   parent->children = g_list_remove (parent->children, window);
@@ -787,7 +852,7 @@
   while (GDK_WINDOW_IS_MAPPED (private))
     {
       if (private->parent)
-        private = GDK_WINDOW_OBJECT (private)->parent;
+        private = private->parent;
       else
         return TRUE;
     }
@@ -804,7 +869,9 @@
   if (!GDK_WINDOW_IS_MAPPED (private))
     return;
 
-  event_win = gdk_directfb_other_event_window ((GdkWindow *) private, GDK_MAP);
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p )\n", __FUNCTION__, private );
+
+  event_win = gdk_directfb_other_event_window (GDK_WINDOW (private), GDK_MAP);
   if (event_win)
     gdk_directfb_event_make (event_win, GDK_MAP);
 
@@ -812,257 +879,14 @@
     send_map_events (list->data);
 }
 
-static GdkWindow *
-gdk_directfb_find_common_ancestor (GdkWindow *win1,
-                                   GdkWindow *win2)
-{
-  GdkWindowObject *a;
-  GdkWindowObject *b;
-
-  for (a = GDK_WINDOW_OBJECT (win1); a; a = a->parent)
-    for (b = GDK_WINDOW_OBJECT (win2); b; b = b->parent)
-      {
-        if (a == b)
-          return GDK_WINDOW (a);
-      }
-
-  return NULL;
-}
-
-void
-gdk_directfb_window_send_crossing_events (GdkWindow       *src,
-                                          GdkWindow       *dest,
-                                          GdkCrossingMode  mode)
-{
-  GdkWindow       *c;
-  GdkWindow       *win, *last, *next;
-  GdkEvent        *event;
-  gint             x, y, x_int, y_int;
-  GdkModifierType  modifiers;
-  GSList          *path, *list;
-  gboolean         non_linear;
-  GdkWindow       *a;
-  GdkWindow       *b;
-  GdkWindow       *event_win;
-
-  /* Do a possible cursor change before checking if we need to
-     generate crossing events so cursor changes due to pointer
-     grabs work correctly. */
-  {
-    static GdkCursorDirectFB *last_cursor = NULL;
-
-    GdkWindowObject       *private = GDK_WINDOW_OBJECT (dest);
-    GdkWindowImplDirectFB *impl    = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
-    GdkCursorDirectFB     *cursor;
-
-    if (_gdk_directfb_pointer_grab_cursor)
-      cursor = (GdkCursorDirectFB*) _gdk_directfb_pointer_grab_cursor;
-    else
-      cursor = (GdkCursorDirectFB*) impl->cursor;
-
-    if (cursor != last_cursor)
-      {
-        win     = gdk_directfb_window_find_toplevel (dest);
-        private = GDK_WINDOW_OBJECT (win);
-        impl    = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
-
-        if (impl->window)
-          impl->window->SetCursorShape (impl->window,
-                                        cursor->shape,
-                                        cursor->hot_x, cursor->hot_y);
-        last_cursor = cursor;
-      }
-  }
-
-  if (dest == gdk_directfb_window_containing_pointer)
-    return;
-
-  if (gdk_directfb_window_containing_pointer == NULL)
-    gdk_directfb_window_containing_pointer = g_object_ref (_gdk_parent_root);
-
-  if (src)
-    a = src;
-  else
-    a = gdk_directfb_window_containing_pointer;
-
-  b = dest;
-
-  if (a == b)
-    return;
-
-  /* gdk_directfb_window_containing_pointer might have been destroyed.
-   * The refcount we hold on it should keep it, but it's parents
-   * might have died.
-   */
-  if (GDK_WINDOW_DESTROYED (a))
-    a = _gdk_parent_root;
-
-  gdk_directfb_mouse_get_info (&x, &y, &modifiers);
-
-  c = gdk_directfb_find_common_ancestor (a, b);
-
-  non_linear = (c != a) && (c != b);
-
-  event_win = gdk_directfb_pointer_event_window (a, GDK_LEAVE_NOTIFY);
-  if (event_win)
-    {
-      event = gdk_directfb_event_make (event_win, GDK_LEAVE_NOTIFY);
-      event->crossing.subwindow = NULL;
-
-      gdk_window_get_origin (a, &x_int, &y_int);
-
-      event->crossing.x      = x - x_int;
-      event->crossing.y      = y - y_int;
-      event->crossing.x_root = x;
-      event->crossing.y_root = y;
-      event->crossing.mode   = mode;
-
-      if (non_linear)
-        event->crossing.detail = GDK_NOTIFY_NONLINEAR;
-      else if (c == a)
-        event->crossing.detail = GDK_NOTIFY_INFERIOR;
-      else
-        event->crossing.detail = GDK_NOTIFY_ANCESTOR;
-
-      event->crossing.focus = FALSE;
-      event->crossing.state = modifiers;
-    }
-
-   /* Traverse up from a to (excluding) c */
-  if (c != a)
-    {
-      last = a;
-      win = GDK_WINDOW (GDK_WINDOW_OBJECT (a)->parent);
-      while (win != c)
-        {
-          event_win =
-            gdk_directfb_pointer_event_window (win, GDK_LEAVE_NOTIFY);
-
-          if (event_win)
-            {
-              event = gdk_directfb_event_make (event_win, GDK_LEAVE_NOTIFY);
-
-              event->crossing.subwindow = g_object_ref (last);
-
-              gdk_window_get_origin (win, &x_int, &y_int);
-
-              event->crossing.x      = x - x_int;
-              event->crossing.y      = y - y_int;
-              event->crossing.x_root = x;
-              event->crossing.y_root = y;
-              event->crossing.mode   = mode;
-
-              if (non_linear)
-                event->crossing.detail = GDK_NOTIFY_NONLINEAR_VIRTUAL;
-              else
-                event->crossing.detail = GDK_NOTIFY_VIRTUAL;
-
-              event->crossing.focus = FALSE;
-              event->crossing.state = modifiers;
-            }
-
-          last = win;
-          win = GDK_WINDOW (GDK_WINDOW_OBJECT (win)->parent);
-        }
-    }
-
-  /* Traverse down from c to b */
-  if (c != b)
-    {
-      path = NULL;
-      win = GDK_WINDOW (GDK_WINDOW_OBJECT (b)->parent);
-      while (win != c)
-        {
-          path = g_slist_prepend (path, win);
-          win = GDK_WINDOW (GDK_WINDOW_OBJECT (win)->parent);
-        }
-
-      list = path;
-      while (list)
-        {
-          win = GDK_WINDOW (list->data);
-          list = g_slist_next (list);
-
-          if (list)
-            next = GDK_WINDOW (list->data);
-          else
-            next = b;
-
-          event_win =
-            gdk_directfb_pointer_event_window (win, GDK_ENTER_NOTIFY);
-
-          if (event_win)
-            {
-              event = gdk_directfb_event_make (event_win, GDK_ENTER_NOTIFY);
-
-              event->crossing.subwindow = g_object_ref (next);
-
-              gdk_window_get_origin (win, &x_int, &y_int);
-
-              event->crossing.x      = x - x_int;
-              event->crossing.y      = y - y_int;
-              event->crossing.x_root = x;
-              event->crossing.y_root = y;
-              event->crossing.mode   = mode;
-
-              if (non_linear)
-                event->crossing.detail = GDK_NOTIFY_NONLINEAR_VIRTUAL;
-              else
-                event->crossing.detail = GDK_NOTIFY_VIRTUAL;
-
-              event->crossing.focus = FALSE;
-              event->crossing.state = modifiers;
-            }
-        }
-
-      g_slist_free (path);
-    }
-
-  event_win = gdk_directfb_pointer_event_window (b, GDK_ENTER_NOTIFY);
-  if (event_win)
-    {
-      event = gdk_directfb_event_make (event_win, GDK_ENTER_NOTIFY);
-
-      event->crossing.subwindow = NULL;
-
-      gdk_window_get_origin (b, &x_int, &y_int);
-
-      event->crossing.x      = x - x_int;
-      event->crossing.y      = y - y_int;
-      event->crossing.x_root = x;
-      event->crossing.y_root = y;
-      event->crossing.mode   = mode;
-
-      if (non_linear)
-        event->crossing.detail = GDK_NOTIFY_NONLINEAR;
-      else if (c==a)
-        event->crossing.detail = GDK_NOTIFY_ANCESTOR;
-      else
-        event->crossing.detail = GDK_NOTIFY_INFERIOR;
-
-      event->crossing.focus = FALSE;
-      event->crossing.state = modifiers;
-    }
-
-  if (mode != GDK_CROSSING_GRAB)
-    {
-      //this seems to cause focus to change as the pointer moves yuck
-      //gdk_directfb_change_focus (b);
-      if (b != gdk_directfb_window_containing_pointer)
-        {
-          g_object_unref (gdk_directfb_window_containing_pointer);
-          gdk_directfb_window_containing_pointer = g_object_ref (b);
-        }
-    }
-}
-
 static void
 show_window_internal (GdkWindow *window,
                       gboolean   raise)
 {
   GdkWindowObject       *private;
   GdkWindowImplDirectFB *impl;
-  GdkWindow             *mousewin;
+
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p, %sraise )\n", __FUNCTION__, window, raise ? "" : "no " );
 
   private = GDK_WINDOW_OBJECT (window);
   impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
@@ -1078,10 +902,6 @@
         {
           send_map_events (private);
 
-          mousewin = gdk_window_at_pointer (NULL, NULL);
-          gdk_directfb_window_send_crossing_events (NULL, mousewin,
-                                                    GDK_CROSSING_NORMAL);
-
           if (private->input_only)
             return;
 
@@ -1092,11 +912,10 @@
   if (impl->window)
     {
       if (gdk_directfb_apply_focus_opacity)
-	impl->window->SetOpacity (impl->window,
-				  (impl->opacity >> 1) + (impl->opacity >> 2));
+        impl->window->SetOpacity (impl->window,
+                                  (impl->opacity >> 1) + (impl->opacity >> 2));
       else
-	impl->window->SetOpacity (impl->window, impl->opacity);
-	  /* if its the first window focus it */
+        impl->window->SetOpacity (impl->window, impl->opacity);
     }
 }
 
@@ -1105,6 +924,8 @@
 {
   g_return_if_fail (GDK_IS_WINDOW (window));
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p )\n", __FUNCTION__, window );
+
   show_window_internal (window, FALSE);
 }
 
@@ -1113,6 +934,8 @@
 {
   g_return_if_fail (GDK_IS_WINDOW (window));
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p )\n", __FUNCTION__, window );
+
   show_window_internal (window, TRUE);
 }
 
@@ -1121,21 +944,20 @@
 {
   GdkWindowObject       *private;
   GdkWindowImplDirectFB *impl;
-  GdkWindow             *mousewin;
   GdkWindow             *event_win;
 
   g_return_if_fail (GDK_IS_WINDOW (window));
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p )\n", __FUNCTION__, window );
+
   private = GDK_WINDOW_OBJECT (window);
-  impl    = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+  impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
 
   if (impl->window)
     impl->window->SetOpacity (impl->window, 0);
 
   if (!private->destroyed && GDK_WINDOW_IS_MAPPED (private))
     {
-      GdkEvent *event;
-
       private->state |= GDK_WINDOW_STATE_WITHDRAWN;
 
       if (!private->input_only && private->parent)
@@ -1149,12 +971,7 @@
 
       event_win = gdk_directfb_other_event_window (window, GDK_UNMAP);
       if (event_win)
-        event = gdk_directfb_event_make (event_win, GDK_UNMAP);
-
-      mousewin = gdk_window_at_pointer (NULL, NULL);
-      gdk_directfb_window_send_crossing_events (NULL,
-                                                mousewin,
-                                                GDK_CROSSING_NORMAL);
+        gdk_directfb_event_make (event_win, GDK_UNMAP);
 
       if (window == _gdk_directfb_pointer_grab_window)
         gdk_pointer_ungrab (GDK_CURRENT_TIME);
@@ -1187,32 +1004,25 @@
 
   if (impl->window)
     {
-  	  private->x = x;
-  	  private->y = y;
+      private->x = x;
+      private->y = y;
       impl->window->MoveTo (impl->window, x, y);
     }
   else
     {
-	  gint width=impl->drawable.width;
-	  gint height=impl->drawable.height;
-      GdkRectangle  old =
-      { private->x, private->y,width,height };
+      gint         width  = impl->drawable.width;
+      gint         height = impl->drawable.height;
+      GdkRectangle old    = { private->x, private->y, width, height };
 
-      _gdk_directfb_move_resize_child (window, x, y, width, height);
-      _gdk_directfb_calc_abs (window);
+      gdk_directfb_move_resize_child (window, x, y, width, height);
+      gdk_directfb_calc_abs (window);
 
       if (GDK_WINDOW_IS_MAPPED (private))
         {
-          GdkWindow    *mousewin;
-          GdkRectangle  new = { x, y, width, height };
+          GdkRectangle new = { x, y, width, height };
 
           gdk_rectangle_union (&new, &old, &new);
-          gdk_window_invalidate_rect (GDK_WINDOW (private->parent), &new,TRUE);
-
-          /* The window the pointer is in might have changed */
-          mousewin = gdk_window_at_pointer (NULL, NULL);
-          gdk_directfb_window_send_crossing_events (NULL, mousewin,
-                                                    GDK_CROSSING_NORMAL);
+          gdk_window_invalidate_rect (GDK_WINDOW (private->parent), &new, TRUE);
         }
     }
 }
@@ -1237,21 +1047,21 @@
       GdkWindowChildHandlerData *data;
 
       data = g_object_get_data (G_OBJECT (private->parent),
-				"gdk-window-child-handler");
+                                "gdk-window-child-handler");
 
       if (data)
-	(*data->get_pos) (window, &x, &y, data->user_data);
+        (*data->get_pos) (window, &x, &y, data->user_data);
     }
 
   gdk_window_move_resize (window, x, y, width, height);
 }
 
 void
-_gdk_directfb_move_resize_child (GdkWindow *window,
-                                 gint       x,
-                                 gint       y,
-                                 gint       width,
-                                 gint       height)
+gdk_directfb_move_resize_child (GdkWindow *window,
+                                gint       x,
+                                gint       y,
+                                gint       width,
+                                gint       height)
 {
   GdkWindowObject       *private;
   GdkWindowImplDirectFB *impl;
@@ -1261,7 +1071,7 @@
   g_return_if_fail (GDK_IS_WINDOW (window));
 
   private = GDK_WINDOW_OBJECT (window);
-  impl    = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+  impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
 
   private->x = x;
   private->y = y;
@@ -1271,15 +1081,18 @@
 
   if (!private->input_only)
     {
-    if (impl->drawable.surface) {
-      GdkDrawableImplDirectFB *dimpl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
-      if(dimpl->cairo_surface) {
-        cairo_surface_destroy(dimpl->cairo_surface);
-        dimpl->cairo_surface= NULL;
-      }
-    impl->drawable.surface->Release (impl->drawable.surface);
-    impl->drawable.surface = NULL;
-  }
+      if (impl->drawable.surface)
+        {
+          GdkDrawableImplDirectFB *dimpl;
+          dimpl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
+          if (dimpl->cairo_surface)
+            {
+              cairo_surface_destroy (dimpl->cairo_surface);
+              dimpl->cairo_surface = NULL;
+            }
+          impl->drawable.surface->Release (impl->drawable.surface);
+          impl->drawable.surface = NULL;
+        }
 
       parent_impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (private->parent)->impl);
 
@@ -1287,19 +1100,20 @@
         {
           DFBRectangle rect = { x, y, width, height };
 
-          parent_impl->drawable.surface->GetSubSurface (parent_impl->drawable.surface,
-                                                        &rect,
-                                                        &impl->drawable.surface);
+          parent_impl->drawable.surface->GetSubSurface (
+            parent_impl->drawable.surface, &rect, &impl->drawable.surface);
         }
     }
 
   for (list = private->children; list; list = list->next)
     {
       private = GDK_WINDOW_OBJECT (list->data);
-  	  impl  = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
-      _gdk_directfb_move_resize_child (list->data,
-                                       private->x, private->y,
-                                       impl->drawable.width, impl->drawable.height);
+      impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+      gdk_directfb_move_resize_child (list->data,
+                                      private->x,
+                                      private->y,
+                                      impl->drawable.width,
+                                      impl->drawable.height);
     }
 }
 
@@ -1324,8 +1138,8 @@
     height = 1;
 
   if (private->destroyed ||
-      (private->x == x  &&  private->y == y  &&
-       impl->drawable.width == width  &&  impl->drawable.height == height))
+      (private->x == x && private->y == y &&
+       impl->drawable.width == width && impl->drawable.height == height))
     return;
 
   if (private->parent && (private->parent->window_type != GDK_WINDOW_CHILD))
@@ -1340,36 +1154,31 @@
         return;
     }
 
-  if (impl->drawable.width == width  &&  impl->drawable.height == height)
+  if (impl->drawable.width == width && impl->drawable.height == height)
     {
       gdk_window_move (window, x, y);
     }
   else if (impl->window)
     {
-  	  private->x = x;
-  	  private->y = y;
+      private->x = x;
+      private->y = y;
       impl->window->MoveTo (impl->window, x, y);
       impl->window->Resize (impl->window, width, height);
     }
   else
     {
-      GdkRectangle  old =
-      { private->x, private->y, impl->drawable.width, impl->drawable.height };
-      _gdk_directfb_move_resize_child (window, x, y, width, height);
-      _gdk_directfb_calc_abs (window);
+      GdkRectangle old = { private->x, private->y,
+                           impl->drawable.width, impl->drawable.height };
+
+      gdk_directfb_move_resize_child (window, x, y, width, height);
+      gdk_directfb_calc_abs (window);
 
       if (GDK_WINDOW_IS_MAPPED (private))
         {
-          GdkWindow    *mousewin;
-          GdkRectangle  new = { x, y, width, height };
+          GdkRectangle new = { x, y, width, height };
 
           gdk_rectangle_union (&new, &old, &new);
-          gdk_window_invalidate_rect (GDK_WINDOW (private->parent), &new,TRUE);
-
-          /* The window the pointer is in might have changed */
-          mousewin = gdk_window_at_pointer (NULL, NULL);
-          gdk_directfb_window_send_crossing_events (NULL, mousewin,
-                                                    GDK_CROSSING_NORMAL);
+          gdk_window_invalidate_rect (GDK_WINDOW (private->parent), &new, TRUE);
         }
     }
 }
@@ -1380,9 +1189,9 @@
                      gint       x,
                      gint       y)
 {
-  GdkWindowObject *window_private;
-  GdkWindowObject *parent_private;
-  GdkWindowObject *old_parent_private;
+  GdkWindowObject       *window_private;
+  GdkWindowObject       *parent_private;
+  GdkWindowObject       *old_parent_private;
   GdkWindowImplDirectFB *impl;
   GdkWindowImplDirectFB *parent_impl;
   GdkVisual             *visual;
@@ -1395,17 +1204,17 @@
   if (!new_parent)
     new_parent = _gdk_parent_root;
 
-  window_private = (GdkWindowObject *) window;
-  old_parent_private = (GdkWindowObject *) window_private->parent;
-  parent_private = (GdkWindowObject *) new_parent;
+  window_private = GDK_WINDOW_OBJECT (window);
+  old_parent_private = GDK_WINDOW_OBJECT (window_private->parent);
+  parent_private = GDK_WINDOW_OBJECT (new_parent);
   parent_impl = GDK_WINDOW_IMPL_DIRECTFB (parent_private->impl);
   visual = gdk_drawable_get_visual (window);
 
   /* already parented */
-  if( window_private->parent == (GdkWindowObject *)new_parent )
-          return;
+  if (window_private->parent == GDK_WINDOW_OBJECT (new_parent))
+    return;
 
-  window_private->parent = (GdkWindowObject *) new_parent;
+  window_private->parent = GDK_WINDOW_OBJECT (new_parent);
 
   if (old_parent_private)
     {
@@ -1413,66 +1222,78 @@
         g_list_remove (old_parent_private->children, window);
     }
 
-    parent_private->children = g_list_prepend (parent_private->children, window);
+  parent_private->children = g_list_prepend (parent_private->children, window);
+
+  impl = GDK_WINDOW_IMPL_DIRECTFB (window_private->impl);
+
+  if (impl->drawable.surface)
+    {
+      impl->drawable.surface->Release (impl->drawable.surface);
+      impl->drawable.surface = NULL;
+    }
+
+  if (impl->window != NULL)
+    {
+      gdk_directfb_window_id_table_remove (impl->dfb_id);
+      impl->window->SetOpacity (impl->window,0);
+      impl->window->Close (impl->window);
+      impl->window->Release (impl->window);
+      impl->window = NULL;
+    }
 
-    impl = GDK_WINDOW_IMPL_DIRECTFB (window_private->impl);
+  if (window_private->parent == GDK_WINDOW_OBJECT (_gdk_parent_root))
+    {
+      DFBWindowDescription desc;
+      DFBWindowOptions     window_options = DWOP_NONE;
 
-    if( impl->drawable.surface ) {
-        impl->drawable.surface->Release (impl->drawable.surface);
-        impl->drawable.surface = NULL;
-    }
-
-    if( impl->window != NULL ) { 
-        gdk_directfb_window_id_table_remove (impl->dfb_id);
-    	impl->window->SetOpacity (impl->window,0);
-   		impl->window->Close(impl->window);
-      	impl->window->Release(impl->window);
-        impl->window = NULL;
-    }
-
-    //create window were a child of the root now
-    if( window_private->parent == (GdkWindowObject *)_gdk_parent_root)  {
-        DFBWindowDescription  desc;
-        DFBWindowOptions  window_options = DWOP_NONE;
-        desc.flags = DWDESC_CAPS;
-        if( window_private->input_only ) {
-            desc.caps = DWCAPS_INPUTONLY;
-        } else {
-            desc.flags |= DWDESC_PIXELFORMAT;
-            desc.pixelformat = ((GdkVisualDirectFB *) visual)->format;
-            if (DFB_PIXELFORMAT_HAS_ALPHA (desc.pixelformat)) {
-                desc.flags |= DWDESC_CAPS;
-                desc.caps = DWCAPS_ALPHACHANNEL;
+      desc.flags = DWDESC_CAPS;
+      if (window_private->input_only)
+        {
+          desc.caps = DWCAPS_INPUTONLY;
+        }
+      else
+        {
+          desc.flags |= DWDESC_PIXELFORMAT;
+          desc.pixelformat = ((GdkVisualDirectFB *) visual)->format;
+          if (DFB_PIXELFORMAT_HAS_ALPHA (desc.pixelformat))
+            {
+              desc.flags |= DWDESC_CAPS;
+              desc.caps = DWCAPS_ALPHACHANNEL;
             }
-       }
-       if( window_private->window_type ==  GDK_WINDOW_CHILD )
-           window_private->window_type = GDK_WINDOW_TOPLEVEL;
-        desc.flags |= ( DWDESC_WIDTH | DWDESC_HEIGHT |
-                      DWDESC_POSX  | DWDESC_POSY );
-        desc.posx   = x;
-        desc.posy   = y;
-        desc.width  = impl->drawable.width;
-        desc.height = impl->drawable.height;
-        if (!create_directfb_window (impl, &desc, window_options))
+        }
+
+      if (window_private->window_type ==  GDK_WINDOW_CHILD)
+        window_private->window_type = GDK_WINDOW_TOPLEVEL;
+
+      desc.flags |= (DWDESC_WIDTH | DWDESC_HEIGHT |
+                     DWDESC_POSX  | DWDESC_POSY);
+      desc.posx   = x;
+      desc.posy   = y;
+      desc.width  = impl->drawable.width;
+      desc.height = impl->drawable.height;
+
+      if (!create_directfb_window (impl, &desc, window_options))
         {
-		  g_assert(0);
           _gdk_window_destroy (window, FALSE);
           return;
         }
-        /* we hold a reference count on ourselves */
-        g_object_ref (window);
-        impl->window->GetID (impl->window, &impl->dfb_id);
-        gdk_directfb_window_id_table_insert (impl->dfb_id, window);
-        gdk_directfb_event_windows_add (window);
-   } else {
-          DFBRectangle rect = { x, y, impl->drawable.width,
-                                     impl->drawable.height};
-          impl->window = NULL;
-          parent_impl->drawable.surface->GetSubSurface (
-                          parent_impl->drawable.surface,
-                          &rect,
-                          &impl->drawable.surface);
-   }
+
+      /* we hold a reference count on ourselves */
+      g_object_ref (window);
+
+      impl->window->GetID (impl->window, &impl->dfb_id);
+      gdk_directfb_window_id_table_insert (impl->dfb_id, window);
+      gdk_directfb_event_windows_add (window);
+    }
+  else
+    {
+      DFBRectangle rect = { x, y,
+                            impl->drawable.width, impl->drawable.height };
+
+      impl->window = NULL;
+      parent_impl->drawable.surface->GetSubSurface (
+        parent_impl->drawable.surface, &rect, &impl->drawable.surface);
+    }
 }
 
 void
@@ -1490,22 +1311,23 @@
   gint                     dx = 0;
   gint                     dy = 0;
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p, %4d,%4d-%4dx%4d )\n", __FUNCTION__, window, x, y, width, height );
+
   g_return_if_fail (GDK_IS_WINDOW (window));
 
   if (GDK_WINDOW_DESTROYED (window))
-    return;
+    {
+      D_DEBUG_AT( GDKDFB_Window, "  -> DESTROYED!\n" );
+      return;
+    }
 
   private = GDK_WINDOW_OBJECT (window);
-
   impl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
 
-  /**
-	Follow XClearArea definition for zero height width
-  **/
-  if( width == 0 )  
-		width = impl->width-x;
-  if( height == 0 )  
-		height = impl->height-y;
+  if (width == 0)
+    width = impl->width - x;
+  if (height == 0)
+    height = impl->height - y;
 
   bg_pixmap = private->bg_pixmap;
 
@@ -1519,36 +1341,42 @@
     }
 
   if (bg_pixmap == GDK_NO_BG)
-    return;
+    {
+      D_DEBUG_AT( GDKDFB_Window, "  -> NO BG\n" );
+      return;
+    }
 
   if (bg_pixmap && bg_pixmap != GDK_PARENT_RELATIVE_BG)
     {
-      GdkGCValues  values;
+      GdkGCValues values;
 
       values.fill = GDK_TILED;
       values.tile = bg_pixmap;
       values.ts_x_origin = - dx;
       values.ts_y_origin = - dy;
 
+      D_DEBUG_AT( GDKDFB_Window, "  -> PIXMAP\n" );
+
       gc = gdk_gc_new_with_values (GDK_DRAWABLE (impl), &values,
                                    GDK_GC_FILL | GDK_GC_TILE |
                                    GDK_GC_TS_X_ORIGIN | GDK_GC_TS_Y_ORIGIN);
     }
-  else 
+  else
     {
       /* GDK_PARENT_RELATIVE_BG, but no pixmap,
          get the color from the parent window. */
 
-      GdkGCValues  values;
+      GdkGCValues values;
 
       values.foreground = relative_to->bg_color;
 
+      D_DEBUG_AT( GDKDFB_Window, "  -> COLOR\n" );
+
       gc = gdk_gc_new_with_values (GDK_DRAWABLE (impl), &values,
                                    GDK_GC_FOREGROUND);
     }
 
-  gdk_draw_rectangle (GDK_DRAWABLE (impl),
-                                gc, TRUE, x, y, width, height);
+  gdk_draw_rectangle (GDK_DRAWABLE (impl), gc, TRUE, x, y, width, height);
 
   if (gc)
     g_object_unref (gc);
@@ -1561,22 +1389,21 @@
                                     gint       width,
                                     gint       height)
 {
-  GdkRectangle  rect;
+  GdkRectangle           rect;
   GdkWindowObject       *private;
   GdkWindowImplDirectFB *impl;
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p, %4d,%4d-%4dx%4d )\n", __FUNCTION__, window, x, y, width, height );
+
   g_return_if_fail (GDK_IS_WINDOW (window));
 
   private = GDK_WINDOW_OBJECT (window);
-  impl    = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+  impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
 
-  /**
-	Follow XClearArea definition for zero height width
-  **/
-  if( width == 0 )  
-		width = impl->drawable.width-x;
-  if( height == 0 )  
-		height = impl->drawable.height-y;
+  if (width == 0)
+    width = impl->drawable.width - x;
+  if (height == 0)
+    height = impl->drawable.height - y;
 
   rect.x = x;
   rect.y = y;
@@ -1586,7 +1413,10 @@
   g_return_if_fail (GDK_IS_WINDOW (window));
 
   if (GDK_WINDOW_DESTROYED (window))
-    return;
+    {
+      D_DEBUG_AT( GDKDFB_Window, "  -> DESTROYED!\n" );
+      return;
+    }
 
   _gdk_windowing_window_clear_area (window, x, y, width, height);
 
@@ -1598,6 +1428,8 @@
 {
   GdkWindowImplDirectFB *impl;
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p )\n", __FUNCTION__, window );
+
   g_return_if_fail (GDK_IS_WINDOW (window));
 
   if (GDK_WINDOW_DESTROYED (window))
@@ -1611,7 +1443,7 @@
 
       ret = impl->window->RaiseToTop (impl->window);
       if (ret)
-        DirectFBError ("gdkwindow-directfb.c: RaiseToTop", ret);
+        DirectFBError ("gdk_window_raise: RaiseToTop() failed", ret);
       else
         gdk_directfb_window_raise (window);
     }
@@ -1627,6 +1459,8 @@
 {
   GdkWindowImplDirectFB *impl;
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p )\n", __FUNCTION__, window );
+
   g_return_if_fail (GDK_IS_WINDOW (window));
 
   if (GDK_WINDOW_DESTROYED (window))
@@ -1640,7 +1474,7 @@
 
       ret = impl->window->LowerToBottom (impl->window);
       if (ret)
-        DirectFBError ("gdkwindow-directfb.c: LowerToBottom", ret);
+        DirectFBError ("gdk_window_lower: LowerToBottom() failed", ret);
       else
         gdk_directfb_window_lower (window);
     }
@@ -1661,12 +1495,7 @@
                       gint       max_height,
                       gint       flags)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
+  D_UNIMPLEMENTED();
 }
 
 void
@@ -1674,53 +1503,28 @@
                                GdkGeometry    *geometry,
                                GdkWindowHints  geom_mask)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_set_title (GdkWindow   *window,
                       const gchar *title)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_set_role (GdkWindow   *window,
                      const gchar *role)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
+  D_UNIMPLEMENTED();
 }
 
-/**
- * gdk_window_set_startup_id:
- * @window: a toplevel #GdkWindow
- * @startup_id: a string with startup-notification identifier
- *
- * When using GTK+, typically you should use gtk_window_set_startup_id()
- * instead of this low-level function.
- *
- * Since: 2.12
- *
- **/
-void          
+void
 gdk_window_set_startup_id (GdkWindow   *window,
-		     const gchar *startup_id)
+                           const gchar *startup_id)
 {
+  D_UNIMPLEMENTED();
 }
 
 void
@@ -1729,7 +1533,7 @@
 {
   GdkWindowObject *private;
   GdkWindowObject *root;
-  gint i;
+  gint             i;
 
   g_return_if_fail (GDK_IS_WINDOW (window));
   g_return_if_fail (GDK_IS_WINDOW (parent));
@@ -1738,7 +1542,8 @@
   root    = GDK_WINDOW_OBJECT (_gdk_parent_root);
 
   g_return_if_fail (GDK_WINDOW (private->parent) == _gdk_parent_root);
-  g_return_if_fail (GDK_WINDOW (GDK_WINDOW_OBJECT (parent)->parent) == _gdk_parent_root);
+  g_return_if_fail (
+    GDK_WINDOW (GDK_WINDOW_OBJECT (parent)->parent) == _gdk_parent_root);
 
   root->children = g_list_remove (root->children, window);
 
@@ -1750,8 +1555,8 @@
 }
 
 void
-gdk_window_set_background (GdkWindow *window,
-                           const GdkColor  *color)
+gdk_window_set_background (GdkWindow      *window,
+                           const GdkColor *color)
 {
   GdkWindowObject *private;
 
@@ -1759,15 +1564,18 @@
 
   g_return_if_fail (color != NULL);
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p, %d,%d,%d )\n", __FUNCTION__, window, color->red, color->green, color->blue );
+
   private = GDK_WINDOW_OBJECT (window);
   private->bg_color = *color;
 
   if (private->bg_pixmap &&
       private->bg_pixmap != GDK_PARENT_RELATIVE_BG &&
       private->bg_pixmap != GDK_NO_BG)
-    g_object_unref (private->bg_pixmap);
-
-  private->bg_pixmap = NULL;
+    {
+      g_object_unref (private->bg_pixmap);
+      private->bg_pixmap = NULL;
+    }
 }
 
 void
@@ -1775,32 +1583,40 @@
                             GdkPixmap *pixmap,
                             gint       parent_relative)
 {
-  GdkWindowObject *private;
-  GdkPixmap       *old_pixmap;
+  GdkWindowObject *private = GDK_WINDOW_OBJECT (window);
 
   g_return_if_fail (GDK_IS_WINDOW (window));
   g_return_if_fail (pixmap == NULL || !parent_relative);
 
-  private = GDK_WINDOW_OBJECT (window);
-  old_pixmap = private->bg_pixmap;
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p, %p, %srelative )\n", __FUNCTION__,
+              window, pixmap, parent_relative ? "" : "not " );
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
 
   if (private->bg_pixmap &&
       private->bg_pixmap != GDK_PARENT_RELATIVE_BG &&
       private->bg_pixmap != GDK_NO_BG)
-    {
-      g_object_unref (private->bg_pixmap);
-    }
+    g_object_unref (private->bg_pixmap);
 
   if (parent_relative)
     {
       private->bg_pixmap = GDK_PARENT_RELATIVE_BG;
+      GDK_NOTE (MISC,
+                g_print ("gdk_window_set_back_pixmap: "
+                         "setting background pixmap to parent_relative\n"));
     }
   else
     {
-      if (pixmap && pixmap != GDK_NO_BG && pixmap != GDK_PARENT_RELATIVE_BG)
-        g_object_ref (pixmap);
-
-      private->bg_pixmap = pixmap;
+      if (pixmap)
+        {
+          g_object_ref (pixmap);
+          private->bg_pixmap = pixmap;
+        }
+      else
+        {
+          private->bg_pixmap = GDK_NO_BG;
+        }
     }
 }
 
@@ -1813,6 +1629,9 @@
 
   g_return_if_fail (GDK_IS_WINDOW (window));
 
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
   impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
   old_cursor = impl->cursor;
 
@@ -1821,12 +1640,7 @@
 
   if (gdk_window_at_pointer (NULL, NULL) == window)
     {
-      /* This is a bit evil but we want to keep all cursor changes in
-         one place, so let gdk_directfb_window_send_crossing_events
-         do the work for us. */
-
-      gdk_directfb_window_send_crossing_events (window, window,
-                                                GDK_CROSSING_NORMAL);
+      gdk_directfb_events_update_cursor (window);
     }
   else if (impl->window)
     {
@@ -1857,29 +1671,29 @@
   g_return_if_fail (GDK_IS_WINDOW (window));
 
   private = GDK_WINDOW_OBJECT (window);
-  impl    = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
 
   if (!GDK_WINDOW_DESTROYED (window))
     {
       if (x)
-	*x = private->x;
+        *x = private->x;
 
       if (y)
-	*y = private->y;
+        *y = private->y;
 
       if (width)
-	*width = impl->width;
+        *width = impl->width;
 
       if (height)
-	*height = impl->height;
+        *height = impl->height;
 
       if (depth)
-	*depth = DFB_BITS_PER_PIXEL(impl->format);
+        *depth = GDK_DFB_BITS_PER_PIXEL (impl->format);
     }
 }
 
 void
-_gdk_directfb_calc_abs (GdkWindow *window)
+gdk_directfb_calc_abs (GdkWindow *window)
 {
   GdkWindowObject         *private;
   GdkDrawableImplDirectFB *impl;
@@ -1902,9 +1716,11 @@
       impl->abs_y += parent_impl->abs_y;
     }
 
+  D_DEBUG_AT( GDKDFB_Window, "%s( %p ) -> %4d,%4d\n", __FUNCTION__, window, impl->abs_x, impl->abs_y );
+
   for (list = private->children; list; list = list->next)
     {
-      _gdk_directfb_calc_abs (list->data);
+      gdk_directfb_calc_abs (list->data);
     }
 }
 
@@ -1922,9 +1738,9 @@
       impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
 
       if (x)
-	*x = impl->abs_x;
+        *x = impl->abs_x;
       if (y)
-	*y = impl->abs_y;
+        *y = impl->abs_y;
 
       return TRUE;
     }
@@ -1949,7 +1765,7 @@
 
   g_return_if_fail (GDK_IS_WINDOW (window));
 
-  rover = (GdkWindowObject*) window;
+  rover = GDK_WINDOW_OBJECT (window);
   if (x)
     *x = 0;
   if (y)
@@ -1958,8 +1774,9 @@
   if (GDK_WINDOW_DESTROYED (window))
     return;
 
-  while (rover->parent && ((GdkWindowObject*) rover->parent)->parent)
-    rover = (GdkWindowObject *) rover->parent;
+  while (rover->parent && rover->parent->parent)
+    rover = rover->parent;
+
   if (rover->destroyed)
     return;
 
@@ -1972,9 +1789,9 @@
 GdkWindow *
 _gdk_windowing_window_get_pointer (GdkDisplay      *display,
                                    GdkWindow       *window,
-				   gint            *x,
-				   gint            *y,
-				   GdkModifierType *mask)
+                                   gint            *x,
+                                   gint            *y,
+                                   GdkModifierType *mask)
 {
   GdkWindow               *retval = NULL;
   gint                     rx, ry, wx, wy;
@@ -2004,13 +1821,13 @@
 GdkWindow *
 _gdk_windowing_window_at_pointer (GdkDisplay *display,
                                   gint       *win_x,
-				  gint       *win_y)
+                                  gint       *win_y)
 {
   GdkWindow *retval;
   gint       wx, wy;
 
   if (!win_x || !win_y)
-  gdk_directfb_mouse_get_info (&wx, &wy, NULL);
+    gdk_directfb_mouse_get_info (&wx, &wy, NULL);
 
   if (win_x)
     wx = *win_x;
@@ -2036,13 +1853,12 @@
                             gint             *y,
                             GdkModifierType  *mask)
 {
-(void)screen;
-if(screen) {
-	*screen = gdk_display_get_default_screen  (display);
-}
-_gdk_windowing_window_get_pointer (display,
-				   _gdk_windowing_window_at_pointer(display,NULL,NULL),x,y,mask);
+  g_return_if_fail (GDK_DISPLAY_DFB (display) == _gdk_display_dfb);
+
+  *screen = _gdk_screen;
 
+  _gdk_windowing_window_get_pointer (_gdk_display, _gdk_parent_root,
+                                     x, y, mask);
 }
 
 GdkEventMask
@@ -2052,8 +1868,8 @@
 
   if (GDK_WINDOW_DESTROYED (window))
     return 0;
-  else
-    return GDK_WINDOW_OBJECT (window)->event_mask;
+
+  return GDK_WINDOW_OBJECT (window)->event_mask;
 }
 
 void
@@ -2062,12 +1878,10 @@
 {
   g_return_if_fail (GDK_IS_WINDOW (window));
 
-  if (event_mask & GDK_BUTTON_MOTION_MASK)
-    event_mask |= (GDK_BUTTON1_MOTION_MASK |
-                   GDK_BUTTON2_MOTION_MASK |
-                   GDK_BUTTON3_MOTION_MASK);
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
 
-  GDK_WINDOW_OBJECT (window)->event_mask = event_mask;
+  GDK_WINDOW_OBJECT (window)->event_mask = GDK_STRUCTURE_MASK | event_mask;
 }
 
 void
@@ -2076,14 +1890,16 @@
                                gint       x,
                                gint       y)
 {
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_input_shape_combine_mask (GdkWindow *window,
-                                    GdkBitmap *mask,
-                                    gint       x,
-                                    gint       y)
+                                     GdkBitmap *mask,
+                                     gint       x,
+                                     gint       y)
 {
+  D_UNIMPLEMENTED();
 }
 
 void
@@ -2092,38 +1908,30 @@
                                  gint       offset_x,
                                  gint       offset_y)
 {
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_input_shape_combine_region (GdkWindow *window,
-                                      GdkRegion *shape_region,
-                                      gint       offset_x,
-                                      gint       offset_y)
+                                       GdkRegion *shape_region,
+                                       gint       offset_x,
+                                       gint       offset_y)
 {
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_set_override_redirect (GdkWindow *window,
                                   gboolean   override_redirect)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_set_icon_list (GdkWindow *window,
                           GList     *pixbufs)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
+  D_UNIMPLEMENTED();
 }
 
 void
@@ -2132,24 +1940,14 @@
                      GdkPixmap *pixmap,
                      GdkBitmap *mask)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_set_icon_name (GdkWindow   *window,
                           const gchar *name)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
+  D_UNIMPLEMENTED();
 }
 
 void
@@ -2177,23 +1975,13 @@
 void
 gdk_window_stick (GdkWindow *window)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_unstick (GdkWindow *window)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
+  D_UNIMPLEMENTED();
 }
 
 void
@@ -2214,11 +2002,11 @@
   if (impl->window && GDK_WINDOW_IS_MAPPED (window))
     {
       if (gdk_directfb_apply_focus_opacity &&
-	  window == gdk_directfb_focused_window)
-	impl->window->SetOpacity (impl->window,
-				  (impl->opacity >> 1) + (impl->opacity >> 2));
+          window == _gdk_directfb_keyboard_window)
+        impl->window->SetOpacity (impl->window,
+                                  (impl->opacity >> 1) + (impl->opacity >> 2));
       else
-	impl->window->SetOpacity (impl->window, impl->opacity);
+        impl->window->SetOpacity (impl->window, impl->opacity);
     }
 }
 
@@ -2236,63 +2024,64 @@
   toplevel = gdk_directfb_window_find_toplevel (window);
   if (toplevel != _gdk_parent_root)
     {
-      GdkWindowImplDirectFB *impl;
+      GdkWindowObject *private = GDK_WINDOW_OBJECT (window);
 
-      impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (toplevel)->impl);
+      if (private->accept_focus && private->window_type != GDK_WINDOW_TEMP)
+        {
+          GdkWindowImplDirectFB *impl;
+
+          impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (toplevel)->impl);
 
-      impl->window->RequestFocus (impl->window);
+          impl->window->RequestFocus (impl->window);
+        }
     }
 }
 
 void
 gdk_window_maximize (GdkWindow *window)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_unmaximize (GdkWindow *window)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
+  D_UNIMPLEMENTED();
 }
 
 void
-gdk_window_set_type_hint (GdkWindow        *window,
-                          GdkWindowTypeHint hint)
+gdk_window_set_type_hint (GdkWindow         *window,
+                          GdkWindowTypeHint  hint)
 {
+  GdkWindowImplDirectFB *impl;
+
   g_return_if_fail (GDK_IS_WINDOW (window));
 
   if (GDK_WINDOW_DESTROYED (window))
     return;
 
-  GDK_NOTE (MISC, g_print ("gdk_window_set_type_hint: 0x%x: %d\n",
-               GDK_WINDOW_DFB_ID (window), hint));
-
-  ((GdkWindowImplDirectFB *)((GdkWindowObject *)window)->impl)->type_hint = hint;
+  GDK_NOTE (MISC,
+            g_print ("gdk_window_set_type_hint: ",
+                     "0x%x: %d\n", GDK_WINDOW_DFB_ID (window), hint));
 
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
 
-  /* N/A */
+  impl->type_hint = hint;
 }
 
 GdkWindowTypeHint
 gdk_window_get_type_hint (GdkWindow *window)
 {
+  GdkWindowImplDirectFB *impl;
+
   g_return_val_if_fail (GDK_IS_WINDOW (window), GDK_WINDOW_TYPE_HINT_NORMAL);
-  
+
   if (GDK_WINDOW_DESTROYED (window))
     return GDK_WINDOW_TYPE_HINT_NORMAL;
 
-  return GDK_WINDOW_IMPL_DIRECTFB (((GdkWindowObject *) window)->impl)->type_hint;
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  return impl->type_hint;
 }
 
 void
@@ -2317,56 +2106,31 @@
 
 void
 gdk_window_set_skip_taskbar_hint (GdkWindow *window,
-				  gboolean   skips_taskbar)
+                                  gboolean   skips_taskbar)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_set_skip_pager_hint (GdkWindow *window,
-				gboolean   skips_pager)
+                                gboolean   skips_pager)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
+  D_UNIMPLEMENTED();
 }
 
-
 void
 gdk_window_set_group (GdkWindow *window,
                       GdkWindow *leader)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  g_return_if_fail (GDK_IS_WINDOW (leader));
- g_warning(" DirectFb set_group groups not supported \n");
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
+  D_UNIMPLEMENTED();
 }
 
-GdkWindow * gdk_window_get_group (GdkWindow *window)
-{
- g_warning(" DirectFb get_group groups not supported \n");
- return window;	
-}
-
-void
-gdk_fb_window_set_child_handler (GdkWindow             *window,
-                                 GdkWindowChildChanged  changed,
-                                 GdkWindowChildGetPos   get_pos,
-                                 gpointer               user_data)
+GdkWindow *
+gdk_window_get_group (GdkWindow *window)
 {
-  GdkWindowChildHandlerData *data;
-
-  g_return_if_fail (GDK_IS_WINDOW (window));
+  D_UNIMPLEMENTED();
 
-  data = g_new (GdkWindowChildHandlerData, 1);
-  data->changed   = changed;
-  data->get_pos   = get_pos;
-  data->user_data = user_data;
-
-  g_object_set_data_full (G_OBJECT (window), "gdk-window-child-handler",
-                          data, (GDestroyNotify) g_free);
+  return window;
 }
 
 void
@@ -2386,7 +2150,7 @@
 
 gboolean
 gdk_window_get_decorations (GdkWindow       *window,
-			    GdkWMDecoration *decorations)
+                            GdkWMDecoration *decorations)
 {
   GdkWMDecoration *dec;
 
@@ -2398,6 +2162,7 @@
       *decorations = *dec;
       return TRUE;
     }
+
   return FALSE;
 }
 
@@ -2405,46 +2170,38 @@
 gdk_window_set_functions (GdkWindow     *window,
                           GdkWMFunction  functions)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  /* N/A */
-  g_message("unimplemented %s", G_STRLOC);
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_set_child_shapes (GdkWindow *window)
 {
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_merge_child_shapes (GdkWindow *window)
 {
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_set_child_input_shapes (GdkWindow *window)
 {
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_merge_child_input_shapes (GdkWindow *window)
 {
+  D_UNIMPLEMENTED();
 }
 
 gboolean
 gdk_window_set_static_gravities (GdkWindow *window,
                                  gboolean   use_static)
 {
-  g_return_val_if_fail (GDK_IS_WINDOW (window), FALSE);
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return FALSE;
-
-  /* N/A */
-  g_message("unimplemented %s", G_STRLOC);
+  D_UNIMPLEMENTED();
 
   return FALSE;
 }
@@ -2457,12 +2214,7 @@
                               gint           root_y,
                               guint32        timestamp)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  g_message("unimplemented %s", G_STRLOC);
+  D_UNIMPLEMENTED();
 }
 
 void
@@ -2472,25 +2224,9 @@
                             gint       root_y,
                             guint32    timestamp)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  g_message("unimplemented %s", G_STRLOC);
+  D_UNIMPLEMENTED();
 }
 
-/**
- * gdk_window_get_frame_extents:
- * @window: a #GdkWindow
- * @rect: rectangle to fill with bounding box of the window frame
- *
- * Obtains the bounding box of the window, including window manager
- * titlebar/borders if any. The frame position is given in root window
- * coordinates. To get the position of the window itself (rather than
- * the frame) in root window coordinates, use gdk_window_get_origin().
- *
- **/
 void
 gdk_window_get_frame_extents (GdkWindow    *window,
                               GdkRectangle *rect)
@@ -2506,8 +2242,9 @@
 
   private = GDK_WINDOW_OBJECT (window);
 
-  while (private->parent && ((GdkWindowObject*) private->parent)->parent)
-    private = (GdkWindowObject*) private->parent;
+  while (private->parent && private->parent->parent)
+    private = private->parent;
+
   if (GDK_WINDOW_DESTROYED (window))
     return;
 
@@ -2523,16 +2260,16 @@
  * Given a directfb window and a subsurface of that window
  * create a gdkwindow child wrapper
  */
-#if (DIRECTFB_MAJOR_VERSION >= 1)
-GdkWindow *gdk_directfb_create_child_window(GdkWindow *parent,
-                                IDirectFBSurface *subsurface)
+GdkWindow *
+gdk_directfb_create_child_window(GdkWindow        *parent,
+                                 IDirectFBSurface *subsurface)
 {
   GdkWindow             *window;
   GdkWindowObject       *private;
   GdkWindowObject       *parent_private;
   GdkWindowImplDirectFB *impl;
   GdkWindowImplDirectFB *parent_impl;
-  gint x,y,w,h;
+  gint                   x, y, w, h;
 
   g_return_val_if_fail (parent != NULL, NULL);
 
@@ -2542,8 +2279,8 @@
   parent_impl = GDK_WINDOW_IMPL_DIRECTFB (parent_private->impl);
   private->parent = parent_private;
 
-  subsurface->GetPosition(subsurface,&x,&y);
-  subsurface->GetSize(subsurface,&w,&h);
+  subsurface->GetPosition (subsurface, &x, &y);
+  subsurface->GetSize (subsurface, &w, &h);
 
   impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
   impl->drawable.wrapper = GDK_DRAWABLE (window);
@@ -2551,205 +2288,198 @@
   private->x = x;
   private->y = y;
 
-  _gdk_directfb_calc_abs (window);
+  gdk_directfb_calc_abs (window);
 
   impl->drawable.width  = w;
   impl->drawable.height = h;
+
   private->window_type = GDK_WINDOW_CHILD;
+
   impl->drawable.surface = subsurface;
-  impl->drawable.format = parent_impl->drawable.format;
+  impl->drawable.format  = parent_impl->drawable.format;
+
   private->depth = parent_private->depth;
+
   gdk_drawable_set_colormap (GDK_DRAWABLE (window),
-        gdk_drawable_get_colormap (parent));
+                             gdk_drawable_get_colormap (parent));
   gdk_window_set_cursor (window, NULL);
   parent_private->children = g_list_prepend (parent_private->children,window);
-  /*we hold a reference count on ourselves */
+
+  /* we hold a reference count on ourselves */
   g_object_ref (window);
 
   return window;
-
 }
-#endif
 
-/*
- * The wrapping is not perfect since directfb does not give full access
- * to the current state of a window event mask etc need to fix dfb
- */
 GdkWindow *
-gdk_window_foreign_new_for_display (GdkDisplay* display,GdkNativeWindow anid)
+gdk_window_foreign_new_for_display (GdkDisplay      *display,
+                                    GdkNativeWindow  anid)
 {
-    GdkWindow *window = NULL;
-    GdkWindow              *parent =NULL;
-    GdkWindowObject       *private =NULL;
-    GdkWindowObject       *parent_private =NULL;
-    GdkWindowImplDirectFB *parent_impl =NULL;
-    GdkWindowImplDirectFB *impl =NULL;
-    DFBWindowOptions options;
-    DFBResult        ret;
-    GdkDisplayDFB * gdkdisplay =  _gdk_display;
-    IDirectFBWindow *dfbwindow;
-
-    window = gdk_window_lookup (anid);
+  DFBResult              ret;
+  DFBWindowOptions       options;
+  GdkWindow             *window         = NULL;
+  GdkWindow             *parent         = NULL;
+  GdkWindowObject       *private        = NULL;
+  GdkWindowObject       *parent_private = NULL;
+  GdkWindowImplDirectFB *impl           = NULL;
+  GdkDisplayDFB         *gdkdisplay     = _gdk_display_dfb;
+  IDirectFBWindow       *dfbwindow;
+
+  window = gdk_window_lookup (anid);
+
+  if (window)
+    {
+      g_object_ref (window);
+      return window;
+    }
+  if (display != NULL)
+    gdkdisplay = GDK_DISPLAY_DFB (display);
 
-    if (window) {
-        g_object_ref (window);
-        return window;
+  ret = gdkdisplay->layer->GetWindow (gdkdisplay->layer, anid, &dfbwindow);
+  if (ret != DFB_OK)
+    {
+      DirectFBError ("gdk_window_foreign_new_for_display: "
+                     "GetWindow() failed", ret);
+      return NULL;
     }
-    if( display != NULL )
-            gdkdisplay = GDK_DISPLAY_DFB(display);
 
-    ret = gdkdisplay->layer->GetWindow (gdkdisplay->layer,
-                    (DFBWindowID)anid,&dfbwindow);
+  parent = _gdk_parent_root;
 
-    if (ret != DFB_OK) {
-        DirectFBError ("gdk_window_new: Layer->GetWindow failed", ret);
-        return NULL;
-    }
+  if (parent)
+    parent_private = GDK_WINDOW_OBJECT (parent);
+
+  window = g_object_new (GDK_TYPE_WINDOW, NULL);
+  /* we hold a reference count on ourselves */
+  g_object_ref (window);
+  private = GDK_WINDOW_OBJECT (window);
+  private->parent      = parent_private;
+  private->window_type = GDK_WINDOW_TOPLEVEL;
+  impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
+  impl->drawable.wrapper = GDK_DRAWABLE (window);
+  impl->window           = dfbwindow;
+  dfbwindow->GetOptions (dfbwindow, &options);
+  dfbwindow->GetPosition (dfbwindow, &private->x, &private->y);
+  dfbwindow->GetSize (dfbwindow, &impl->drawable.width, &impl->drawable.height);
 
-    parent = _gdk_parent_root;
 
-    if(parent) {
-        parent_private = GDK_WINDOW_OBJECT (parent);
-        parent_impl = GDK_WINDOW_IMPL_DIRECTFB (parent_private->impl);
-    }
-
-    window = g_object_new (GDK_TYPE_WINDOW, NULL);
-    /* we hold a reference count on ourselves */
-    g_object_ref (window);
-    private = GDK_WINDOW_OBJECT (window);
-    private->parent = parent_private;
-    private->window_type = GDK_WINDOW_TOPLEVEL;
-    impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
-
-    impl->drawable.wrapper = GDK_DRAWABLE (window);
-    impl->window = dfbwindow;
-    dfbwindow->GetOptions(dfbwindow,&options);
-    dfbwindow->GetPosition(dfbwindow,&private->x,&private->y);
-    dfbwindow->GetSize(dfbwindow,&impl->drawable.width,&impl->drawable.height);
-
-
-    private->input_only = FALSE;
-
-    if( dfbwindow->GetSurface (dfbwindow, &impl->drawable.surface) == DFB_UNSUPPORTED ){
-        private->input_only = TRUE;
-        impl->drawable.surface = NULL;
-    }
-    /*
-     * Position ourselevs
-     */
-    _gdk_directfb_calc_abs (window);
-
-    /* We default to all events least surprise to the user 
-     * minus the poll for motion events 
-     */
-    gdk_window_set_events (window, (GDK_ALL_EVENTS_MASK ^ GDK_POINTER_MOTION_HINT_MASK));
+  private->input_only = FALSE;
 
-    if (impl->drawable.surface)
+  ret = dfbwindow->GetSurface (dfbwindow, &impl->drawable.surface);
+  if (ret == DFB_UNSUPPORTED)
+    {
+      private->input_only = TRUE;
+      impl->drawable.surface = NULL;
+    }
+  gdk_directfb_calc_abs (window);
+
+  gdk_window_set_events (window,
+                         GDK_ALL_EVENTS_MASK ^ GDK_POINTER_MOTION_HINT_MASK);
+
+  if (impl->drawable.surface)
     {
       impl->drawable.surface->GetPixelFormat (impl->drawable.surface,
-					      &impl->drawable.format);
+                                              &impl->drawable.format);
 
-  	  private->depth = DFB_BITS_PER_PIXEL(impl->drawable.format);
-      if( parent )
-        gdk_drawable_set_colormap (GDK_DRAWABLE (window), gdk_drawable_get_colormap (parent));
+      private->depth = GDK_DFB_BITS_PER_PIXEL (impl->drawable.format);
+      if (parent)
+        gdk_drawable_set_colormap (GDK_DRAWABLE (window),
+                                   gdk_drawable_get_colormap (parent));
       else
-        gdk_drawable_set_colormap (GDK_DRAWABLE (window), gdk_colormap_get_system());
+        gdk_drawable_set_colormap (GDK_DRAWABLE (window),
+                                   gdk_colormap_get_system());
     }
 
-    //can  be null for the soft cursor window itself when
-    //running a gtk directfb wm
-    if( gdk_display_get_default() != NULL ) {
-        gdk_window_set_cursor (window,NULL);
-    }
+  if (gdk_display_get_default () != NULL)
+    gdk_window_set_cursor (window, NULL);
 
-    if (parent_private)
-        parent_private->children = g_list_prepend (parent_private->children,
+  if (parent_private)
+    parent_private->children = g_list_prepend (parent_private->children,
                                                window);
-    impl->dfb_id = (DFBWindowID)anid; 
-    gdk_directfb_window_id_table_insert (impl->dfb_id, window);
-    gdk_directfb_event_windows_add (window);
+  impl->dfb_id = anid;
+  gdk_directfb_window_id_table_insert (impl->dfb_id, window);
+  gdk_directfb_event_windows_add (window);
 
-    return window;
+  return window;
 }
 
 GdkWindow *
-gdk_window_lookup_for_display (GdkDisplay *display,GdkNativeWindow anid)
+gdk_window_lookup_for_display (GdkDisplay      *display,
+                               GdkNativeWindow  anid)
 {
-  return gdk_directfb_window_id_table_lookup ((DFBWindowID) anid);
+  return gdk_directfb_window_id_table_lookup (anid);
 }
 
 GdkWindow *
 gdk_window_lookup (GdkNativeWindow anid)
 {
-  return gdk_directfb_window_id_table_lookup ((DFBWindowID) anid);
+  return gdk_directfb_window_id_table_lookup (anid);
 }
 
-IDirectFBWindow *gdk_directfb_window_lookup(GdkWindow *window )
+IDirectFBWindow *
+gdk_directfb_window_lookup (GdkWindow *window)
 {
   GdkWindowObject       *private;
   GdkWindowImplDirectFB *impl;
-  g_return_val_if_fail (GDK_IS_WINDOW (window),NULL);
+
+  g_return_val_if_fail (GDK_IS_WINDOW (window), NULL);
+
   private = GDK_WINDOW_OBJECT (window);
   impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
   return impl->window;
 }
 
-IDirectFBSurface *gdk_directfb_surface_lookup(GdkWindow *window)
+IDirectFBSurface *
+gdk_directfb_surface_lookup (GdkWindow *window)
 {
   GdkWindowObject       *private;
   GdkWindowImplDirectFB *impl;
-  g_return_val_if_fail (GDK_IS_WINDOW (window),NULL);
+
+  g_return_val_if_fail (GDK_IS_WINDOW (window), NULL);
+
   private = GDK_WINDOW_OBJECT (window);
   impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
   return impl->drawable.surface;
 }
 
 void
 gdk_window_fullscreen (GdkWindow *window)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  g_warning ("gdk_window_fullscreen() not implemented.\n");
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_unfullscreen (GdkWindow *window)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  /* g_warning ("gdk_window_unfullscreen() not implemented.\n");*/
+  D_UNIMPLEMENTED();
 }
 
 void
-gdk_window_set_keep_above (GdkWindow *window, gboolean setting)
+gdk_window_set_keep_above (GdkWindow *window,
+                           gboolean   setting)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  static gboolean first_call = TRUE;
-  if (first_call) {
-  g_warning ("gdk_window_set_keep_above() not implemented.\n");
-	first_call=FALSE;
-  }
-	
+  D_UNIMPLEMENTED();
 }
 
 void
-gdk_window_set_keep_below (GdkWindow *window, gboolean setting)
+gdk_window_set_keep_below (GdkWindow *window,
+                           gboolean   setting)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  static gboolean first_call = TRUE;
-  if (first_call) {
-  g_warning ("gdk_window_set_keep_below() not implemented.\n");
-  first_call=FALSE;
-  }
-  
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_enable_synchronized_configure (GdkWindow *window)
 {
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_configure_finished (GdkWindow *window)
 {
+  D_UNIMPLEMENTED();
 }
 
 void
@@ -2758,218 +2488,234 @@
                           gint        x,
                           gint        y)
 {
-  g_warning ("gdk_display_warp_pointer() not implemented.\n");
+  D_UNIMPLEMENTED();
 }
 
 void
 gdk_window_set_urgency_hint (GdkWindow *window,
                              gboolean   urgent)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
-  g_return_if_fail (GDK_WINDOW_TYPE (window) != GDK_WINDOW_CHILD);
-
-  if (GDK_WINDOW_DESTROYED (window))
-    return;
-
-  g_warning ("gdk_window_set_urgency_hint() not implemented.\n");
-
+  D_UNIMPLEMENTED();
 }
 
 static void
-gdk_window_impl_directfb_invalidate_maybe_recurse (GdkPaintable *paintable,
-                         GdkRegion    *region,
-                         gboolean    (*child_func) (GdkWindow *, gpointer),
-                         gpointer      user_data)
+gdk_window_impl_directfb_invalidate_maybe_recurse (GdkPaintable  *paintable,
+                                                   GdkRegion     *region,
+                                                   gboolean     (*child_func) (
+                                                                    GdkWindow *,
+                                                                    gpointer),
+                                                   gpointer       user_data)
 {
-  GdkWindow *window;
-  GdkWindowObject *private;
-  GdkWindowImplDirectFB *wimpl;
+  GdkWindow               *window;
+  GdkWindowObject         *private;
+  GdkWindowImplDirectFB   *wimpl;
   GdkDrawableImplDirectFB *impl;
+  GdkRegion                visible_region;
+  GList                   *tmp_list;
 
   wimpl = GDK_WINDOW_IMPL_DIRECTFB (paintable);
-  impl = (GdkDrawableImplDirectFB *)wimpl;
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (wimpl);
   window = wimpl->gdkWindow;
-  private = (GdkWindowObject *)window;
-
-  GdkRegion *visible_region;
-  GList *tmp_list;
+  private = GDK_WINDOW_OBJECT (window);
 
   g_return_if_fail (window != NULL);
   g_return_if_fail (GDK_IS_WINDOW (window));
 
   if (GDK_WINDOW_DESTROYED (window))
     return;
-  
+
   if (private->input_only || !GDK_WINDOW_IS_MAPPED (window))
     return;
 
-  visible_region = gdk_drawable_get_visible_region (window);
-  gdk_region_intersect (visible_region, region);
+  D_DEBUG_AT( GDKDFB_Updates, "%s( %p ) <- [" GDKDFB_WIMPL_FORM "]\n", __FUNCTION__,
+              paintable, GDKDFB_WIMPL_V (wimpl) );
+
+  temp_region_init_rectangle_vals (&visible_region,
+                                   0, 0,
+                                   impl->width, impl->height);
+
+  gdk_region_intersect (&visible_region, region);
 
   tmp_list = private->children;
   while (tmp_list)
     {
-      GdkWindowObject *child = tmp_list->data;
-      
+      GdkWindowObject         *child = tmp_list->data;
+      GdkDrawableImplDirectFB *cimpl = GDK_DRAWABLE_IMPL_DIRECTFB (child->impl);
+
       if (!child->input_only)
-	{
-	  GdkRegion *child_region;
-	  GdkRectangle child_rect;
-	  
-	  gdk_window_get_position ((GdkWindow *)child,
-				   &child_rect.x, &child_rect.y);
-	  gdk_drawable_get_size ((GdkDrawable *)child,
-				 &child_rect.width, &child_rect.height);
-
-	  child_region = gdk_region_rectangle (&child_rect);
-	  
-	  /* remove child area from the invalid area of the parent */
-	  if (GDK_WINDOW_IS_MAPPED (child) && !child->shaped)
-	    gdk_region_subtract (visible_region, child_region);
-	  
-	  if (child_func && (*child_func) ((GdkWindow *)child, user_data))
-	    {
-	      gdk_region_offset (region, - child_rect.x, - child_rect.y);
-	      gdk_region_offset (child_region, - child_rect.x, - child_rect.y);
-	      gdk_region_intersect (child_region, region);
-	      
-	      gdk_window_invalidate_maybe_recurse ((GdkWindow *)child,
-						   child_region, child_func, user_data);
-	      
-	      gdk_region_offset (region, child_rect.x, child_rect.y);
-	    }
+        {
+          GdkRegion child_region;
+          temp_region_init_rectangle_vals (&child_region,
+                                           child->x, child->y,
+                                           cimpl->width, cimpl->height);
+
+          /* remove child area from the invalid area of the parent */
+          if (GDK_WINDOW_IS_MAPPED (child) && !child->shaped)
+            gdk_region_subtract (&visible_region, &child_region);
 
-	  gdk_region_destroy (child_region);
-	}
+          if (child_func && (*child_func) (GDK_WINDOW (child), user_data))
+            {
+              gdk_region_intersect (&child_region, region);
+              gdk_region_offset (&child_region, - child->x, - child->y);
+
+              gdk_window_invalidate_maybe_recurse (GDK_WINDOW (child),
+                                                   &child_region, child_func,
+                                                   user_data);
+            }
+
+          temp_region_deinit (&child_region);
+        }
 
       tmp_list = tmp_list->next;
     }
-  
-  if (!gdk_region_empty (visible_region))
+
+  if (!gdk_region_empty (&visible_region))
     {
-      
+
       if (private->update_area)
-	{
-	  gdk_region_union (private->update_area, visible_region);
-	}
+        {
+          gdk_region_union (private->update_area, &visible_region);
+        }
       else
-	{
-	  update_windows = g_slist_prepend (update_windows, window);
-	  private->update_area = gdk_region_copy (visible_region);
-	  gdk_window_schedule_update (window);
-	}
+        {
+          update_windows = g_slist_prepend (update_windows, window);
+          private->update_area = gdk_region_copy (&visible_region);
+          gdk_window_schedule_update (window);
+        }
     }
-    gdk_region_destroy (visible_region);
-}
 
+  temp_region_deinit (&visible_region);
+}
 
 static void
 gdk_window_impl_directfb_process_updates (GdkPaintable *paintable,
-                    gboolean      update_children)
+                                          gboolean      update_children)
 {
-  GdkWindow *window;
-  GdkWindowObject *private;
-  GdkWindowImplDirectFB *wimpl;
+  GdkWindow               *window;
+  GdkWindowObject         *private;
+  GdkWindowImplDirectFB   *wimpl;
   GdkDrawableImplDirectFB *impl;
+  GdkRegion               *update_area;
 
   wimpl = GDK_WINDOW_IMPL_DIRECTFB (paintable);
-  impl = (GdkDrawableImplDirectFB *)wimpl;
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (wimpl);
   window = wimpl->gdkWindow;
-  private = (GdkWindowObject *)window;
-  gboolean save_region = FALSE;
+  private = GDK_WINDOW_OBJECT (window);
+
+  D_DEBUG_AT( GDKDFB_Updates, "%s( %p, %schildren ) <- [" GDKDFB_WIMPL_FORM "]\n", __FUNCTION__,
+              paintable, update_children ? "update " : "no ", GDKDFB_WIMPL_V (wimpl) );
 
   /* If an update got queued during update processing, we can get a
    * window in the update queue that has an empty update_area.
    * just ignore it.
    */
-  if (private->update_area)
+  if (!private->update_area)
+    return;
+
+  update_area = private->update_area;
+  private->update_area = NULL;
+
+  D_DEBUG_AT( GDKDFB_Updates, "  -> update area    " GDKDFB_REGION_FORM "\n", GDKDFB_REGION_V (update_area) );
+
+  if (_gdk_event_func && gdk_window_is_viewable (window))
     {
-      GdkRegion *update_area = private->update_area;
-      private->update_area = NULL;
-      
-      if (_gdk_event_func && gdk_window_is_viewable (window))
-	{
-	  GdkRectangle window_rect;
-	  GdkRegion *expose_region;
-	  GdkRegion *window_region;
-          gint width, height;
-	  save_region = _gdk_windowing_window_queue_antiexpose (window, update_area);
-
-	  if (save_region)
-	    expose_region = gdk_region_copy (update_area);
-	  else
-	    expose_region = update_area;
-	  
-          gdk_drawable_get_size (GDK_DRAWABLE (private), &width, &height);
-
-	  window_rect.x = 0;
-	  window_rect.y = 0;
-	  window_rect.width = width;
-	  window_rect.height = height;
-
-	  window_region = gdk_region_rectangle (&window_rect);
-	  gdk_region_intersect (expose_region,
-				window_region);
-	  gdk_region_destroy (window_region);
-	  
-	  if (!gdk_region_empty (expose_region) &&
-	      (private->event_mask & GDK_EXPOSURE_MASK))
-	    {
-	      GdkEvent event;
-	      
-	      event.expose.type = GDK_EXPOSE;
-	      event.expose.window = g_object_ref (window);
-	      event.expose.send_event = FALSE;
-	      event.expose.count = 0;
-	      event.expose.region = expose_region;
-	      gdk_region_get_clipbox (expose_region, &event.expose.area);
-	      (*_gdk_event_func) (&event, _gdk_event_data);
-	      
-	      g_object_unref (window);
-	    }
-
-	  if (expose_region != update_area)
-	    gdk_region_destroy (expose_region);
-	}
-      if (!save_region)
-	gdk_region_destroy (update_area);
+      GdkRegion *expose_region = update_area;
+      GdkRegion  window_region;
+
+      temp_region_init_rectangle_vals (&window_region,
+                                       0, 0,
+                                       impl->width, impl->height);
+
+      gdk_region_intersect ( expose_region, &window_region );
+
+      temp_region_deinit (&window_region);
+
+      D_DEBUG_AT( GDKDFB_Updates, "  -> expose region  " GDKDFB_REGION_FORM "\n", GDKDFB_REGION_V (expose_region) );
+
+      if (!gdk_region_empty (expose_region) && (private->event_mask & GDK_EXPOSURE_MASK))
+        {
+          GdkEvent event;
+
+          event.expose.type       = GDK_EXPOSE;
+          event.expose.window     = g_object_ref (window);
+          event.expose.send_event = FALSE;
+          event.expose.count      = 0;
+          event.expose.region     = expose_region;
+          gdk_region_get_clipbox (expose_region, &event.expose.area);
+          (*_gdk_event_func) (&event, _gdk_event_data);
+
+          g_object_unref (window);
+        }
+
+      if (expose_region != update_area)
+        gdk_region_destroy (expose_region);
     }
-}
 
+  gdk_region_destroy (update_area);
+}
 
 static void
 gdk_window_impl_directfb_begin_paint_region (GdkPaintable *paintable,
-					   GdkRegion    *region)
+                                             GdkRegion    *region)
 {
   GdkDrawableImplDirectFB *impl;
-  GdkWindowImplDirectFB *wimpl;
+  GdkWindowImplDirectFB   *wimpl;
   gint                     i;
 
-
-  g_assert (region != NULL );
   wimpl = GDK_WINDOW_IMPL_DIRECTFB (paintable);
-  impl = (GdkDrawableImplDirectFB *)wimpl;
-  impl->buffered = TRUE;
-  impl->paint_depth++;
+  impl  = GDK_DRAWABLE_IMPL_DIRECTFB (wimpl);
 
-  if (!region)
-    return;
+  g_return_if_fail (region != NULL);
+
+  D_DEBUG_AT( GDKDFB_Paintable, "%s( %p ) <- [" GDKDFB_WIMPL_FORM "] (%d)\n", __FUNCTION__, paintable,
+              GDKDFB_WIMPL_V (wimpl), impl->paint_depth );
 
-  if (impl->paint_region)
-    gdk_region_union (impl->paint_region, region);
+  /* When it's buffered... */
+  if (impl->buffered)
+    {
+      /* ...we're already painting on it! */
+      g_assert (impl->paint_depth > 0);
+
+      D_DEBUG_AT( GDKDFB_Updates, "  -> already        " GDKDFB_REGION_FORM "\n", GDKDFB_REGION_V (&impl->paint_region) );
+
+      /* Add the new region to the paint region... */
+      gdk_region_union (&impl->paint_region, region);
+    }
   else
-    impl->paint_region = gdk_region_copy (region);
+    {
+      /* ...otherwise it's the first time! */
+      g_assert (impl->paint_depth == 0);
+
+      /* Generate the clip region for painting around child windows. */
+      gdk_directfb_clip_region (GDK_DRAWABLE (paintable),
+                                NULL, NULL, &impl->clip_region);
+
+      /* Initialize the paint region with the new one... */
+      temp_region_init_copy (&impl->paint_region, region);
+
+      impl->buffered = TRUE;
+    }
+
+  D_DEBUG_AT( GDKDFB_Updates, "  -> painting       " GDKDFB_REGION_FORM "\n", GDKDFB_REGION_V (&impl->paint_region) );
+
+  /* ...but clip the initial/compound result against the clip region. */
+  gdk_region_intersect (&impl->paint_region, &impl->clip_region);
+
+  D_DEBUG_AT( GDKDFB_Updates, "  -> clipped        " GDKDFB_REGION_FORM "\n", GDKDFB_REGION_V (&impl->paint_region) );
+
+  impl->paint_depth++;
 
   for (i = 0; i < region->numRects; i++)
     {
       GdkRegionBox *box = &region->rects[i];
 
-      _gdk_windowing_window_clear_area (GDK_WINDOW(wimpl->gdkWindow),
+      D_DEBUG_AT( GDKDFB_Paintable, "  -> [%2d] %4d,%4d-%4dx%4d\n", i, GDKDFB_RECTANGLE_VALS_FROM_BOX( box ) );
+
+      _gdk_windowing_window_clear_area (GDK_WINDOW (wimpl->gdkWindow),
                                         box->x1,
                                         box->y1,
                                         box->x2 - box->x1,
                                         box->y2 - box->y1);
-                                        
     }
 }
 
@@ -2977,77 +2723,131 @@
 gdk_window_impl_directfb_end_paint (GdkPaintable *paintable)
 {
   GdkDrawableImplDirectFB *impl;
+  GdkWindowImplDirectFB   *wimpl;
+
+  wimpl = GDK_WINDOW_IMPL_DIRECTFB (paintable);
+  impl  = GDK_DRAWABLE_IMPL_DIRECTFB (wimpl);
 
-  impl = GDK_DRAWABLE_IMPL_DIRECTFB (paintable);
+  D_DEBUG_AT( GDKDFB_Paintable, "%s( %p ) <- [" GDKDFB_WIMPL_FORM "] (%d)\n", __FUNCTION__,
+              paintable, GDKDFB_WIMPL_V (wimpl), impl->paint_depth );
 
   g_return_if_fail (impl->paint_depth > 0);
 
+  g_assert (impl->buffered);
+
   impl->paint_depth--;
 
+#if GDK_DIRECTFB_GROUPED_FLIPS
   if (impl->paint_depth == 0)
     {
       impl->buffered = FALSE;
 
-      if (impl->paint_region)
+      temp_region_deinit (&impl->clip_region);
+
+      if (impl->paint_region.numRects)
         {
-          DFBRegion reg = { impl->paint_region->extents.x1,
-                            impl->paint_region->extents.y1,
-                            impl->paint_region->extents.x2 ,
-                            impl->paint_region->extents.y2 };
-
-          impl->surface->Flip(impl->surface, &reg,0);
-          gdk_region_destroy (impl->paint_region);
-          impl->paint_region = NULL;
+          GdkWindow *window = GDK_WINDOW (impl->wrapper);
+
+          if (GDK_IS_WINDOW (window))
+            {
+              GdkWindowObject *top;
+
+              top = GDK_WINDOW_OBJECT (gdk_window_get_toplevel (window));
+
+              if (top)
+                {
+                  DFBRegion              reg;
+                  GdkWindowImplDirectFB *wimpl;
+
+                  wimpl = GDK_WINDOW_IMPL_DIRECTFB (top->impl);
+
+                  reg.x1 = impl->abs_x - top->x +
+                           impl->paint_region.extents.x1;
+                  reg.y1 = impl->abs_y - top->y +
+                           impl->paint_region.extents.y1;
+                  reg.x2 = impl->abs_x - top->x +
+                           impl->paint_region.extents.x2 - 1;
+                  reg.y2 = impl->abs_y - top->y +
+                           impl->paint_region.extents.y2 - 1;
+
+                  D_DEBUG_AT( GDKDFB_Paintable, "  -> queue flip     " DFB_RECT_FORMAT "\n", DFB_RECTANGLE_VALS_FROM_REGION (&reg) );
+
+                  dfb_updates_add (&wimpl->flips, &reg);
+                }
+            }
+
+          temp_region_reset (&impl->paint_region);
         }
     }
-}
+#else
+  if (impl->paint_depth == 0)
+    {
+      impl->buffered = FALSE;
+
+      if (impl->paint_region.numRects)
+        {
+          DFBRegion reg = { impl->paint_region.extents.x1,
+                            impl->paint_region.extents.y1,
+                            impl->paint_region.extents.x2 - 1,
+                            impl->paint_region.extents.y2 - 1 };
 
+          D_DEBUG_AT( GDKDFB_Paintable, "  -> flip           " DFB_RECT_FORMAT "\n", DFB_RECTANGLE_VALS_FROM_REGION (&reg) );
+
+          impl->surface->Flip (impl->surface, &reg, DSFLIP_NONE);
+
+          temp_region_reset (&impl->paint_region);
+        }
+    }
+#endif
+  else
+    D_DEBUG_AT( GDKDFB_Paintable, "  -> depth is still %d\n", impl->paint_depth );
+}
 
 static void
 gdk_window_impl_directfb_paintable_init (GdkPaintableIface *iface)
 {
-  iface->begin_paint_region = gdk_window_impl_directfb_begin_paint_region;
-  iface->end_paint = gdk_window_impl_directfb_end_paint;
-
-  iface->invalidate_maybe_recurse = gdk_window_impl_directfb_invalidate_maybe_recurse;
-  iface->process_updates = gdk_window_impl_directfb_process_updates;
+  iface->begin_paint_region       = gdk_window_impl_directfb_begin_paint_region;
+  iface->end_paint                = gdk_window_impl_directfb_end_paint;
+  iface->invalidate_maybe_recurse =
+    gdk_window_impl_directfb_invalidate_maybe_recurse;
+  iface->process_updates          = gdk_window_impl_directfb_process_updates;
 }
 
 void
 gdk_window_beep (GdkWindow *window)
 {
-  gdk_display_beep (gdk_display_get_default());
+  gdk_display_beep (gdk_display_get_default ());
 }
 
 void
 gdk_window_set_opacity (GdkWindow *window,
-			gdouble    opacity)
+                        gdouble    opacity)
 {
-  GdkDisplay *display;
   guint8 cardinal;
-  
+
   g_return_if_fail (GDK_IS_WINDOW (window));
 
   if (GDK_WINDOW_DESTROYED (window))
     return;
 
-  display = gdk_drawable_get_display (window);
+  gdk_drawable_get_display (window);
 
   if (opacity < 0)
     opacity = 0;
   else if (opacity > 1)
     opacity = 1;
+
   cardinal = opacity * 0xff;
-  gdk_directfb_window_set_opacity(window,cardinal);
+
+  gdk_directfb_window_set_opacity (window, cardinal);
 }
 
 void
 _gdk_windowing_window_set_composited (GdkWindow *window,
                                       gboolean   composited)
 {
+  D_UNIMPLEMENTED();
 }
 
-
 #define __GDK_WINDOW_X11_C__
 #include "gdkaliasdef.c"
-
--- gtk+-2.12.12.orig/gdk/directfb/gdkwindowid.c
+++ gtk+-2.12.12/gdk/directfb/gdkwindowid.c
@@ -35,14 +35,19 @@
 #include "gdkdirectfb.h"
 #include "gdkprivate-directfb.h"
 
+D_DEBUG_DOMAIN( GDKDFB_WinIDTable,  "GDKDFB/WinIDTable",  "GDK DirectFB Window ID Table" );
+D_DEBUG_DOMAIN( GDKDFB_WinIDLookup, "GDKDFB/WinIDLookup", "GDK DirectFB Window ID Table Lookups" );
 
 static GHashTable *window_id_ht = NULL;
 
-
 void
 gdk_directfb_window_id_table_insert (DFBWindowID  dfb_id,
                                      GdkWindow   *window)
 {
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  D_DEBUG_AT( GDKDFB_WinIDTable, "%s( %u, %p )\n", __FUNCTION__, dfb_id, window );
+
   if (!window_id_ht)
     window_id_ht = g_hash_table_new (g_direct_hash, g_direct_equal);
 
@@ -52,6 +57,8 @@
 void
 gdk_directfb_window_id_table_remove (DFBWindowID dfb_id)
 {
+  D_DEBUG_AT( GDKDFB_WinIDTable, "%s( %u )\n", __FUNCTION__, dfb_id );
+
   if (window_id_ht)
     g_hash_table_remove (window_id_ht, GUINT_TO_POINTER (dfb_id));
 }
@@ -61,9 +68,12 @@
 {
   GdkWindow *window = NULL;
 
+  D_DEBUG_AT( GDKDFB_WinIDLookup, "%s( %u )\n", __FUNCTION__, dfb_id );
+
   if (window_id_ht)
-    window = (GdkWindow *) g_hash_table_lookup (window_id_ht,
-                                                GUINT_TO_POINTER (dfb_id));
+    window = g_hash_table_lookup (window_id_ht, GUINT_TO_POINTER (dfb_id));
+
+  D_DEBUG_AT( GDKDFB_WinIDLookup, "  -> %p\n", window );
 
   return window;
 }
--- gtk+-2.12.12.orig/gdk/gdkdraw.c
+++ gtk+-2.12.12/gdk/gdkdraw.c
@@ -32,7 +32,6 @@
 #include "gdkinternals.h"
 #include "gdkwindow.h"
 #include "gdkscreen.h"
-#include "gdk-pixbuf-private.h"
 #include "gdkpixbuf.h"
 #include "gdkalias.h"
 
@@ -1502,20 +1501,20 @@
   GdkRectangle tmp_rect;
 				       
   g_return_if_fail (GDK_IS_PIXBUF (pixbuf));
-  g_return_if_fail (pixbuf->colorspace == GDK_COLORSPACE_RGB);
-  g_return_if_fail (pixbuf->n_channels == 3 || pixbuf->n_channels == 4);
-  g_return_if_fail (pixbuf->bits_per_sample == 8);
+  g_return_if_fail (gdk_pixbuf_get_colorspace (pixbuf) == GDK_COLORSPACE_RGB);
+  g_return_if_fail (gdk_pixbuf_get_n_channels (pixbuf) == 3 || gdk_pixbuf_get_n_channels (pixbuf) == 4);
+  g_return_if_fail (gdk_pixbuf_get_bits_per_sample (pixbuf) == 8);
 
   g_return_if_fail (drawable != NULL);
 
   if (width == -1) 
-    width = pixbuf->width;
+    width = gdk_pixbuf_get_width (pixbuf);
   if (height == -1)
-    height = pixbuf->height;
+    height = gdk_pixbuf_get_height (pixbuf);
 
   g_return_if_fail (width >= 0 && height >= 0);
-  g_return_if_fail (src_x >= 0 && src_x + width <= pixbuf->width);
-  g_return_if_fail (src_y >= 0 && src_y + height <= pixbuf->height);
+  g_return_if_fail (src_x >= 0 && src_x + width <= gdk_pixbuf_get_width (pixbuf));
+  g_return_if_fail (src_y >= 0 && src_y + height <= gdk_pixbuf_get_height (pixbuf));
 
   /* Clip to the drawable; this is required for get_from_drawable() so
    * can't be done implicitly
@@ -1573,7 +1572,7 @@
   if (!gc)
     gc = _gdk_drawable_get_scratch_gc (drawable, FALSE);
   
-  if (pixbuf->has_alpha)
+  if (gdk_pixbuf_get_has_alpha (pixbuf))
     {
       GdkVisual *visual = gdk_drawable_get_visual (drawable);
       void (*composite_func) (guchar       *src_buf,
@@ -1636,8 +1635,8 @@
 					      dest_x + x0, dest_y + y0,
 					      xs0, ys0,
 					      width1, height1);
-		  (*composite_func) (pixbuf->pixels + (src_y + y0) * pixbuf->rowstride + (src_x + x0) * 4,
-				     pixbuf->rowstride,
+		  (*composite_func) (gdk_pixbuf_get_pixels (pixbuf) + (src_y + y0) * gdk_pixbuf_get_rowstride (pixbuf) + (src_x + x0) * 4,
+				     gdk_pixbuf_get_rowstride (pixbuf),
 				     (guchar*)image->mem + ys0 * image->bpl + xs0 * image->bpp,
 				     image->bpl,
 				     visual->byte_order,
@@ -1664,10 +1663,10 @@
 						     width, height);
 	  
 	  if (composited)
-	    composite (pixbuf->pixels + src_y * pixbuf->rowstride + src_x * 4,
-		       pixbuf->rowstride,
-		       composited->pixels,
-		       composited->rowstride,
+	    composite (gdk_pixbuf_get_pixels (pixbuf) + src_y * gdk_pixbuf_get_rowstride (pixbuf) + src_x * 4,
+		       gdk_pixbuf_get_rowstride (pixbuf),
+		       gdk_pixbuf_get_pixels (composited),
+		       gdk_pixbuf_get_rowstride (composited),
 		       width, height);
 	}
     }
@@ -1679,26 +1678,26 @@
       pixbuf = composited;
     }
   
-  if (pixbuf->n_channels == 4)
+  if (gdk_pixbuf_get_n_channels (pixbuf) == 4)
     {
-      guchar *buf = pixbuf->pixels + src_y * pixbuf->rowstride + src_x * 4;
+      guchar *buf = gdk_pixbuf_get_pixels (pixbuf) + src_y * gdk_pixbuf_get_rowstride (pixbuf) + src_x * 4;
 
       gdk_draw_rgb_32_image_dithalign (drawable, gc,
 				       dest_x, dest_y,
 				       width, height,
 				       dither,
-				       buf, pixbuf->rowstride,
+				       buf, gdk_pixbuf_get_rowstride (pixbuf),
 				       x_dither, y_dither);
     }
   else				/* n_channels == 3 */
     {
-      guchar *buf = pixbuf->pixels + src_y * pixbuf->rowstride + src_x * 3;
+      guchar *buf = gdk_pixbuf_get_pixels (pixbuf) + src_y * gdk_pixbuf_get_rowstride (pixbuf) + src_x * 3;
 
       gdk_draw_rgb_image_dithalign (drawable, gc,
 				    dest_x, dest_y,
 				    width, height,
 				    dither,
-				    buf, pixbuf->rowstride,
+				    buf, gdk_pixbuf_get_rowstride (pixbuf),
 				    x_dither, y_dither);
     }
 
--- gtk+-2.12.12.orig/gdk/gdkpixbuf-drawable.c
+++ gtk+-2.12.12/gdk/gdkpixbuf-drawable.c
@@ -31,7 +31,6 @@
 #include "gdkwindow.h"
 #include "gdkpixbuf.h"
 #include "gdkpixmap.h"
-#include "gdk-pixbuf-private.h"
 #include "gdkinternals.h"
 #include "gdkalias.h"
 
@@ -1230,9 +1229,9 @@
     g_return_val_if_fail (dest_x == 0 && dest_y == 0, NULL);
   else
     {
-      g_return_val_if_fail (dest->colorspace == GDK_COLORSPACE_RGB, NULL);
-      g_return_val_if_fail (dest->n_channels == 3 || dest->n_channels == 4, NULL);
-      g_return_val_if_fail (dest->bits_per_sample == 8, NULL);
+      g_return_val_if_fail (gdk_pixbuf_get_colorspace (dest) == GDK_COLORSPACE_RGB, NULL);
+      g_return_val_if_fail (gdk_pixbuf_get_n_channels (dest) == 3 || gdk_pixbuf_get_n_channels (dest) == 4, NULL);
+      g_return_val_if_fail (gdk_pixbuf_get_bits_per_sample (dest) == 8, NULL);
     }
 
   if (cmap == NULL)
@@ -1281,8 +1280,8 @@
   if (dest)
     {
       g_return_val_if_fail (dest_x >= 0 && dest_y >= 0, NULL);
-      g_return_val_if_fail (dest_x + width <= dest->width, NULL);
-      g_return_val_if_fail (dest_y + height <= dest->height, NULL);
+      g_return_val_if_fail (dest_x + width <= gdk_pixbuf_get_width (dest), NULL);
+      g_return_val_if_fail (dest_y + height <= gdk_pixbuf_get_height (dest), NULL);
     }
 
   for (y0 = 0; y0 < height; y0 += GDK_SCRATCH_IMAGE_HEIGHT)
@@ -1348,9 +1347,9 @@
     g_return_val_if_fail (dest_x == 0 && dest_y == 0, NULL);
   else
     {
-      g_return_val_if_fail (dest->colorspace == GDK_COLORSPACE_RGB, NULL);
-      g_return_val_if_fail (dest->n_channels == 3 || dest->n_channels == 4, NULL);
-      g_return_val_if_fail (dest->bits_per_sample == 8, NULL);
+      g_return_val_if_fail (gdk_pixbuf_get_colorspace (dest) == GDK_COLORSPACE_RGB, NULL);
+      g_return_val_if_fail (gdk_pixbuf_get_n_channels (dest) == 3 || gdk_pixbuf_get_n_channels (dest) == 4, NULL);
+      g_return_val_if_fail (gdk_pixbuf_get_bits_per_sample (dest) == 8, NULL);
     }
 
   if (cmap == NULL)
@@ -1380,8 +1379,8 @@
   if (dest)
     {
       g_return_val_if_fail (dest_x >= 0 && dest_y >= 0, NULL);
-      g_return_val_if_fail (dest_x + width <= dest->width, NULL);
-      g_return_val_if_fail (dest_y + height <= dest->height, NULL);
+      g_return_val_if_fail (dest_x + width <= gdk_pixbuf_get_width (dest), NULL);
+      g_return_val_if_fail (dest_y + height <= gdk_pixbuf_get_height (dest), NULL);
     }
 
   /* Create the pixbuf if needed */
@@ -1392,14 +1391,14 @@
         return NULL;
     }
 
-  alpha = dest->has_alpha;
-  rowstride = dest->rowstride;
+  alpha = gdk_pixbuf_get_has_alpha (dest);
+  rowstride = gdk_pixbuf_get_rowstride (dest);
   bpp = alpha ? 4 : 3;
 
   /* we offset into the image data based on the position we are
    * retrieving from
    */
-  rgbconvert (src, dest->pixels +
+  rgbconvert (src, gdk_pixbuf_get_pixels (dest) +
 	      (dest_y * rowstride) + (dest_x * bpp),
 	      rowstride,
 	      alpha,
--- gtk+-2.12.12.orig/gdk/gdkpixbuf-render.c
+++ gtk+-2.12.12/gdk/gdkpixbuf-render.c
@@ -22,7 +22,6 @@
 
 #include <config.h>
 #include <gdk/gdk.h>
-#include "gdk-pixbuf-private.h"
 #include "gdkpixbuf.h"
 #include "gdkscreen.h"
 #include "gdkinternals.h"
@@ -64,19 +63,19 @@
   int status;
 
   g_return_if_fail (GDK_IS_PIXBUF (pixbuf));
-  g_return_if_fail (pixbuf->colorspace == GDK_COLORSPACE_RGB);
-  g_return_if_fail (pixbuf->n_channels == 3 || pixbuf->n_channels == 4);
-  g_return_if_fail (pixbuf->bits_per_sample == 8);
+  g_return_if_fail (gdk_pixbuf_get_colorspace (pixbuf) == GDK_COLORSPACE_RGB);
+  g_return_if_fail (gdk_pixbuf_get_n_channels (pixbuf) == 3 || gdk_pixbuf_get_n_channels (pixbuf) == 4);
+  g_return_if_fail (gdk_pixbuf_get_bits_per_sample (pixbuf) == 8);
 
   if (width == -1) 
-    width = pixbuf->width;
+    width = gdk_pixbuf_get_width (pixbuf);
   if (height == -1)
-    height = pixbuf->height;
+    height = gdk_pixbuf_get_height (pixbuf);
 
   g_return_if_fail (bitmap != NULL);
   g_return_if_fail (width >= 0 && height >= 0);
-  g_return_if_fail (src_x >= 0 && src_x + width <= pixbuf->width);
-  g_return_if_fail (src_y >= 0 && src_y + height <= pixbuf->height);
+  g_return_if_fail (src_x >= 0 && src_x + width <= gdk_pixbuf_get_width (pixbuf));
+  g_return_if_fail (src_y >= 0 && src_y + height <= gdk_pixbuf_get_height (pixbuf));
 
   g_return_if_fail (alpha_threshold >= 0 && alpha_threshold <= 255);
 
@@ -85,7 +84,7 @@
 
   gc = _gdk_drawable_get_scratch_gc (bitmap, FALSE);
 
-  if (!pixbuf->has_alpha)
+  if (!gdk_pixbuf_get_has_alpha (pixbuf))
     {
       color.pixel = (alpha_threshold == 255) ? 0 : 1;
       gdk_gc_set_foreground (gc, &color);
@@ -102,8 +101,8 @@
 
   for (y = 0; y < height; y++)
     {
-      p = (pixbuf->pixels + (y + src_y) * pixbuf->rowstride + src_x * pixbuf->n_channels
-	   + pixbuf->n_channels - 1);
+      p = (gdk_pixbuf_get_pixels (pixbuf) + (y + src_y) * gdk_pixbuf_get_rowstride (pixbuf) + src_x * gdk_pixbuf_get_n_channels (pixbuf)
+	   + gdk_pixbuf_get_n_channels (pixbuf) - 1);
 	    
       start = 0;
       start_status = *p < alpha_threshold;
@@ -123,7 +122,7 @@
 	      start_status = status;
 	    }
 	  
-	  p += pixbuf->n_channels;
+	  p += gdk_pixbuf_get_n_channels (pixbuf);
 	}
       
       if (!start_status)
--- gtk+-2.12.12.orig/gdk/gdkspawn.h
+++ gtk+-2.12.12/gdk/gdkspawn.h
@@ -23,7 +23,6 @@
 #define __GDK_SPAWN_H__
 
 #include <gdk/gdkscreen.h>
-#include <glib/gspawn.h>
 
 G_BEGIN_DECLS
 
--- gtk+-2.12.12.orig/gdk/x11/Makefile.am
+++ gtk+-2.12.12/gdk/x11/Makefile.am
@@ -69,7 +69,7 @@
 
 
 noinst_PROGRAMS = checksettings
-checksettings_LDADD = libgdk-x11.la $(GLIB_LIBS) $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la 
+checksettings_LDADD = libgdk-x11.la $(GLIB_LIBS) $(GDK_PIXBUF_LIBS)
 
 TESTS = checksettings
 
--- gtk+-2.12.12.orig/gdk-2.0.pc.in
+++ gtk+-2.12.12/gdk-2.0.pc.in
@@ -8,5 +8,5 @@
 Description: GIMP Drawing Kit (${target} target)
 Version: @VERSION@
 Requires: gdk-pixbuf-2.0 @GDK_PACKAGES@
-Libs: -L${libdir} -lgdk-${target}-@GTK_API_VERSION@ @GDK_EXTRA_LIBS@
-Cflags: -I${includedir}/gtk-2.0 -I${libdir}/gtk-2.0/include @GDK_EXTRA_CFLAGS@
+Libs: -L${libdir} -lgdk-@GTK_API_VERSION@ @GDK_EXTRA_LIBS@
+Cflags: -I${includedir}/gtk-2.0 @GDK_EXTRA_CFLAGS@
--- gtk+-2.12.12.orig/gdk-pixbuf/io-png.c
+++ gtk+-2.12.12/gdk-pixbuf/io-png.c
@@ -184,7 +184,7 @@
                              error_msg);
         }
 
-        longjmp (png_save_ptr->jmpbuf, 1);
+        longjmp (png_jmpbuf(png_save_ptr), 1);
 }
 
 static void
@@ -282,7 +282,7 @@
 		return NULL;
 	}
 
-	if (setjmp (png_ptr->jmpbuf)) {
+	if (setjmp (png_jmpbuf(png_ptr))) {
 	    	g_free (rows);
 
 		if (pixbuf)
@@ -442,7 +442,7 @@
                 return NULL;
         }
         
-	if (setjmp (lc->png_read_ptr->jmpbuf)) {
+	if (setjmp (png_jmpbuf(lc->png_read_ptr))) {
 		if (lc->png_info_ptr)
 			png_destroy_read_struct(&lc->png_read_ptr, NULL, NULL);
                 g_free(lc);
@@ -514,7 +514,7 @@
         lc->error = error;
         
         /* Invokes our callbacks as needed */
-	if (setjmp (lc->png_read_ptr->jmpbuf)) {
+	if (setjmp (png_jmpbuf(lc->png_read_ptr))) {
                 lc->error = NULL;
 		return FALSE;
 	} else {
@@ -734,7 +734,7 @@
                              error_msg);
         }
 
-        longjmp (png_read_ptr->jmpbuf, 1);
+        longjmp (png_jmpbuf(png_read_ptr), 1);
 }
 
 static void
@@ -924,7 +924,7 @@
 	       success = FALSE;
 	       goto cleanup;
        }
-       if (setjmp (png_ptr->jmpbuf)) {
+       if (setjmp (png_jmpbuf(png_ptr))) {
 	       success = FALSE;
 	       goto cleanup;
        }
--- gtk+-2.12.12.orig/gtk/Makefile.am
+++ gtk+-2.12.12/gtk/Makefile.am
@@ -34,7 +34,6 @@
 	-I$(top_builddir)/gtk				\
 	-I$(top_srcdir) -I../gdk			\
 	-I$(top_srcdir)/gdk				\
-	-I$(top_srcdir)/gdk-pixbuf -I../gdk-pixbuf	\
 	-DGDK_PIXBUF_DISABLE_DEPRECATED			\
 	-DGDK_DISABLE_DEPRECATED			\
 	-DGTK_FILE_SYSTEM_ENABLE_UNSUPPORTED		\
@@ -110,7 +109,7 @@
 # we use the general approach here
 libgtkincludedir = $(includedir)/gtk-2.0/gtk
 libadd =								\
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
+	$(GDK_PIXBUF_LIBS)						\
 	$(top_builddir)/gdk/$(gdktargetlib)				\
 	$(GTK_DEP_LIBS)
 
@@ -882,13 +881,13 @@
 	  rm -f $(MAINTAINERCLEANFILES); \
 	fi
 
-DEPS = $(gtktargetlib) $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la $(top_builddir)/gdk/$(gdktargetlib)
+DEPS = $(gtktargetlib) $(GDK_PIXBUF_DEPS) $(top_builddir)/gdk/$(gdktargetlib)
 
 TEST_DEPS = $(DEPS) gtk.immodules
 
 LDADDS =								\
 	$(gtktargetlib)							\
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
+	$(GDK_PIXBUF_LIBS)						\
 	$(top_builddir)/gdk/$(gdktargetlib)
 
 #
@@ -904,7 +903,7 @@
 
 gtk_query_immodules_2_0_SOURCES = queryimmodules.c
 
-gtk_update_icon_cache_LDADD = $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la
+gtk_update_icon_cache_LDADD = $(GDK_PIXBUF_LIBS)
 
 gtk_update_icon_cache_SOURCES = \
 	updateiconcache.c 
@@ -1170,13 +1169,7 @@
 	done								\
 	&& touch stamp-icons
 
-if CROSS_COMPILING
 gtk_update_icon_cache_program = $(GTK_UPDATE_ICON_CACHE)
-else
-gtk_update_icon_cache_program =							\
-	GDK_PIXBUF_MODULE_FILE=$(top_builddir)/gdk-pixbuf/gdk-pixbuf.loaders	\
-	   ./gtk-update-icon-cache
-endif
 
 gtkbuiltincache.h: @REBUILD@ stamp-icons
 	$(MAKE) $(AM_MAKEFLAGS) gtk-update-icon-cache$(EXEEXT)
--- gtk+-2.12.12.orig/gtk/gtkbuilderprivate.h
+++ gtk+-2.12.12/gtk/gtkbuilderprivate.h
@@ -21,9 +21,6 @@
 #ifndef __GTK_BUILDER_PRIVATE_H__
 #define __GTK_BUILDER_PRIVATE_H__
 
-#include <glib/gmarkup.h>
-#include <glib/gslist.h>
-
 #include <glib-object.h>
 #include "gtkbuilder.h"
 
--- gtk+-2.12.12.orig/gtk/gtkfilechoosersettings.c
+++ gtk+-2.12.12/gtk/gtkfilechoosersettings.c
@@ -32,7 +32,6 @@
 #include <config.h>
 #include <errno.h>
 #include <string.h>
-#include <glib/gkeyfile.h>
 #include <glib/gi18n-lib.h>
 #include "gtkfilechoosersettings.h"
 #include "gtkalias.h"
--- gtk+-2.12.12.orig/gtk/gtksearchenginesimple.c
+++ gtk+-2.12.12/gtk/gtksearchenginesimple.c
@@ -39,8 +39,6 @@
 
 #include <string.h>
 
-#include <glib/gstrfuncs.h>
-
 #define BATCH_SIZE 500
 
 typedef struct 
--- gtk+-2.12.12.orig/gtk/theme-bits/Makefile.am
+++ gtk+-2.12.12/gtk/theme-bits/Makefile.am
@@ -1,10 +1,10 @@
 INCLUDES = -I$(top_srcdir) -I$(top_builddir) 	\
 	-DGDK_PIXBUF_DISABLE_DEPRECATED		\
-	$(GDK_PIXBUF_DEP_CFLAGS)
+	$(GDK_PIXBUF_CFLAGS)
 
 noinst_PROGRAMS = decompose-bits
 
 decompose_bits_SOURCES = decompose-bits.c
-decompose_bits_LDADD = $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la
+decompose_bits_LDADD = $(GDK_PIXBUF_LIBS)
 
 EXTRA_DIST = check-13.png check-13-inconsistent.png radio-13.png radio-13-inconsistent.png
--- gtk+-2.12.12.orig/gtk+-2.0.pc.in
+++ gtk+-2.12.12/gtk+-2.0.pc.in
@@ -10,6 +10,6 @@
 Name: GTK+
 Description: GIMP Tool Kit (${target} target)
 Version: @VERSION@
-Requires: gdk-${target}-2.0 @GTK_PACKAGES@
-Libs: -L${libdir} -lgtk-${target}-@GTK_API_VERSION@ @GTK_EXTRA_LIBS@
+Requires: gdk-2.0 @GTK_PACKAGES@
+Libs: -L${libdir} -lgtk-@GTK_API_VERSION@ @GTK_EXTRA_LIBS@
 Cflags: -I${includedir}/gtk-2.0 @GTK_EXTRA_CFLAGS@
--- gtk+-2.12.12.orig/gtk+-unix-print-2.0.pc.in
+++ gtk+-2.12.12/gtk+-unix-print-2.0.pc.in
@@ -10,5 +10,5 @@
 Name: GTK+
 Description: GIMP Tool Kit Unix print support
 Version: @VERSION@
-Requires: gtk+-${target}-2.0 @GTK_PACKAGES@
+Requires: gtk+-2.0 @GTK_PACKAGES@
 Cflags: -I${includedir}/gtk-unix-print-2.0
--- gtk+-2.12.12.orig/gtk-doc.m4
+++ gtk+-2.12.12/gtk-doc.m4
@@ -0,0 +1,39 @@
+dnl -*- mode: autoconf -*-
+
+# serial 1
+
+dnl Usage:
+dnl   GTK_DOC_CHECK([minimum-gtk-doc-version])
+AC_DEFUN([GTK_DOC_CHECK],
+[
+  AC_BEFORE([AC_PROG_LIBTOOL],[$0])dnl setup libtool first
+  AC_BEFORE([AM_PROG_LIBTOOL],[$0])dnl setup libtool first
+  dnl for overriding the documentation installation directory
+  AC_ARG_WITH([html-dir],
+    AS_HELP_STRING([--with-html-dir=PATH], [path to installed docs]),,
+    [with_html_dir='${datadir}/gtk-doc/html'])
+  HTML_DIR="$with_html_dir"
+  AC_SUBST([HTML_DIR])
+
+  dnl enable/disable documentation building
+  AC_ARG_ENABLE([gtk-doc],
+    AS_HELP_STRING([--enable-gtk-doc],
+                   [use gtk-doc to build documentation [[default=no]]]),,
+    [enable_gtk_doc=no])
+
+  if test x$enable_gtk_doc = xyes; then
+    ifelse([$1],[],
+      [PKG_CHECK_EXISTS([gtk-doc],,
+                        AC_MSG_ERROR([gtk-doc not installed and --enable-gtk-doc requested]))],
+      [PKG_CHECK_EXISTS([gtk-doc >= $1],,
+                        AC_MSG_ERROR([You need to have gtk-doc >= $1 installed to build gtk-doc]))])
+  fi
+
+  AC_MSG_CHECKING([whether to build gtk-doc documentation])
+  AC_MSG_RESULT($enable_gtk_doc)
+
+  AC_PATH_PROGS(GTKDOC_CHECK,gtkdoc-check,)
+
+  AM_CONDITIONAL([ENABLE_GTK_DOC], [test x$enable_gtk_doc = xyes])
+  AM_CONDITIONAL([GTK_DOC_USE_LIBTOOL], [test -n "$LIBTOOL"])
+])
--- gtk+-2.12.12.orig/modules/engines/ms-windows/Makefile.am
+++ gtk+-2.12.12/modules/engines/ms-windows/Makefile.am
@@ -12,7 +12,7 @@
 
 
 LDADDS = \
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-2.0.la	\
+	$(GDK_PIXBUF_LIBS)				\
 	$(top_builddir)/gdk/$(gdktargetlib)		\
 	$(top_builddir)/gtk/$(gtktargetlib)		\
 	$(GTK_DEP_LIBS)
--- gtk+-2.12.12.orig/modules/engines/pixbuf/Makefile.am
+++ gtk+-2.12.12/modules/engines/pixbuf/Makefile.am
@@ -12,7 +12,7 @@
 
 LDADDS = \
 	$(GTK_DEP_LIBS)					\
-        $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-2.0.la \
+	$(GDK_PIXBUF_LIBS)				\
 	$(top_builddir)/gdk/$(gdktargetlib)		\
 	$(top_builddir)/gtk/$(gtktargetlib)		
 
--- gtk+-2.12.12.orig/modules/input/Makefile.am
+++ gtk+-2.12.12/modules/input/Makefile.am
@@ -15,13 +15,7 @@
 	$(GTK_XIM_FLAGS)				\
 	$(GTK_DEP_CFLAGS)
 
-DEPS = \
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
-	$(top_builddir)/gdk/$(gdktargetlib) 				\
-	$(top_builddir)/gtk/$(gtktargetlib)
-
 LDADDS = \
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
 	$(top_builddir)/gdk/$(gdktargetlib)        			\
 	$(top_builddir)/gtk/$(gtktargetlib) 				\
 	$(GTK_DEP_LIBS)
--- gtk+-2.12.12.orig/perf/Makefile.am
+++ gtk+-2.12.12/perf/Makefile.am
@@ -11,19 +11,19 @@
 	$(GTK_DEP_CFLAGS)
 
 DEPS =									\
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
+	$(GDK_PIXBUF_DEPS)						\
 	$(top_builddir)/gdk/$(gdktargetlib)				\
 	$(top_builddir)/gtk/$(gtktargetlib)
 
 LDADDS =								\
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
+	$(GDK_PIXBUF_LIBS)						\
 	$(top_builddir)/gdk/$(gdktargetlib)				\
 	$(top_builddir)/gtk/$(gtktargetlib)
 
 noinst_PROGRAMS	= 	\
 	testperf
 
-testperf_DEPENDENCIES = $(TEST_DEPS)
+testperf_DEPENDENCIES = $(DEPS)
 
 testperf_LDADD = $(LDADDS)
 
--- gtk+-2.12.12.orig/tests/Makefile.am
+++ gtk+-2.12.12/tests/Makefile.am
@@ -11,12 +11,12 @@
 	$(GTK_DEP_CFLAGS)
 
 DEPS =									\
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
+	$(GDK_PIXBUF_DEPS)						\
 	$(top_builddir)/gdk/$(gdktargetlib)				\
 	$(top_builddir)/gtk/$(gtktargetlib)
 
 LDADDS =								\
-	$(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la	\
+	$(GDK_PIXBUF_LIBS)						\
 	$(top_builddir)/gdk/$(gdktargetlib)				\
 	$(top_builddir)/gtk/$(gtktargetlib)
 
@@ -181,7 +181,7 @@
 testentrycompletion_LDADD = $(LDADDS)
 testfilechooser_LDADD = $(LDADDS)
 testfilechooserbutton_LDADD = $(LDADDS)
-testgtk_LDADD = $(LDADDS)
+testgtk_LDADD = $(LDADDS) $(MATH_LIB)
 testicontheme_LDADD = $(LDADDS)
 testiconview_LDADD = $(LDADDS)
 testinput_LDADD = $(LDADDS)
@@ -192,7 +192,7 @@
 testmultiscreen_LDADD = $(LDADDS)
 testnotebookdnd_LDADD = $(LDADDS)
 testnouiprint_LDADD = $(LDADDS)
-testprint_LDADD = $(LDADDS)
+testprint_LDADD = $(LDADDS) $(MATH_LIB)
 testrecentchooser_LDADD = $(LDADDS)
 testrecentchoosermenu_LDADD = $(LDADDS)
 testrgb_LDADD = $(LDADDS)
