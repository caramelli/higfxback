# This file is part of HiGFXback

# requires
REQUIRES="autotools-wrappers-lt-build libxkbcommon-build"

pkg-config --exists --print-errors $REQUIRES || exit 1

# configure (ac-2.69; am-1.15; lt-2.4.6)
libtoolize -c -f; aclocal; autoheader; autoconf; automake -a -c
rm -f external/xkbcommon-keysyms.h
./configure --disable-static --prefix=/dfb

# build
make

# install
install -d $DESTDIR/dfb/include
install -m 644 src/tsm/libtsm.h $DESTDIR/dfb/include
install -d $DESTDIR/dfb/lib
install .libs/libtsm.so.4 $DESTDIR/dfb/lib
ln -sf libtsm.so.4 $DESTDIR/dfb/lib/libtsm.so
install -d $DESTDIR/dfb/lib/pkgconfig
install -m 644 src/tsm/libtsm.pc $DESTDIR/dfb/lib/pkgconfig

# build.pc
install -d $DESTDIR/dfb/share/pkgconfig
cat > $DESTDIR/dfb/share/pkgconfig/libtsm-build.pc << EOF
Name: libtsm
Version: 4.0.0
Description: Terminal-emulator State Machine library
Requires: $REQUIRES

devel=\\
/dfb/include/libtsm.h \\
/dfb/lib/libtsm.so \\
/dfb/lib/pkgconfig/libtsm.pc

exec=\\
/dfb/lib/libtsm.so.4
EOF

exit

# patch
--- libtsm-4.0.0.orig/Makefile.in
+++ libtsm-4.0.0/Makefile.in
@@ -0,0 +1 @@
+# Makefile.in generated by automake 1.15.1
--- libtsm-4.0.0.orig/build-aux/ltmain.sh
+++ libtsm-4.0.0/build-aux/ltmain.sh
@@ -0,0 +1 @@
+# libtool (GNU libtool) 2.4.6
--- libtsm-4.0.0.orig/configure
+++ libtsm-4.0.0/configure
@@ -0,0 +1 @@
+# Generated by GNU Autoconf 2.69
--- libtsm-4.0.0.orig/configure.ac
+++ libtsm-4.0.0/configure.ac
@@ -20,6 +20,7 @@
 
 AM_INIT_AUTOMAKE([foreign 1.11 subdir-objects dist-xz no-dist-gzip tar-pax -Wall -Werror -Wno-portability])
 AM_SILENT_RULES([yes])
+AM_MAINTAINER_MODE
 
 AC_SUBST(PACKAGE_DESCRIPTION, ["terminal-emulator state machine"])
 
--- libtsm-4.0.0.orig/external/wcwidth/wcwidth.h
+++ libtsm-4.0.0/external/wcwidth/wcwidth.h
@@ -3,10 +3,14 @@
 
 #include <stdlib.h>
 
-__BEGIN_DECLS
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 int wcwidth(wchar_t ucs);
 
-__END_DECLS
+#ifdef __cplusplus
+}
+#endif
 
 #endif
--- libtsm-4.0.0.orig/src/tsm/libtsm-int.h
+++ libtsm-4.0.0/src/tsm/libtsm-int.h
@@ -133,6 +133,7 @@
 	struct line *sb_last;		/* last line; was moved last*/
 	unsigned int sb_max;		/* max-limit of lines in sb */
 	struct line *sb_pos;		/* current position in sb or NULL */
+	unsigned int sb_pos_num;	/* current numeric position in sb */
 	uint64_t sb_last_id;		/* last id given to sb-line */
 
 	/* cursor: positions are always in-bound, but cursor_x might be
--- libtsm-4.0.0.orig/src/tsm/libtsm.h
+++ libtsm-4.0.0/src/tsm/libtsm.h
@@ -199,6 +199,8 @@
 void tsm_screen_sb_page_up(struct tsm_screen *con, unsigned int num);
 void tsm_screen_sb_page_down(struct tsm_screen *con, unsigned int num);
 void tsm_screen_sb_reset(struct tsm_screen *con);
+unsigned int tsm_screen_sb_get_line_count(struct tsm_screen *con);
+unsigned int tsm_screen_sb_get_line_pos(struct tsm_screen *con);
 
 void tsm_screen_set_def_attr(struct tsm_screen *con,
 			     const struct tsm_screen_attr *attr);
@@ -256,6 +258,9 @@
 void tsm_screen_selection_target(struct tsm_screen *con,
 				 unsigned int posx,
 				 unsigned int posy);
+void tsm_screen_selection_word(struct tsm_screen *con,
+			       unsigned int posx,
+			       unsigned int posy);
 int tsm_screen_selection_copy(struct tsm_screen *con, char **out);
 
 tsm_age_t tsm_screen_draw(struct tsm_screen *con, tsm_screen_draw_cb draw_cb,
--- libtsm-4.0.0.orig/src/tsm/libtsm.sym
+++ libtsm-4.0.0/src/tsm/libtsm.sym
@@ -54,6 +54,8 @@
 	tsm_screen_sb_page_up;
 	tsm_screen_sb_page_down;
 	tsm_screen_sb_reset;
+	tsm_screen_sb_get_line_count;
+	tsm_screen_sb_get_line_pos;
 
 	tsm_screen_set_def_attr;
 	tsm_screen_reset;
@@ -97,6 +99,7 @@
 	tsm_screen_selection_reset;
 	tsm_screen_selection_start;
 	tsm_screen_selection_target;
+	tsm_screen_selection_word;
 	tsm_screen_selection_copy;
 
 	tsm_screen_draw;
--- libtsm-4.0.0.orig/src/tsm/tsm-screen.c
+++ libtsm-4.0.0/src/tsm/tsm-screen.c
@@ -224,10 +224,13 @@
 		if (con->sb_pos) {
 			if (con->sb_pos == tmp ||
 			    !(con->flags & TSM_SCREEN_FIXED_POS)) {
-				if (con->sb_pos->next)
+				if (con->sb_pos->next) {
 					con->sb_pos = con->sb_pos->next;
-				else
+					++con->sb_pos_num;
+				} else {
 					con->sb_pos = line;
+					con->sb_pos_num = 0;
+				}
 			}
 		}
 
@@ -253,6 +256,9 @@
 		con->sb_first = line;
 	con->sb_last = line;
 	++con->sb_count;
+
+	if (con->sb_pos == NULL)
+		con->sb_pos_num = con->sb_count;
 }
 
 static void screen_scroll_up(struct tsm_screen *con, unsigned int num)
@@ -824,6 +830,7 @@
 	con->sb_last = NULL;
 	con->sb_count = 0;
 	con->sb_pos = NULL;
+	con->sb_pos_num = 0;
 
 	if (con->sel_active) {
 		if (con->sel_start.line) {
@@ -853,10 +860,12 @@
 				return;
 
 			con->sb_pos = con->sb_pos->prev;
+			--con->sb_pos_num;
 		} else if (!con->sb_last) {
 			return;
 		} else {
 			con->sb_pos = con->sb_last;
+			con->sb_pos_num = con->sb_count - 1;
 		}
 	}
 }
@@ -872,8 +881,10 @@
 	con->age = con->age_cnt;
 
 	while (num--) {
-		if (con->sb_pos)
+		if (con->sb_pos) {
 			con->sb_pos = con->sb_pos->next;
+			++con->sb_pos_num;
+		}
 		else
 			return;
 	}
@@ -910,6 +921,27 @@
 	con->age = con->age_cnt;
 
 	con->sb_pos = NULL;
+	con->sb_pos_num = con->sb_count;
+}
+
+SHL_EXPORT
+unsigned int tsm_screen_sb_get_line_count(struct tsm_screen *con)
+{
+	if (!con) {
+		return 0;
+	}
+
+	return con->sb_count;
+}
+
+SHL_EXPORT
+unsigned int tsm_screen_sb_get_line_pos(struct tsm_screen *con)
+{
+	if (!con) {
+		return 0;
+	}
+
+	return con->sb_pos_num;
 }
 
 SHL_EXPORT
--- libtsm-4.0.0.orig/src/tsm/tsm-selection.c
+++ libtsm-4.0.0/src/tsm/tsm-selection.c
@@ -81,6 +81,44 @@
 	sel->y = y;
 }
 
+static void word_select(struct tsm_screen *con,
+			unsigned int posx,
+			unsigned int posy)
+{
+	int start, end;
+	struct line *line;
+
+	selection_set(con, &con->sel_start, posx, posy);
+
+	if (con->sel_start.line)
+		line = con->sel_start.line;
+	else
+	 	line = con->lines[con->sel_start.y];
+
+	if (!line || line->cells[posx].ch == ' ')
+		return;
+
+	for (start = posx; start >= 0; start--) {
+		if (line->cells[start].ch == ' ') {
+			start++;
+			break;
+		}
+	}
+	if (start < 0)
+		start = 0;
+
+	for (end = posx; end < line->size; end++) {
+		if (line->cells[end].ch == ' ' || line->cells[end].ch == '\n' ||
+		    line->cells[end].ch == '\0') {
+			end--;
+			break;
+		}
+	}
+	con->sel_start.x = start;
+	selection_set(con, &con->sel_end, end, posy);
+	con->sel_active = true;
+}
+
 SHL_EXPORT
 void tsm_screen_selection_reset(struct tsm_screen *con)
 {
@@ -126,6 +164,21 @@
 	selection_set(con, &con->sel_end, posx, posy);
 }
 
+SHL_EXPORT
+void tsm_screen_selection_word(struct tsm_screen *con,
+			       unsigned int posx,
+			       unsigned int posy)
+{
+	if (!con)
+		return;
+
+	screen_inc_age(con);
+	/* TODO: more sophisticated ageing */
+	con->age = con->age_cnt;
+
+	word_select(con, posx, posy);
+}
+
 /* TODO: tsm_ucs4_to_utf8 expects UCS4 characters, but a cell contains a
  * tsm-symbol (which can contain multiple UCS4 chars). Fix this when introducing
  * support for combining characters. */
--- libtsm-4.0.0.orig/src/tsm/tsm-vte.c
+++ libtsm-4.0.0/src/tsm/tsm-vte.c
@@ -1899,12 +1899,52 @@
 	vte->osc_len += len;
 }
 
-static void do_osc_end(struct tsm_vte *vte) {
+static void vte_write_xcolor(struct tsm_vte *vte, const char *code,
+			     const char *end_seq,
+			     uint8_t r, uint8_t g, uint8_t b)
+{
+	char buf[32];
+	snprintf(buf, sizeof(buf), "\e]%s;rgb:%02x%02x/%02x%02x/%02x%02x%s",
+		 code, r, r, g, g, b, b, end_seq);
+	vte_write(vte, buf, strlen(buf));
+}
+
+static bool do_osc_internal(struct tsm_vte *vte, const char *end_seq)
+{
+	if (!strncmp(vte->osc_arg, "10;?", 4)) {
+		vte_write_xcolor(vte, "10", end_seq,
+				 vte->def_attr.fr, vte->def_attr.fg,
+				 vte->def_attr.fb);
+		return true;
+	}
+	if (!strncmp(vte->osc_arg, "11;?", 4)) {
+		vte_write_xcolor(vte, "11", end_seq,
+				 vte->def_attr.br, vte->def_attr.bg,
+				 vte->def_attr.bb);
+		return true;
+	}
+	return false;
+}
+
+static const char *osc_end_seq(uint32_t end)
+{
+	if (end == 0x07) {
+		return "\x07";
+	}
+	return "\x1b\x5c";
+}
+
+static void do_osc_end(struct tsm_vte *vte, uint32_t end) {
+	const char *end_seq = osc_end_seq(end);
+	vte->osc_arg[vte->osc_len] = 0;
+	if (do_osc_internal(vte, end_seq)) {
+		return;
+	}
+
 	if (!vte->osc_cb) {
 		return;
 	}
 
-	vte->osc_arg[vte->osc_len] = 0;
 	vte->osc_cb(vte, vte->osc_arg, vte->osc_len, vte->osc_data);
 }
 
@@ -1955,7 +1995,7 @@
 			do_osc_collect(vte, data);
 			break;
 		case ACTION_OSC_END:
-			do_osc_end(vte);
+			do_osc_end(vte, data);
 			break;
 		default:
 			llog_warning(vte, "invalid action %d", action);

# source
https://github.com/kmscon/libtsm/archive/libtsm-4.0.0/libtsm-4.0.0.tar.gz
