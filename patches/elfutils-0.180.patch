# This file is part of HiGFXback

# requires
REQUIRES="autotools-wrappers-am-build"

pkg-config --exists --print-errors $REQUIRES || exit 1

pkg-config --exists xz-build && REQUIRES="$REQUIRES xz-build"

# configure (ac-2.69; am-1.16)
aclocal -I m4; autoheader; autoconf; automake -a -c
./configure --disable-debuginfod --prefix=

# build
make

# install
install -d $DESTDIR/bin
install src/addr2line $DESTDIR/bin/eu-addr2line
install src/ar $DESTDIR/bin/eu-ar
install src/elfclassify $DESTDIR/bin/eu-elfclassify
install src/elfcmp $DESTDIR/bin/eu-elfcmp
install src/elfcompress $DESTDIR/bin/eu-elfcompress
install src/elflint $DESTDIR/bin/eu-elflint
install src/findtextrel $DESTDIR/bin/eu-findtextrel
install src/make-debug-archive $DESTDIR/bin/eu-make-debug-archive
install src/nm $DESTDIR/bin/eu-nm
install src/objdump $DESTDIR/bin/eu-objdump
install src/ranlib $DESTDIR/bin/eu-ranlib
install src/readelf $DESTDIR/bin/eu-readelf
install src/size $DESTDIR/bin/eu-size
install src/stack $DESTDIR/bin/eu-stack
install src/strings $DESTDIR/bin/eu-strings
install src/strip $DESTDIR/bin/eu-strip
install src/unstrip $DESTDIR/bin/eu-unstrip
install -d $DESTDIR/include
install -m 644 libdw/dwarf.h $DESTDIR/include
install -m 644 libelf/gelf.h $DESTDIR/include
install -m 644 libelf/libelf.h $DESTDIR/include
install -d $DESTDIR/include/elfutils
install -m 644 version.h $DESTDIR/include/elfutils
install -m 644 libdw/libdw.h $DESTDIR/include/elfutils
install -m 644 libdwelf/libdwelf.h $DESTDIR/include/elfutils
install -m 644 libdwfl/libdwfl.h $DESTDIR/include/elfutils
install -d $DESTDIR/lib
install libasm/libasm.so $DESTDIR/lib/libasm.so.1
ln -sf libasm.so.1 $DESTDIR/lib/libasm.so
install libdw/libdw.so $DESTDIR/lib/libdw.so.1
ln -sf libdw.so.1 $DESTDIR/lib/libdw.so
install libelf/libelf.so $DESTDIR/lib/libelf.so.1
ln -sf libelf.so.1 $DESTDIR/lib/libelf.so
install -d $DESTDIR/lib/pkgconfig
install -m 644 config/libdw.pc $DESTDIR/lib/pkgconfig
install -m 644 config/libelf.pc $DESTDIR/lib/pkgconfig

# build.pc
install -d $DESTDIR/share/pkgconfig
cat > $DESTDIR/share/pkgconfig/elfutils-build.pc << EOF
Name: elfutils
Version: 0.180
Description: libraries and tools for ELF files and DWARF data
Requires: $REQUIRES

devel=\\
/include/dwarf.h \\
/include/gelf.h \\
/include/libelf.h \\
/include/elfutils/libdw.h \\
/include/elfutils/libdwelf.h \\
/include/elfutils/libdwfl.h \\
/include/elfutils/version.h \\
/lib/libasm.so \\
/lib/libdw.so \\
/lib/libelf.so \\
/lib/pkgconfig/libdw.pc \\
/lib/pkgconfig/libelf.pc

exec=\\
/bin/eu-addr2line \\
/bin/eu-ar \\
/bin/eu-elfclassify \\
/bin/eu-elfcmp \\
/bin/eu-elfcompress \\
/bin/eu-elflint \\
/bin/eu-findtextrel \\
/bin/eu-make-debug-archive \\
/bin/eu-nm \\
/bin/eu-objdump \\
/bin/eu-ranlib \\
/bin/eu-readelf \\
/bin/eu-size \\
/bin/eu-stack \\
/bin/eu-strings \\
/bin/eu-strip \\
/bin/eu-unstrip \\
/lib/libasm.so.1 \\
/lib/libdw.so.1 \\
/lib/libelf.so.1
EOF

exit

# patch
--- elfutils-0.180.orig/configure.ac
+++ elfutils-0.180/configure.ac
@@ -538,6 +538,60 @@
 fi
 AC_SUBST([argp_LDADD])
 
+dnl Check if we have fts available from our libc
+AC_LINK_IFELSE(
+	[AC_LANG_PROGRAM(
+		[#if !defined(__x86_64__)
+		#undef  _FILE_OFFSET_BITS
+		#define _FILE_OFFSET_BITS 32
+		#endif
+		#include <fts.h>],
+		[FTS* fts = 0; return fts_close(fts); return 0;]
+		)],
+	[libc_has_fts="true"],
+	[libc_has_fts="false"]
+)
+
+dnl If our libc doesn't provide fts, then test for libfts
+if test "$libc_has_fts" = "false" ; then
+	AC_MSG_WARN("libc does not have fts")
+	AC_CHECK_LIB([fts], [fts_close], [have_fts="true"], [have_fts="false"])
+
+	if test "$have_fts" = "false"; then
+		AC_MSG_ERROR("no libfts found")
+	else
+		fts_LDADD="-lfts"
+	fi
+else
+	fts_LDADD=""
+fi
+AC_SUBST([fts_LDADD])
+
+dnl Check if we have obstack available from our libc
+AC_LINK_IFELSE(
+	[AC_LANG_PROGRAM(
+		[#include <obstack.h>],
+		[_obstack_begin(0, 0, 0, NULL, NULL); return 0;]
+		)],
+	[libc_has_obstack="true"],
+	[libc_has_obstack="false"]
+)
+
+dnl If our libc doesn't provide obstack, then test for libobstack
+if test "$libc_has_obstack" = "false" ; then
+	AC_MSG_WARN("libc does not have obstack")
+	AC_CHECK_LIB([obstack], [_obstack_begin], [have_obstack="true"], [have_obstack="false"])
+
+	if test "$have_obstack" = "false"; then
+		AC_MSG_ERROR("no libobstack found")
+	else
+		obstack_LDADD="-lobstack"
+	fi
+else
+	obstack_LDADD=""
+fi
+AC_SUBST([obstack_LDADD])
+
 dnl The directories with content.
 
 dnl Documentation.
--- elfutils-0.180.orig/lib/error.h
+++ elfutils-0.180/lib/error.h
@@ -0,0 +1,27 @@
+#ifndef _ERROR_H_
+#define _ERROR_H_
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+static unsigned int error_message_count = 0;
+
+static inline void error(int status, int errnum, const char* format, ...)
+{
+	va_list ap;
+	fprintf(stderr, "%s: ", program_invocation_name);
+	va_start(ap, format);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	if (errnum)
+		fprintf(stderr, ": %s", strerror(errnum));
+	fprintf(stderr, "\n");
+	error_message_count++;
+	if (status)
+		exit(status);
+}
+
+#endif
--- elfutils-0.180.orig/lib/fixedsizehash.h
+++ elfutils-0.180/lib/fixedsizehash.h
@@ -30,7 +30,6 @@
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/cdefs.h>
 
 #include <system.h>
 
--- elfutils-0.180.orig/lib/libeu.h
+++ elfutils-0.180/lib/libeu.h
@@ -39,7 +39,6 @@
 extern char *xstrdup (const char *) __attribute__ ((__malloc__));
 extern char *xstrndup (const char *, size_t) __attribute__ ((__malloc__));
 
-
 extern uint32_t crc32 (uint32_t crc, unsigned char *buf, size_t len);
 extern int crc32_file (int fd, uint32_t *resp);
 
--- elfutils-0.180.orig/lib/system.h
+++ elfutils-0.180/lib/system.h
@@ -152,4 +152,11 @@
   extern int never_defined_just_used_for_checking[(expr) ? 1 : -1]	\
     __attribute__ ((unused))
 
+static inline const char *
+xbasename(const char *s)
+{
+  const char *p = strrchr(s, '/');
+  return p ? p+1 : s;
+}
+
 #endif /* system.h */
--- elfutils-0.180.orig/libdw/Makefile.am
+++ elfutils-0.180/libdw/Makefile.am
@@ -109,7 +109,7 @@
 		../libcpu/libcpu_pic.a libdw_pic.a ../libdwelf/libdwelf_pic.a \
 		../libdwfl/libdwfl_pic.a
 libdw_so_DEPS = ../lib/libeu.a ../libelf/libelf.so
-libdw_so_LDLIBS = $(libdw_so_DEPS) -ldl -lz $(argp_LDADD) $(zip_LIBS) -pthread
+libdw_so_LDLIBS = $(libdw_so_DEPS) -ldl -lz $(argp_LDADD) $(fts_LDADD) $(zip_LIBS) -pthread
 libdw_so_SOURCES =
 libdw.so$(EXEEXT): $(srcdir)/libdw.map $(libdw_so_LIBS) $(libdw_so_DEPS)
 	$(AM_V_CCLD)$(LINK) $(dso_LDFLAGS) -o $@ \
--- elfutils-0.180.orig/libdw/dwarf_getsrc_file.c
+++ elfutils-0.180/libdw/dwarf_getsrc_file.c
@@ -37,6 +37,7 @@
 #include <string.h>
 
 #include "libdwP.h"
+#include "system.h"
 
 
 int
@@ -70,10 +71,10 @@
       if (INTUSE(dwarf_getsrclines) (cudie, &lines, &nlines) != 0)
 	{
 	  /* Ignore a CU that just has no DW_AT_stmt_list at all.  */
-	  int error = INTUSE(dwarf_errno) ();
-	  if (error == 0)
+	  int result = INTUSE(dwarf_errno) ();
+	  if (result == 0)
 	    continue;
-	  __libdw_seterrno (error);
+	  __libdw_seterrno (result);
 	  return -1;
 	}
 
@@ -98,7 +99,7 @@
 	      /* Match the name with the name the user provided.  */
 	      const char *fname2 = line->files->info[lastfile].name;
 	      if (is_basename)
-		lastmatch = strcmp (basename (fname2), fname) == 0;
+		lastmatch = strcmp (xbasename (fname2), fname) == 0;
 	      else
 		lastmatch = strcmp (fname2, fname) == 0;
 	    }
--- elfutils-0.180.orig/libdwfl/core-file.c
+++ elfutils-0.180/libdwfl/core-file.c
@@ -40,12 +40,11 @@
 
 /* On failure return, we update *NEXT to point back at OFFSET.  */
 static inline Elf *
-do_fail (int error, off_t *next, off_t offset)
+do_fail (int err, off_t *next, off_t offset)
 {
     if (next != NULL)
       *next = offset;
-    //__libelf_seterrno (error);
-    __libdwfl_seterrno (DWFL_E (LIBELF, error));
+    __libdwfl_seterrno (DWFL_E (LIBELF, err));
     return NULL;
 }
 
@@ -590,7 +589,7 @@
       if (! __libdwfl_dynamic_vaddr_get (module->elf, &file_dynamic_vaddr))
 	continue;
       Dwfl_Module *mod;
-      mod = __libdwfl_report_elf (dwfl, basename (module->name), module->name,
+      mod = __libdwfl_report_elf (dwfl, xbasename (module->name), module->name,
 				  module->fd, module->elf,
 				  module->l_ld - file_dynamic_vaddr,
 				  true, true);
--- elfutils-0.180.orig/libdwfl/dwfl_build_id_find_elf.c
+++ elfutils-0.180/libdwfl/dwfl_build_id_find_elf.c
@@ -167,9 +167,9 @@
   int fd = __libdwfl_open_mod_by_build_id (mod, false, file_name);
   if (fd >= 0)
     {
-      Dwfl_Error error = __libdw_open_file (&fd, elfp, true, false);
-      if (error != DWFL_E_NOERROR)
-	__libdwfl_seterrno (error);
+      Dwfl_Error result = __libdw_open_file (&fd, elfp, true, false);
+      if (result != DWFL_E_NOERROR)
+	__libdwfl_seterrno (result);
       else if (__libdwfl_find_build_id (mod, false, *elfp) == 2)
 	{
 	  /* This is a backdoor signal to short-circuit the ID refresh.  */
--- elfutils-0.180.orig/libdwfl/dwfl_error.c
+++ elfutils-0.180/libdwfl/dwfl_error.c
@@ -154,7 +154,16 @@
   switch (error &~ 0xffff)
     {
     case OTHER_ERROR (ERRNO):
+#if defined(__GLIBC__)
       return strerror_r (error & 0xffff, "bad", 0);
+#else
+      {
+        static __thread char buf[128] = "";
+        if (0 == strerror_r(error & 0xffff, buf, sizeof(buf)))
+          return buf;
+      }
+      return "strerror_r() failed";
+#endif
     case OTHER_ERROR (LIBELF):
       return elf_errmsg (error & 0xffff);
     case OTHER_ERROR (LIBDW):
--- elfutils-0.180.orig/libdwfl/dwfl_module_getdwarf.c
+++ elfutils-0.180/libdwfl/dwfl_module_getdwarf.c
@@ -76,9 +76,9 @@
 static inline Dwfl_Error
 open_elf (Dwfl_Module *mod, struct dwfl_file *file)
 {
-  Dwfl_Error error = open_elf_file (&file->elf, &file->fd, &file->name);
-  if (error != DWFL_E_NOERROR)
-    return error;
+  Dwfl_Error result = open_elf_file (&file->elf, &file->fd, &file->name);
+  if (result != DWFL_E_NOERROR)
+    return result;
 
   GElf_Ehdr ehdr_mem, *ehdr = gelf_getehdr (file->elf, &ehdr_mem);
   if (ehdr == NULL)
@@ -576,9 +576,9 @@
 	 because they open the Elf anyway for sanity checking.
 	 Otherwise open either the given file name or use the fd
 	 returned.  */
-      Dwfl_Error error = open_elf_file (&mod->alt_elf, &mod->alt_fd,
-					&altfile);
-      if (error == DWFL_E_NOERROR)
+      Dwfl_Error result = open_elf_file (&mod->alt_elf, &mod->alt_fd,
+					 &altfile);
+      if (result == DWFL_E_NOERROR)
 	{
 	  mod->alt = INTUSE(dwarf_begin_elf) (mod->alt_elf,
 					      DWARF_C_READ, NULL);
@@ -970,12 +970,12 @@
   if (rawdata == NULL)
     return;
 
-  Dwfl_Error error;
+  Dwfl_Error result;
   void *buffer = NULL;
   size_t size = 0;
-  error = __libdw_unlzma (-1, 0, rawdata->d_buf, rawdata->d_size,
-			  &buffer, &size);
-  if (error == DWFL_E_NOERROR)
+  result = __libdw_unlzma (-1, 0, rawdata->d_buf, rawdata->d_size,
+			   &buffer, &size);
+  if (result == DWFL_E_NOERROR)
     {
       if (unlikely (size == 0))
 	free (buffer);
@@ -1327,12 +1327,12 @@
       if (cb->section_address == NULL)
 	return DWFL_E_NOREL;
 
-      Dwfl_Error error = __libdwfl_module_getebl (mod);
-      if (error != DWFL_E_NOERROR)
-	return error;
+      Dwfl_Error result = __libdwfl_module_getebl (mod);
+      if (result != DWFL_E_NOERROR)
+	return result;
 
       find_symtab (mod);
-      Dwfl_Error result = mod->symerr;
+      result = mod->symerr;
       if (result == DWFL_E_NOERROR)
 	result = __libdwfl_relocate (mod, debugfile->elf, true);
       if (result != DWFL_E_NOERROR)
--- elfutils-0.180.orig/libdwfl/dwfl_module_getsrc_file.c
+++ elfutils-0.180/libdwfl/dwfl_module_getsrc_file.c
@@ -32,6 +32,7 @@
 
 #include "libdwflP.h"
 #include "../libdw/libdwP.h"
+#include "system.h"
 
 
 static inline const char *
@@ -75,10 +76,10 @@
   Dwfl_Line **match = *nsrcs == 0 ? NULL : *srcsp;
 
   struct dwfl_cu *cu = NULL;
-  Dwfl_Error error;
-  while ((error = __libdwfl_nextcu (mod, cu, &cu)) == DWFL_E_NOERROR
+  Dwfl_Error result;
+  while ((result = __libdwfl_nextcu (mod, cu, &cu)) == DWFL_E_NOERROR
 	 && cu != NULL
-	 && (error = __libdwfl_cu_getsrclines (cu)) == DWFL_E_NOERROR)
+	 && (result = __libdwfl_cu_getsrclines (cu)) == DWFL_E_NOERROR)
     {
       /* Search through all the line number records for a matching
 	 file and line/column number.  If any of the numbers is zero,
@@ -103,7 +104,7 @@
 		{
 		  /* Match the name with the name the user provided.  */
 		  lastfile = file;
-		  lastmatch = !strcmp (is_basename ? basename (file) : file,
+		  lastmatch = !strcmp (is_basename ? xbasename (file) : file,
 				       fname);
 		}
 	    }
--- elfutils-0.180.orig/libdwfl/dwfl_segment_report_module.c
+++ elfutils-0.180/libdwfl/dwfl_segment_report_module.c
@@ -675,7 +675,7 @@
 	      bias += fixup;
 	      if (module->name[0] != '\0')
 		{
-		  name = basename (module->name);
+		  name = xbasename (module->name);
 		  name_is_final = true;
 		}
 	      break;
@@ -724,8 +724,8 @@
       fd = open (name, O_RDONLY);
       if (fd >= 0)
 	{
-	  Dwfl_Error error = __libdw_open_file (&fd, &elf, true, false);
-	  if (error == DWFL_E_NOERROR)
+	  Dwfl_Error result = __libdw_open_file (&fd, &elf, true, false);
+	  if (result == DWFL_E_NOERROR)
 	    invalid = invalid_elf (elf, true /* disk_file_has_build_id */,
 				   build_id, build_id_len);
 	}
--- elfutils-0.180.orig/libdwfl/find-debuginfo.c
+++ elfutils-0.180/libdwfl/find-debuginfo.c
@@ -103,10 +103,10 @@
 	  /* We need to open an Elf handle on the file so we can check its
 	     build ID note for validation.  Backdoor the handle into the
 	     module data structure since we had to open it early anyway.  */
-	  Dwfl_Error error = __libdw_open_file (&fd, &mod->alt_elf,
-						false, false);
-	  if (error != DWFL_E_NOERROR)
-	    __libdwfl_seterrno (error);
+	  Dwfl_Error result = __libdw_open_file (&fd, &mod->alt_elf,
+						 false, false);
+	  if (result != DWFL_E_NOERROR)
+	    __libdwfl_seterrno (result);
 	  else
 	    {
 	      const void *alt_build_id;
@@ -136,9 +136,9 @@
 	 module data structure since we had to open it early anyway.  */
 
       mod->debug.valid = false;
-      Dwfl_Error error = __libdw_open_file (&fd, &mod->debug.elf, false, false);
-      if (error != DWFL_E_NOERROR)
-	__libdwfl_seterrno (error);
+      Dwfl_Error result = __libdw_open_file (&fd, &mod->debug.elf, false, false);
+      if (result != DWFL_E_NOERROR)
+	__libdwfl_seterrno (result);
       else if (likely (__libdwfl_find_build_id (mod, false,
 						mod->debug.elf) == 2))
 	/* Also backdoor the gratuitous flag.  */
@@ -165,7 +165,7 @@
 {
   bool cancheck = debuglink_crc != (GElf_Word) 0;
 
-  const char *file_basename = file_name == NULL ? NULL : basename (file_name);
+  const char *file_basename = file_name == NULL ? NULL : xbasename (file_name);
   char *localname = NULL;
 
   /* We invent a debuglink .debug name if NULL, but then want to try the
@@ -279,7 +279,7 @@
 	  else
 	    {
 	      subdir = NULL;
-	      file = basename (debuglink_file);
+	      file = xbasename (debuglink_file);
 	    }
 	  try_file_basename = debuglink_null;
 	  break;
@@ -307,7 +307,7 @@
 	    if (mod->dw != NULL && (p[0] == '\0' || p[0] == '/'))
 	      {
 		fd = try_open (&main_stat, dir, ".dwz",
-			       basename (file), &fname);
+			       xbasename (file), &fname);
 		if (fd < 0)
 		  {
 		    if (errno != ENOENT && errno != ENOTDIR)
--- elfutils-0.180.orig/libdwfl/link_map.c
+++ elfutils-0.180/libdwfl/link_map.c
@@ -249,12 +249,12 @@
 
   void *buffer = NULL;
   size_t buffer_available = 0;
-  inline int release_buffer (int result)
+  inline int release_buffer (int res)
   {
     if (buffer != NULL)
       (void) (*memory_callback) (dwfl, -1, &buffer, &buffer_available, 0, 0,
 				 memory_callback_arg);
-    return result;
+    return res;
   }
 
   GElf_Addr addrs[4];
@@ -309,7 +309,7 @@
   GElf_Addr next = addrs[0];
 
   Dwfl_Module **lastmodp = &dwfl->modulelist;
-  int result = 0;
+  int res = 0;
 
   /* There can't be more elements in the link_map list than there are
      segments.  DWFL->lookup_elts is probably twice that number, so it
@@ -372,7 +372,7 @@
 	  r_debug_info_module = malloc (sizeof (*r_debug_info_module)
 					+ strlen (name1) + 1);
 	  if (unlikely (r_debug_info_module == NULL))
-	    return release_buffer (result);
+	    return release_buffer (res);
 	  r_debug_info_module->fd = -1;
 	  r_debug_info_module->elf = NULL;
 	  r_debug_info_module->l_ld = l_ld;
@@ -393,9 +393,9 @@
 	  if (fd >= 0)
 	    {
 	      Elf *elf;
-	      Dwfl_Error error = __libdw_open_file (&fd, &elf, true, false);
+	      Dwfl_Error result = __libdw_open_file (&fd, &elf, true, false);
 	      GElf_Addr elf_dynamic_vaddr;
-	      if (error == DWFL_E_NOERROR
+	      if (result == DWFL_E_NOERROR
 		  && __libdwfl_dynamic_vaddr_get (elf, &elf_dynamic_vaddr))
 		{
 		  const void *build_id_bits;
@@ -444,7 +444,7 @@
 		      if (r_debug_info_module == NULL)
 			{
 			  // XXX hook for sysroot
-			  mod = __libdwfl_report_elf (dwfl, basename (name),
+			  mod = __libdwfl_report_elf (dwfl, xbasename (name),
 						      name, fd, elf, base,
 						      true, true);
 			  if (mod != NULL)
@@ -475,7 +475,7 @@
 
       if (mod != NULL)
 	{
-	  ++result;
+	  ++res;
 
 	  /* Move this module to the end of the list, so that we end
 	     up with a list in the same order as the link_map chain.  */
@@ -498,7 +498,7 @@
 	}
     }
 
-  return release_buffer (result);
+  return release_buffer (res);
 }
 
 static GElf_Addr
@@ -810,12 +810,12 @@
 
 	      int fd = open (dwfl->user_core->executable_for_core, O_RDONLY);
 	      Elf *elf;
-	      Dwfl_Error error = DWFL_E_ERRNO;
+	      Dwfl_Error result = DWFL_E_ERRNO;
 	      if (fd != -1)
-		error = __libdw_open_file (&fd, &elf, true, false);
-	      if (error != DWFL_E_NOERROR)
+		result = __libdw_open_file (&fd, &elf, true, false);
+	      if (result != DWFL_E_NOERROR)
 		{
-		  __libdwfl_seterrno (error);
+		  __libdwfl_seterrno (result);
 		  return false;
 		}
 	      GElf_Ehdr ehdr_mem, *ehdr = gelf_getehdr (elf, &ehdr_mem);
--- elfutils-0.180.orig/libdwfl/linux-kernel-modules.c
+++ elfutils-0.180/libdwfl/linux-kernel-modules.c
@@ -116,7 +116,7 @@
 	/* Try the file's unadorned basename as DEBUGLINK_FILE,
 	   to look only for "vmlinux" files.  */
 	fd = INTUSE(dwfl_standard_find_debuginfo) (&fakemod, NULL, NULL, 0,
-						   *fname, basename (*fname),
+						   *fname, xbasename (*fname),
 						   0, &fakemod.debug.name);
 
       if (fakemod.debug.name != NULL)
@@ -824,7 +824,7 @@
     alternate_name[0] = '\0';
 
   FTSENT *f;
-  int error = ENOENT;
+  int err = ENOENT;
   while ((f = fts_read (fts)) != NULL)
     {
       /* Skip a "source" subtree, which tends to be large.
@@ -836,7 +836,7 @@
 	  continue;
 	}
 
-      error = ENOENT;
+      err = ENOENT;
       switch (f->fts_info)
 	{
 	case FTS_F:
@@ -866,7 +866,7 @@
 	case FTS_ERR:
 	case FTS_DNR:
 	case FTS_NS:
-	  error = f->fts_errno;
+	  err = f->fts_errno;
 	  break;
 
 	case FTS_SLNONE:
@@ -878,7 +878,7 @@
   fts_close (fts);
   free (modulesdir[0]);
   free (alternate_name);
-  errno = error;
+  errno = err;
   return -1;
 }
 INTDEF (dwfl_linux_kernel_find_elf)
--- elfutils-0.180.orig/libelf/elf.h
+++ elfutils-0.180/libelf/elf.h
@@ -21,6 +21,16 @@
 
 #include <features.h>
 
+#if !defined(__GLIBC__)
+#ifdef  __cplusplus
+# define __BEGIN_DECLS  extern "C" {
+# define __END_DECLS    }
+#else
+# define __BEGIN_DECLS
+# define __END_DECLS
+#endif
+#endif
+
 __BEGIN_DECLS
 
 /* Standard ELF types.  */
--- elfutils-0.180.orig/src/Makefile.am
+++ elfutils-0.180/src/Makefile.am
@@ -46,7 +46,7 @@
 else
 libasm = ../libasm/libasm.so
 libdw = ../libdw/libdw.so
-libelf = ../libelf/libelf.so
+libelf = ../libelf/libelf.so $(obstack_LDADD)
 endif
 libebl = ../libebl/libebl.a ../backends/libebl_backends.a ../libcpu/libcpu.a
 libeu = ../lib/libeu.a
--- elfutils-0.180.orig/src/addr2line.c
+++ elfutils-0.180/src/addr2line.c
@@ -374,7 +374,7 @@
 		  if (file == NULL)
 		    file = "???";
 		  else if (only_basenames)
-		    file = basename (file);
+		    file = xbasename (file);
 		  else if (use_comp_dir && file[0] != '/')
 		    {
 		      const char *const *dirs;
@@ -558,7 +558,7 @@
   const char *comp_dir_sep = "";
 
   if (only_basenames)
-    src = basename (src);
+    src = xbasename (src);
   else if (use_comp_dir && src[0] != '/')
     {
       Dwarf_Attribute attr;
--- elfutils-0.180.orig/src/ar.c
+++ elfutils-0.180/src/ar.c
@@ -1129,7 +1129,7 @@
       for (int cnt = 0; cnt < argc; ++cnt)
 	{
 	  ENTRY entry;
-	  entry.key = full_path ? argv[cnt] : basename (argv[cnt]);
+	  entry.key = full_path ? argv[cnt] : (char*)xbasename (argv[cnt]);
 	  entry.data = &argv[cnt];
 	  if (hsearch (entry, ENTER) == NULL)
 	    error (EXIT_FAILURE, errno,
@@ -1239,7 +1239,7 @@
       /* Open all the new files, get their sizes and add all symbols.  */
       for (int cnt = 0; cnt < argc; ++cnt)
 	{
-	  const char *bname = basename (argv[cnt]);
+	  const char *bname = xbasename (argv[cnt]);
 	  size_t bnamelen = strlen (bname);
 	  if (found[cnt] == NULL)
 	    {
--- elfutils-0.180.orig/src/arlib.h
+++ elfutils-0.180/src/arlib.h
@@ -29,6 +29,12 @@
 #include <stdint.h>
 #include <sys/types.h>
 
+#if !defined(ALLPERMS)
+# define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)
+#endif
+#if !defined(DEFFILEMODE)
+# define DEFFILEMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
+#endif
 
 /* State of -D/-U flags.  */
 extern bool arlib_deterministic_output;
--- elfutils-0.180.orig/src/elfcompress.c
+++ elfutils-0.180/src/elfcompress.c
@@ -37,6 +37,14 @@
 #include "libeu.h"
 #include "printversion.h"
 
+#if !defined(FNM_EXTMATCH)
+# define FNM_EXTMATCH 0
+#endif
+
+#if !defined(ALLPERMS)
+# define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO) /* 07777 */
+#endif
+
 /* Name and version of program.  */
 ARGP_PROGRAM_VERSION_HOOK_DEF = print_version;
 
--- elfutils-0.180.orig/src/nm.c
+++ elfutils-0.180/src/nm.c
@@ -1421,7 +1421,7 @@
 			  int lineno;
 			  (void) dwarf_lineno (line, &lineno);
 			  const char *file = dwarf_linesrc (line, NULL, NULL);
-			  file = (file != NULL) ? basename (file) : "???";
+			  file = (file != NULL) ? xbasename (file) : "???";
 			  int n;
 			  n = obstack_printf (&whereob, "%s:%d%c", file,
 					      lineno, '\0');
@@ -1452,7 +1452,7 @@
 		{
 		  /* We found the line.  */
 		  int n = obstack_printf (&whereob, "%s:%" PRIu64 "%c",
-					  basename ((*found)->file),
+					  xbasename ((*found)->file),
 					  (*found)->lineno,
 					  '\0');
 		  sym_mem[nentries_used].where = obstack_finish (&whereob);
--- elfutils-0.180.orig/src/readelf.c
+++ elfutils-0.180/src/readelf.c
@@ -1582,7 +1582,7 @@
   /* Get the data of the section.  */
   Elf_Data *data = elf_getdata (scn, NULL);
 
-  Elf_Scn *symscn = elf_getscn (ebl->elf, shdr->sh_link);
+  Elf_Scn *symscn = shdr ? elf_getscn (ebl->elf, shdr->sh_link) : NULL;
   GElf_Shdr symshdr_mem;
   GElf_Shdr *symshdr = gelf_getshdr (symscn, &symshdr_mem);
   Elf_Data *symdata = elf_getdata (symscn, NULL);
@@ -3490,14 +3490,14 @@
 		       elf_ndxscn (scn), elf_errmsg (-1));
 	    }
 
-	  if (shdr->sh_type == SHT_HASH)
+	  if (shdr && shdr->sh_type == SHT_HASH)
 	    {
 	      if (ebl_sysvhash_entrysize (ebl) == sizeof (Elf64_Xword))
 		handle_sysv_hash64 (ebl, scn, shdr, shstrndx);
 	      else
 		handle_sysv_hash (ebl, scn, shdr, shstrndx);
 	    }
-	  else if (shdr->sh_type == SHT_GNU_HASH)
+	  else if (shdr && shdr->sh_type == SHT_GNU_HASH)
 	    handle_gnu_hash (ebl, scn, shdr, shstrndx);
 	}
     }
--- elfutils-0.180.orig/src/stack.c
+++ elfutils-0.180/src/stack.c
@@ -147,7 +147,7 @@
 
   int width = get_addr_width (mod);
   printf ("0x%0*" PRIx64 "-0x%0*" PRIx64 " %s\n",
-	  width, start, width, end, basename (name));
+	  width, start, width, end, xbasename (name));
 
   const unsigned char *id;
   GElf_Addr id_vaddr;
--- elfutils-0.180.orig/src/strip.c
+++ elfutils-0.180/src/strip.c
@@ -46,6 +46,14 @@
 #include <system.h>
 #include <printversion.h>
 
+#if !defined(FNM_EXTMATCH)
+# define FNM_EXTMATCH 0
+#endif
+
+#if !defined(ACCESSPERMS)
+#define ACCESSPERMS (S_IRWXU|S_IRWXG|S_IRWXO)
+#endif
+
 typedef uint8_t GElf_Byte;
 
 /* Name and version of program.  */
@@ -1743,7 +1751,7 @@
 		 elf_errmsg (-1));
 	}
 
-      char *debug_basename = basename (debug_fname_embed ?: debug_fname);
+      const char *debug_basename = xbasename (debug_fname_embed ?: debug_fname);
       off_t crc_offset = strlen (debug_basename) + 1;
       /* Align to 4 byte boundary */
       crc_offset = ((crc_offset - 1) & ~3) + 4;
--- elfutils-0.180.orig/src/unstrip.c
+++ elfutils-0.180/src/unstrip.c
@@ -56,6 +56,15 @@
 # define _(str) gettext (str)
 #endif
 
+#ifndef strndupa
+#define strndupa(s, n) \
+       (__extension__ ({const char *__in = (s);                    \
+                        size_t __len = strnlen (__in, (n)) + 1;    \
+                        char *__out = (char *) alloca (__len);     \
+                        __out[__len-1] = '\0';                     \
+                        (char *) memcpy (__out, __in, __len-1);}))
+#endif
+
 /* Name and version of program.  */
 ARGP_PROGRAM_VERSION_HOOK_DEF = print_version;
 
@@ -1548,8 +1557,8 @@
 	error (EXIT_FAILURE, 0,
 	       _("cannot find matching section for [%zu] '%s'"),
 	       elf_ndxscn (scn), name);
-
-      sec->outscn = scn;
+      else
+        sec->outscn = scn;
     }
 
   /* If that failed due to changes made by prelink, we take another tack.

# source
https://sourceware.org/pub/elfutils/0.180/elfutils-0.180.tar.bz2
